<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Analysis</title>

<script src="site_libs/header-attrs-2.11/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/paper.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/pagedtable-1.1/css/pagedtable.css" rel="stylesheet" />
<script src="site_libs/pagedtable-1.1/js/pagedtable.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>


<link rel="stylesheet" href="my-style.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Supporting material for pliman's paper</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">
    <span class="fa fa-home"></span>
     
    About
  </a>
</li>
<li>
  <a href="code.html">
    <span class="fa fa-file-code-o"></span>
     
    Analysis
  </a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/TiagoOlivoto/paper_pliman">
    <span class="fa fa-github-square"></span>
     
    Source
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Analysis</h1>

</div>


<div id="packages" class="section level1" number="1">
<h1 number="1"><span class="header-section-number">1</span> Packages</h1>
<p>To reproduce the examples of this material, the following packages are needed.</p>
<pre class="r"><code>library(tidyverse)  # data manipulation and plots
## -- Attaching packages --------------------------------------- tidyverse 1.3.1 --
## v ggplot2 3.3.5     v purrr   0.3.4
## v tibble  3.1.4     v dplyr   1.0.7
## v tidyr   1.1.3     v stringr 1.4.0
## v readr   2.0.2     v forcats 0.5.1
## -- Conflicts ------------------------------------------ tidyverse_conflicts() --
## x dplyr::filter() masks stats::filter()
## x dplyr::lag()    masks stats::lag()
library(pliman)     # plant image analysis
## |=======================================================|
## | Tools for Plant Image Analysis (pliman 0.3.0)         |
## | Author: Tiago Olivoto                                 |
## | Type &#39;vignette(&#39;pliman_start&#39;)&#39; for a short tutorial  |
## | Visit &#39;https://bit.ly/pliman&#39; for a complete tutorial |
## |=======================================================|
library(DescTools)  # concordance correlation coefficient
library(rio)        # import/export data
library(LeafArea)   # leaf area
library(ggrepel)    # plots
library(ggh4x)      # plots
library(GGally)     # pairwise correlation plots
## Registered S3 method overwritten by &#39;GGally&#39;:
##   method from   
##   +.gg   ggplot2</code></pre>
</div>
<div id="installing-pliman" class="section level1" number="2">
<h1 number="2"><span class="header-section-number">2</span> Installing pliman</h1>
<p>To install the released version of <code>pliman</code> from CRAN type:</p>
<pre class="r"><code>install.packages(&quot;pliman&quot;)</code></pre>
<p>The latest development version of <code>pliman</code> can be installed from the GitHub repository. The installation process requires the <code>devtools</code> package, which needs to be installed first. If you are a Windows user, you should also first download and install the latest version of <a href="https://cran.r-project.org/bin/windows/Rtools/">Rtools</a>.</p>
<pre class="r"><code>if(!require(devtools)) install.packages(&quot;devtools&quot;)</code></pre>
<p>After <code>devtools</code> is properly installed, you can install <code>pliman</code> by running the following code. Please, note that the installation will also download the dependencies required to run the package.</p>
<pre class="r"><code>devtools::install_github(&quot;TiagoOlivoto/pliman&quot;)</code></pre>
<p>Them, load <code>pliman</code> by running</p>
<pre class="r"><code>library(pliman)</code></pre>
</div>
<div id="helper-functions" class="section level1" number="3">
<h1 number="3"><span class="header-section-number">3</span> Helper functions</h1>
<pre class="r"><code># helper function to compute concordance statistics
get_ccc &lt;- function(df, predicted, real){
  if(is.grouped_df(df)){
    df %&gt;% 
      group_modify(~get_ccc(.x, {{predicted}}, {{real}})) %&gt;% 
      ungroup()
  } else{
    predicted &lt;- pull(df, {{predicted}})
    real &lt;- pull(df, {{real}})
    cor &lt;- CCC(real, predicted, na.rm = TRUE)
    data.frame(r = cor(real, predicted, use = &quot;pairwise.complete.obs&quot;),
               pc = cor$rho.c[[1]],
               lwr_ci = cor$rho.c[[2]],
               upr_ci = cor$rho.c[[3]],
               bc = cor$C.b)
  }
}

# helper function to plot the CCC in ggpairs()
custom_ccc &lt;- function(data, mapping,...){
  data2 &lt;- data
  data2$x &lt;- as.numeric(data[,as_label(mapping$x)])
  data2$y &lt;- as.numeric(data[,as_label(mapping$y)])
  data2$group &lt;- data[,as_label(mapping$colour)]
  correlation_df &lt;- data2 %&gt;% 
    group_by(group) %&gt;%
    summarize(estimate = round(as.numeric(DescTools::CCC(x, y)$rho.c[1]),3))
  ggplot(data=correlation_df, aes(x=1,y=group, color = group))+
    geom_text(aes(label = paste0(&quot;rho[c]: &quot;, estimate)),
              data = correlation_df,
              parse = TRUE,
              size = 4)
}
custom_smoth &lt;- function(data, mapping, method=&quot;lm&quot;, ...){
  p &lt;- ggplot(data = data, mapping = mapping) + 
    geom_abline(color = &quot;black&quot;,
                intercept = 0,
                size = 0.7,
                slope = 1,
                linetype = 2) +
    geom_point(alpha = 0.6,
               shape = 21,
               size = 2.5,
               stroke = 0,
               color = &quot;black&quot;) 
  p
}

# ggplot theme
my_theme &lt;- function(){
  theme_grey() %+%
    theme(legend.position = &quot;bottom&quot;,
          legend.box.margin=margin(-10,-10,-10,-10),
          legend.title = element_blank(),
          axis.ticks.length = unit(0.2, &quot;cm&quot;),
          panel.grid = element_blank(),
          panel.spacing = unit(0, &quot;cm&quot;),
          panel.background = element_rect(color = &quot;black&quot;, fill = NA),
          axis.text = element_text(color = &quot;black&quot;, size = 10),
          axis.title = element_text(color = &quot;black&quot;, size = 10),
          legend.key = element_rect(fill = NA),
          strip.background = element_rect(color = &quot;black&quot;, fill = NA))
}</code></pre>
</div>
<div id="image-manipulation" class="section level1" number="4">
<h1 number="4"><span class="header-section-number">4</span> Image manipulation</h1>
<div id="importing-images" class="section level2" number="4.1">
<h2 number="4.1"><span class="header-section-number">4.1</span> Importing images</h2>
<pre class="r"><code>soy &lt;- image_import(&quot;data/soy_grains.jpg&quot;)
soy2 &lt;- image_import(&quot;data/soy_grains_2.jpg&quot;)</code></pre>
<p>To import a list of images, the argument <code>pattern</code> of the function <code>image_import()</code> is used. All images that match the pattern name are imported into a list.</p>
<pre class="r"><code>soy_list &lt;- 
  image_import(pattern = &quot;soy_&quot;,
               path = &quot;./data&quot;) # choose path directory
names(soy_list)
## [1] &quot;soy_grains.jpg&quot;   &quot;soy_grains_2.JPG&quot;</code></pre>
</div>
<div id="displaying-images" class="section level2" number="4.2">
<h2 number="4.2"><span class="header-section-number">4.2</span> Displaying images</h2>
<p>Single images are displayed with <code>plot()</code>. For combining images, the function <code>image_combine()</code> is used. Users can inform either a comma-separated list of objects or a list of objects of class <code>Image</code>.</p>
<pre class="r"><code># Single images
plot(soy)</code></pre>
<p><img src="code_files/figure-html/display1-1.png" width="1152" /></p>
<pre class="r"><code># Combine images
image_combine(soy, soy2)</code></pre>
<p><img src="code_files/figure-html/display2-1.png" width="1152" /></p>
<pre class="r"><code># Combine images
image_combine(soy_list)</code></pre>
<p><img src="code_files/figure-html/display2-2.png" width="1152" /></p>
</div>
<div id="manipulating-images" class="section level2" number="4.3">
<h2 number="4.3"><span class="header-section-number">4.3</span> Manipulating images</h2>
<p><code>pliman</code> provides a set of <code>image_*()</code> functions to perform image manipulation and transformation of unique images or a list of images based on the <a href="https://www.bioconductor.org/packages/release/bioc/vignettes/EBImage/inst/doc/EBImage-introduction.html">EBImage package</a>.</p>
<div id="resize-an-image" class="section level3" number="4.3.1">
<h3 number="4.3.1"><span class="header-section-number">4.3.1</span> Resize an image</h3>
<p>Sometimes resizing of high-resolution images is needed to reduce the processing time. The function <code>image_resize()</code> is used to resize an image. The argument <code>rel_size</code> can be used to resize the image by relative size. For example, by setting <code>rel_size = 50</code> to an image of width 1280 x 720, the new image will have a size of 640 x 360. This is useful to speed up the time of analysis such as those computed with <code>analyze_objects()</code> and <code>measure_disease()</code>.</p>
<pre class="r"><code>image_dimension(soy)
## 
## ----------------------
## Image dimension
## ----------------------
## Width :  1281 
## Height:  910
soy_resized &lt;- image_resize(soy, rel_size = 50)
image_dimension(soy_resized)
## 
## ----------------------
## Image dimension
## ----------------------
## Width :  640 
## Height:  455</code></pre>
</div>
<div id="crop-an-image" class="section level3" number="4.3.2">
<h3 number="4.3.2"><span class="header-section-number">4.3.2</span> Crop an image</h3>
<p>Cropping images is useful to remove noises from the image edge, as well as to reduce the size of images before processing. To crop an image, the function <code>image_crop()</code> is used. Users need to inform a numeric vector indicating the pixel range (<code>width</code> and <code>height</code>) that will be maintained in the cropped image.</p>
<pre class="r"><code>crop1 &lt;-
  image_crop(soy,
             width = 170:720,
             height = 300:650,
             plot = TRUE)</code></pre>
<p><img src="code_files/figure-html/unnamed-chunk-5-1.png" width="672" /></p>
<p>If only <code>width</code> or <code>height</code> are informed, the image will be cropped vertically or horizontally.</p>
<pre class="r"><code>crop2 &lt;-
  image_crop(soy,
             width = 170:720,
             plot = TRUE)</code></pre>
<p><img src="code_files/figure-html/unnamed-chunk-6-1.png" width="672" /></p>
<p>If both <code>width</code> and <code>height</code> are missing, an iterative process of image cropping is performed.</p>
<pre class="r"><code># only run in an iterative section
image_crop(soy)</code></pre>
<p>Additionally, an automated cropping process can be performed. In this case, the image will be automatically cropped to the area of objects with an edge of five pixels by default.</p>
<pre class="r"><code>auto_crop &lt;- image_autocrop(soy, plot = TRUE)</code></pre>
<p><img src="code_files/figure-html/unnamed-chunk-8-1.png" width="672" /></p>
<p>The function <code>image_trim()</code> is used to trim pixels from image edges.</p>
<pre class="r"><code># trim 100 pixels from all edges
soy_trim &lt;- image_trim(soy, edge = 100, plot = TRUE)

# The same is achieved with
soy_trim2 &lt;-
  image_trim(soy,
             top = 100,
             bottom = 100,
             left = 100,
             right = 100,
             plot = TRUE)</code></pre>
<p><img src="code_files/figure-html/manipulate2-1.png" width="960" /></p>
<pre class="r"><code># trim 200 pixels from top and bottom
soy_trim3 &lt;-
  image_trim(soy,
             top = 200,
             bottom = 200,
             plot = TRUE)</code></pre>
<p><img src="code_files/figure-html/manipulate2-2.png" width="960" /></p>
<pre class="r"><code># trim to 5 pixels around objects&#39; area</code></pre>
</div>
<div id="dpi" class="section level3" number="4.3.3">
<h3 number="4.3.3"><span class="header-section-number">4.3.3</span> Image resolution (DPI)</h3>
<p>The function <code>dpi()</code> runs an interactive function to compute the image resolution given a known distance informed by the user. To compute the image resolution (dpi) the user must use the left button mouse to create a line of known distance. This can be done, for example, using a template with known distance in the image (e.g., <code>leaves.JPG</code>).</p>
<pre class="r"><code># only run in an interactive section
leaves &lt;- image_import(&quot;./data/leaf_area/leaves.JPG&quot;)
dpi(leaves)</code></pre>
<iframe width="760" height="430" src="https://www.youtube.com/embed/Rh10_pLgeng" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen>
</iframe>
</div>
<div id="rotate-an-image" class="section level3" number="4.3.4">
<h3 number="4.3.4"><span class="header-section-number">4.3.4</span> Rotate an image</h3>
<p><code>image_rotate()</code> is used to rotates the image clockwise by the given angle.</p>
<pre class="r"><code>soy_rotated &lt;- image_rotate(soy, angle = 45, plot = TRUE)</code></pre>
<p><img src="code_files/figure-html/manipulate3-1.png" width="672" /></p>
</div>
<div id="horizontal-and-vertical-reflection" class="section level3" number="4.3.5">
<h3 number="4.3.5"><span class="header-section-number">4.3.5</span> Horizontal and vertical reflection</h3>
<p><code>image_hreflect()</code> and <code>image_vreflect()</code> performs vertical and horizontal reflection of images, respectively.</p>
<pre class="r"><code>soy_hrefl &lt;- image_hreflect(soy)
soy_vrefl &lt;- image_vreflect(soy)
image_combine(soy, soy_hrefl, soy_vrefl, ncol = 3)</code></pre>
<p><img src="code_files/figure-html/manipulate4-1.png" width="1920" /></p>
</div>
<div id="horizontal-and-vertical-conversion" class="section level3" number="4.3.6">
<h3 number="4.3.6"><span class="header-section-number">4.3.6</span> Horizontal and vertical conversion</h3>
<p><code>image_horizontal()</code> and <code>image_vertical()</code> converts (if needed) an image to a horizontal or vertical image, respectively.</p>
<pre class="r"><code>soy_h &lt;- image_horizontal(soy)
soy_v &lt;- image_vertical(soy)
image_combine(soy, soy_h, soy_v, ncol = 3)</code></pre>
<p><img src="code_files/figure-html/manipulate5-1.png" width="1920" /></p>
</div>
<div id="filter-blur-contrast-dilatation-and-erosion" class="section level3" number="4.3.7">
<h3 number="4.3.7"><span class="header-section-number">4.3.7</span> Filter, blur, contrast, dilatation, and erosion</h3>
<pre class="r"><code>soy_filter &lt;- image_filter(soy)
soy_blur &lt;- image_blur(soy)
soy_contrast &lt;- image_contrast(soy)
soy_dilatation &lt;- image_dilate(soy)
soy_erosion &lt;- image_erode(soy)
image_combine(soy, soy_filter, soy_blur, soy_contrast, soy_dilatation, soy_erosion)</code></pre>
<p><img src="code_files/figure-html/manipulate6-1.png" width="960" /></p>
</div>
<div id="exporting-images" class="section level3" number="4.3.8">
<h3 number="4.3.8"><span class="header-section-number">4.3.8</span> Exporting images</h3>
<p>To export images to the current directory, use the function <code>image_export()</code>. If a list of images is exported, the images will be saved considering the name and extension present in the list. If no extension is present, the images will be saved as <code>*.jpg</code> files.</p>
<pre class="r"><code>image_export(soy, &quot;exported.jpg&quot;)</code></pre>
</div>
<div id="combining-functions" class="section level3" number="4.3.9">
<h3 number="4.3.9"><span class="header-section-number">4.3.9</span> Combining functions</h3>
<p><code>pliman</code> offers the possibility of combining functions with the new R base (4.1) forward pipe operator <code>|&gt;</code>.</p>
<pre class="r"><code># temporary directory
a &lt;- image_import(pattern = &quot;soy_grains&quot;,
                  path = &quot;./data&quot;)
image_combine(a)</code></pre>
<p><img src="code_files/figure-html/combiningfunct-1.png" width="960" /></p>
<pre class="r"><code># reduce resolution, autocrop, vertical rotation,
# create a binary image, export
a |&gt;
  image_resize(rel_size = 50) |&gt;
  image_blur() |&gt;
  image_autocrop() |&gt;
  image_vertical() |&gt;
  image_binary(index = &quot;NB&quot;,
               show_image = FALSE,
               resize = FALSE) |&gt;
  image_combine()</code></pre>
<p><img src="code_files/figure-html/combiningfunct-2.png" width="960" /></p>
</div>
</div>
</div>
<div id="image-segmentation" class="section level1" number="5">
<h1 number="5"><span class="header-section-number">5</span> Image segmentation</h1>
<p>In <code>pliman</code> the following functions can be used to segment an image.</p>
<ul>
<li><code>image_binary()</code> to produce a binary (black and white) image</li>
<li><code>image_segment()</code> to produce a segmented image (image objects and a white background).</li>
<li><code>image_segment_iter()</code> to segment an image iteratively.</li>
</ul>
<p>Both functions segment the image based on the value of some image index, which may be one of the RGB bands or any operation with these bands. Internally, these functions call <code>image_index()</code> to compute these indexes. The following indexes are currently available.</p>
<table>
<thead>
<tr class="header">
<th>Index</th>
<th align="center">Equation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>R</td>
<td align="center">R</td>
</tr>
<tr class="even">
<td>G</td>
<td align="center">G</td>
</tr>
<tr class="odd">
<td>B</td>
<td align="center">B</td>
</tr>
<tr class="even">
<td>NR</td>
<td align="center">R/(R+G+B)</td>
</tr>
<tr class="odd">
<td>NG</td>
<td align="center">G/(R+G+B)</td>
</tr>
<tr class="even">
<td>NB</td>
<td align="center">B/(R+G+B)</td>
</tr>
<tr class="odd">
<td>GB</td>
<td align="center">G/B</td>
</tr>
<tr class="even">
<td>RB</td>
<td align="center">R/B</td>
</tr>
<tr class="odd">
<td>GR</td>
<td align="center">G/R</td>
</tr>
<tr class="even">
<td>BI</td>
<td align="center">sqrt((R^2+G^2+B^2)/3)</td>
</tr>
<tr class="odd">
<td>BIM</td>
<td align="center">sqrt((R*2+G*2+B*2)/3)</td>
</tr>
<tr class="even">
<td>SCI</td>
<td align="center">(R-G)/(R+G)</td>
</tr>
<tr class="odd">
<td>GLI</td>
<td align="center">(2*G-R-B)/(2*G+R+B)</td>
</tr>
<tr class="even">
<td>HI</td>
<td align="center">(2*R-G-B)/(G-B)</td>
</tr>
<tr class="odd">
<td>NGRDI</td>
<td align="center">(G-R)/(G+R)</td>
</tr>
<tr class="even">
<td>NDGBI</td>
<td align="center">(G-B)/(G+B)</td>
</tr>
<tr class="odd">
<td>NDRBI</td>
<td align="center">(R-B)/(R+B)</td>
</tr>
<tr class="even">
<td>I</td>
<td align="center">R+G+B</td>
</tr>
<tr class="odd">
<td>S</td>
<td align="center">((R+G+B)-3*B)/(R+G+B)</td>
</tr>
<tr class="even">
<td>VARI</td>
<td align="center">(G-R)/(G+R-B)</td>
</tr>
<tr class="odd">
<td>HUE</td>
<td align="center">atan(2*(B-G-R)/30.5*(G-R))</td>
</tr>
<tr class="even">
<td>HUE2</td>
<td align="center">atan(2*(R-G-R)/30.5*(G-B))</td>
</tr>
<tr class="odd">
<td>BGI</td>
<td align="center">B/G</td>
</tr>
<tr class="even">
<td>L</td>
<td align="center">R+G+B/3</td>
</tr>
<tr class="odd">
<td>GRAY</td>
<td align="center">0.299*R + 0.587*G + 0.114*B</td>
</tr>
</tbody>
</table>
<p>Here, I use the argument <code>index"</code> to test the segmentation based on the RGB and their normalized values. Users can also provide their own index with the argument <code>my_index</code>.</p>
<pre class="r"><code>soy &lt;- image_import(&quot;data/segmentation/seg_medium.jpg&quot;, plot = TRUE)</code></pre>
<p><img src="code_files/figure-html/segmentation1-1.png" width="672" /></p>
<pre class="r"><code># Compute the indexes
indexes &lt;- image_index(soy, index = c(&quot;R, G, B, NR, NG, NB&quot;))</code></pre>
<p><img src="code_files/figure-html/segmentation2-1.png" width="960" /></p>
<pre class="r"><code># Create a raster plot with the RGB values
plot(indexes)</code></pre>
<p><img src="code_files/figure-html/segmentation2-2.png" width="960" /></p>
<pre class="r"><code># Create a histogram with the RGB values
plot(indexes, type = &quot;hist&quot;)</code></pre>
<p><img src="code_files/figure-html/segmentation2-3.png" width="960" /></p>
<p>In this example, we can see the distribution of the RGB values (first row) and the normalized RGB values (second row). The two peaks represent the grains (smaller peak) and the blue background (larger peak). The clearer the difference between these peaks, the better will the image segmentation.</p>
<div id="segment-an-image" class="section level2" number="5.1">
<h2 number="5.1"><span class="header-section-number">5.1</span> Segment an image</h2>
<p>The function <code>image_segmentation()</code> is used to segment images using image indexes. In this example, I will use the same indexes computed below to see how the image is segmented. The output of this function can be used as input in the function <code>analyze_objects()</code>.</p>
<pre class="r"><code>segmented &lt;- image_segment(soy, index = c(&quot;R, G, B, NR, NG, NB&quot;))</code></pre>
<p><img src="code_files/figure-html/segmentation3-1.png" width="960" /></p>
<p>It seems that the <code>"NB"</code> index provided better segmentation. <code>"R"</code> and <code>"NR"</code> resulted in an inverted segmented image, i.e., the grains were considered as background and the remaining as ‘selected’ image. To circumvent this problem, we can use the argument <code>invert</code> in those functions.</p>
<pre class="r"><code>image_segment(soy,
              index = c(&quot;R, NR&quot;),
              invert = TRUE)</code></pre>
<p><img src="code_files/figure-html/segmentation4-1.png" width="960" /></p>
</div>
<div id="iterative-segmentation" class="section level2" number="5.2">
<h2 number="5.2"><span class="header-section-number">5.2</span> Iterative segmentation</h2>
<p>The function <code>image_segment_iter()</code> provides an iterative image segmentation, returning the proportions of segmented pixels. This is useful when more than one segmentation procedure is needed. Users can choose how many segmentation perform, using the argument <code>nseg</code>.</p>
<pre class="r"><code>seg_iter &lt;- image_import(image_pliman(&quot;sev_leaf_nb.jpg&quot;), plot = TRUE)</code></pre>
<p><img src="code_files/figure-html/segmentation5-1.png" width="672" /></p>
<p>Using a soybean sample leaf (above), I will use the function <code>image_segment_iter</code> to segment the diseased tissue from healthy tissue. The aim is to segment the symptoms into two classes, namely, necrosis (brown areas) and chlorosis (yellow areas), and compute the percentage of each symptom class.</p>
<p>First, we need to find a suitable index for segmentation.</p>
<pre class="r"><code># First segmentation
seg &lt;-
  image_segment(seg_iter,
                index = &quot;all&quot;)</code></pre>
<p><img src="code_files/figure-html/segmentation6-1.png" width="960" /></p>
<pre class="r"><code># second segmentation
seg2 &lt;-
  image_segment(seg$VARI$image,
                index = &quot;all&quot;)</code></pre>
<p><img src="code_files/figure-html/segmentation6-2.png" width="960" /></p>
<p>Note that the same results can be obtainet with <code>image_segment_iter()</code> using an iterative section.</p>
<pre class="r"><code># Only run iteratively
image_segment_iter(seg_iter, nseg = 2)</code></pre>
<p>The <code>"VARI"</code> seems to be a suitable index to segment symptoms (necrosis and chlorosis) from healthy tissues. The <code>"GLI"</code> can be used to segment necrosis from chlorosis. Knowing this, we can now use <code>image_segment_iter()</code> explicitly indicating these indexes, as follows</p>
<pre class="r"><code>image_segment_iter(seg_iter,
                   nseg = 2, # two segmentations
                   index = c(&quot;VARI&quot;, &quot;GLI&quot;),
                   ncol = 3)
##      image  pixels   percent
## 1 original 1317600 100.00000
## 2     seg1  399075  30.28802
## 3     seg2  103464  25.92595</code></pre>
<p><img src="code_files/figure-html/segmentation8-1.png" width="960" /></p>
<p>It can be observed that 30.28% of the original image were characterized as symptoms (both necrosis and chlorosis). Of out this (symptomatic area), 25.92% are necrotic areas. So 7.85% of the total area were considered as necrotic areas (30.288 <span class="math inline">\(\times\)</span> 0.2592 or 103464/1317600 <span class="math inline">\(\times\)</span> 100) and 22.43% (30.28 - 7.85 or (399075 - 103464) / 1317600 <span class="math inline">\(\times\)</span> 100) were considered as chlorotic areas.</p>
<p>Users can use the argument <code>threshold</code> to controls how segmentation is made. By default (<code>threshold = "Otsu"</code>), a threshold value based on Otsu’s method is used to reduce the grayscale image to a binary image. If a numeric value is informed, this value will be used as a threshold. Inform any non-numeric value different than <code>"Otsu"</code> to iteratively chosen the threshold based on a raster plot showing pixel intensity of the index. For <code>image_segmentation_iter()</code>, a vector (allows a mixed (numeric and character) type) with the same length of <code>nseg</code> can be used.</p>
<pre class="r"><code>seg_iter1 &lt;-
  image_segment_iter(seg_iter,
                     nseg = 2, # two segmentations
                     index = c(&quot;VARI&quot;, &quot;GLI&quot;),
                     threshold = c(0.3, &quot;Otsu&quot;),
                     ncol = 3,
                     show_image = FALSE)
##      image  pixels   percent
## 1 original 1317600 100.00000
## 2     seg1  195288  14.82149
## 3     seg2   95151  48.72342
seg_iter2 &lt;-
  image_segment_iter(seg_iter,
                     nseg = 2, # two segmentations
                     index = c(&quot;VARI&quot;, &quot;GLI&quot;),
                     threshold = c(0.5, &quot;Otsu&quot;),
                     ncol = 3,
                     show_image = FALSE)
##      image  pixels   percent
## 1 original 1317600 100.00000
## 2     seg1  321729  24.41781
## 3     seg2  101883  31.66733
image_combine(seg_iter1$images$seg1,
              seg_iter2$images$seg1)</code></pre>
<p><img src="code_files/figure-html/segmentation9-1.png" width="960" /></p>
<p>Users can then set the argument <code>threshold</code> for their specific case, depending on the aims of the segmentation.</p>
</div>
</div>
<div id="producing-a-binary-image" class="section level1" number="6">
<h1 number="6"><span class="header-section-number">6</span> Producing a binary image</h1>
<p>We can also produce a binary image with <code>image_binary()</code>. Just for curiosity, we will use the indexes <code>"B"</code> (blue) and <code>"NB"</code> (normalized blue). By default, <code>image_binary()</code> rescales the image to 30% of the size of the original image to speed up the computation time. Use the argument <code>resize = FALSE</code> to produce a binary image with the original size.</p>
<pre class="r"><code>binary &lt;- image_binary(soy)</code></pre>
<p><img src="code_files/figure-html/binary1-1.png" width="960" /></p>
<pre class="r"><code># original image size
image_binary(soy,
             index = c(&quot;B, NB&quot;),
             resize = FALSE)</code></pre>
<p><img src="code_files/figure-html/binary1-2.png" width="960" /></p>
</div>
<div id="count-objects" class="section level1" number="7">
<h1 number="7"><span class="header-section-number">7</span> Count objects</h1>
<div id="check-the-better-index-to-segment-the-image" class="section level2" number="7.1">
<h2 number="7.1"><span class="header-section-number">7.1</span> Check the better index to segment the image</h2>
<ul>
<li>Blue background</li>
</ul>
<pre class="r"><code># wheat (NB)
dir_wb &lt;- &quot;./data/count_objects/images/img_wb_50_1.jpg&quot;
wb &lt;- image_import(image = dir_wb)
image_binary(wb)</code></pre>
<p><img src="code_files/figure-html/unnamed-chunk-10-1.png" width="960" /></p>
<pre class="r"><code># soybean (NB)
dir_sb &lt;- &quot;./data/count_objects/images/img_sb_50_1.jpg&quot;
sb &lt;- image_import(image = dir_sb)
image_binary(sb)</code></pre>
<p><img src="code_files/figure-html/unnamed-chunk-10-2.png" width="960" /></p>
<pre class="r"><code># bean (NR with invert= TRUE)
dir_bb &lt;- &quot;./data/count_objects/images/img_bb_50_1.jpg&quot;
bb &lt;- image_import(image = dir_bb)
image_binary(bb)</code></pre>
<p><img src="code_files/figure-html/unnamed-chunk-10-3.png" width="960" /></p>
<pre class="r"><code>### SOYBEAN

# mid-resolution images (_50) and with no filtering
t1 &lt;-
  system.time(
    sb_res_50_nf &lt;-
      analyze_objects(pattern = &quot;sb_50&quot;,
                      dir_original = &quot;data/count_objects/images&quot;,
                      show_image = FALSE,
                      parallel = TRUE,
                      verbose = FALSE)
  )

# mid-resolution images (_50) and with filtering
t2 &lt;-
  system.time(
    sb_res_50_wf &lt;-
      analyze_objects(pattern = &quot;sb_50&quot;,
                      dir_original = &quot;/data/count_objects/images&quot;,
                      show_image = FALSE,
                      parallel = TRUE,
                      filter = 2,
                      verbose = FALSE)
  )

# high-resolution images (_100) and with no filtering
t3 &lt;-
  system.time(
    sb_res_100_nf &lt;-
      analyze_objects(pattern = &quot;sb_100&quot;,
                      dir_original = &quot;/data/count_objects/images&quot;,
                      show_image = FALSE,
                      parallel = TRUE,
                      verbose = FALSE)
  )


# low-resolution images (_100) and with filtering
t4 &lt;-
  system.time(
    sb_res_100_wf &lt;-
      analyze_objects(pattern = &quot;sb_100&quot;,
                      dir_original = &quot;/data/count_objects/images&quot;,
                      show_image = FALSE,
                      parallel = TRUE,
                      filter = 3,
                      verbose = FALSE)
  )








### WHEAT

# mid-resolution images (_50) and with no filtering
wb_res_50_nf &lt;-
  analyze_objects(pattern = &quot;wb_50&quot;,
                  dir_original = &quot;/data/count_objects/images&quot;,
                  show_image = FALSE,
                  parallel = TRUE,
                  verbose = FALSE)

# mid-resolution images (_50) and with filtering
wb_res_50_wf &lt;-
  analyze_objects(pattern = &quot;wb_50&quot;,
                  dir_original = &quot;/data/count_objects/images&quot;,
                  show_image = FALSE,
                  parallel = TRUE,
                  filter = 2,
                  verbose = FALSE)

# high-resolution images (_100) and with no filtering
wb_res_100_nf &lt;-
  analyze_objects(pattern = &quot;wb_100&quot;,
                  dir_original = &quot;/data/count_objects/images&quot;,
                  show_image = FALSE,
                  parallel = TRUE,
                  verbose = FALSE)


# low-resolution images (_100) and with filtering
wb_res_100_wf &lt;-
  analyze_objects(pattern = &quot;wb_100&quot;,
                  dir_original = &quot;/data/count_objects/images&quot;,
                  show_image = FALSE,
                  parallel = TRUE,
                  filter = 3,
                  verbose = FALSE)





### BEAN

# mid-resolution images (_50) and with no filtering
bb_res_50_nf &lt;-
  analyze_objects(pattern = &quot;bb_50&quot;,
                  dir_original = &quot;/data/count_objects/images&quot;,
                  index = &quot;NR&quot;,
                  invert = TRUE,
                  show_image = FALSE,
                  parallel = TRUE,
                  verbose = FALSE)

# mid-resolution images (_50) and with filtering
bb_res_50_wf &lt;-
  analyze_objects(pattern = &quot;bb_50&quot;,
                  dir_original = &quot;/data/count_objects/images&quot;,
                  index = &quot;NR&quot;,
                  invert = TRUE,
                  show_image = FALSE,
                  parallel = TRUE,
                  filter = 2,
                  verbose = FALSE)

# high-resolution images (_100) and with no filtering
bb_res_100_nf &lt;-
  analyze_objects(pattern = &quot;bb_100&quot;,
                  dir_original = &quot;/data/count_objects/images&quot;,
                  index = &quot;NR&quot;,
                  invert = TRUE,
                  show_image = FALSE,
                  parallel = TRUE,
                  verbose = FALSE)


# low-resolution images (_100) and with filtering
bb_res_100_wf &lt;-
  analyze_objects(pattern = &quot;bb_100&quot;,
                  dir_original = &quot;/data/count_objects/images&quot;,
                  index = &quot;NR&quot;,
                  invert = TRUE,
                  show_image = FALSE,
                  parallel = TRUE,
                  filter = 3,
                  verbose = FALSE)</code></pre>
<ul>
<li>white background</li>
</ul>
<pre class="r"><code># wheat (NB)
dir_ww &lt;- &quot;./data/count_objects/images/img_ww_50_1.jpg&quot;
ww &lt;- image_import(image = dir_ww)
image_binary(ww)</code></pre>
<p><img src="code_files/figure-html/unnamed-chunk-11-1.png" width="960" /></p>
<pre class="r"><code># soybean (NB)
dir_sw &lt;- &quot;./data/count_objects/images/img_sw_50_1.jpg&quot;
sw &lt;- image_import(image = dir_sw)
image_binary(sw)</code></pre>
<p><img src="code_files/figure-html/unnamed-chunk-11-2.png" width="960" /></p>
<pre class="r"><code># bean (G)
dir_bw &lt;- &quot;./data/count_objects/images/img_bw_50_1.jpg&quot;
bw &lt;- image_import(image = dir_bw)
image_binary(bw)</code></pre>
<p><img src="code_files/figure-html/unnamed-chunk-11-3.png" width="960" /></p>
<pre class="r"><code>### SOYBEAN

# mid-resolution images (_50) and with no filtering
sw_res_50_nf &lt;-
  analyze_objects(pattern = &quot;sw_50&quot;,
                  dir_original = &quot;/data/count_objects/images&quot;,
                  show_image = FALSE,
                  parallel = TRUE,
                  verbose = FALSE)

# mid-resolution images (_50) and with filtering
sw_res_50_wf &lt;-
  analyze_objects(pattern = &quot;sw_50&quot;,
                  dir_original = &quot;/data/count_objects/images&quot;,
                  show_image = FALSE,
                  parallel = TRUE,
                  filter = 2,
                  verbose = FALSE)
sw_res_100_nf &lt;-
  analyze_objects(pattern = &quot;sw_100&quot;,
                  dir_original = &quot;/data/count_objects/images&quot;,
                  show_image = FALSE,
                  parallel = TRUE,
                  verbose = FALSE)


# low-resolution images (_100) and with filtering
sw_res_100_wf &lt;-
  analyze_objects(pattern = &quot;sw_100&quot;,
                  dir_original = &quot;/data/count_objects/images&quot;,
                  show_image = FALSE,
                  parallel = TRUE,
                  filter = 3,
                  verbose = FALSE)






### WHEAT

# mid-resolution images (_50) and with no filtering
ww_res_50_nf &lt;-
  analyze_objects(pattern = &quot;ww_50&quot;,
                  dir_original = &quot;/data/count_objects/images&quot;,
                  show_image = FALSE,
                  parallel = TRUE,
                  verbose = FALSE)

# mid-resolution images (_50) and with filtering
ww_res_50_wf &lt;-
  analyze_objects(pattern = &quot;ww_50&quot;,
                  dir_original = &quot;/data/count_objects/images&quot;,
                  show_image = FALSE,
                  parallel = TRUE,
                  filter = 2,
                  verbose = FALSE)

# high-resolution images (_100) and with no filtering
ww_res_100_nf &lt;-
  analyze_objects(pattern = &quot;ww_100&quot;,
                  dir_original = &quot;/data/count_objects/images&quot;,
                  show_image = FALSE,
                  parallel = TRUE,
                  verbose = FALSE)


# low-resolution images (_100) and with filtering
ww_res_100_wf &lt;-
  analyze_objects(pattern = &quot;ww_100&quot;,
                  dir_original = &quot;/data/count_objects/images&quot;,
                  show_image = FALSE,
                  parallel = TRUE,
                  filter = 3,
                  verbose = FALSE)





### BEAN

# mid-resolution images (_50) and with no filtering
bw_res_50_nf &lt;-
  analyze_objects(pattern = &quot;bw_50&quot;,
                  dir_original = &quot;/data/count_objects/images&quot;,
                  index = &quot;G&quot;,
                  show_image = FALSE,
                  parallel = TRUE,
                  verbose = FALSE)

# mid-resolution images (_50) and with filtering
bw_res_50_wf &lt;-
  analyze_objects(pattern = &quot;bw_50&quot;,
                  dir_original = &quot;/data/count_objects/images&quot;,
                  index = &quot;G&quot;,
                  show_image = FALSE,
                  parallel = TRUE,
                  filter = 2,
                  verbose = FALSE)

# high-resolution images (_100) and with no filtering
bw_res_100_nf &lt;-
  analyze_objects(pattern = &quot;bw_100&quot;,
                  dir_original = &quot;/data/count_objects/images&quot;,
                  index = &quot;G&quot;,
                  show_image = FALSE,
                  parallel = TRUE,
                  verbose = FALSE)


# low-resolution images (_100) and with filtering
bw_res_100_wf &lt;-
  analyze_objects(pattern = &quot;bw_100&quot;,
                  dir_original = &quot;/data/count_objects/images&quot;,
                  index = &quot;G&quot;,
                  show_image = FALSE,
                  parallel = TRUE,
                  filter = 3,
                  verbose = FALSE)</code></pre>
</div>
<div id="concordance" class="section level2" number="7.2">
<h2 number="7.2"><span class="header-section-number">7.2</span> Concordance</h2>
<pre class="r"><code>validation &lt;- import(&quot;data/count_objects/count_data.xlsx&quot;)

### overall concordance
get_ccc(validation, real, predicted)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["r"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["pc"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["lwr_ci"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["upr_ci"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["bc"],"name":[5],"type":["dbl"],"align":["right"]}],"data":[{"1":"0.9547395","2":"0.9525171","3":"0.9411152","4":"0.9617548","5":"0.9976723"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>### concordance by resolution, filtering, crop, background
df_ccc &lt;-
  validation %&gt;%
  group_by(filter) %&gt;%
  get_ccc(real, predicted) %&gt;%
  mutate(rho = paste0(&quot;rho[c]:~&quot;, round(pc, 3)),
         bc = paste0(&quot;C[b]:~&quot;, round(bc, 3)),
         r = paste0(&quot;r:~~~&quot;, round(r, 3)))


ggplot(validation, aes(real, predicted))+
  geom_abline(intercept = 0 , slope = 1, linetype = 2) +
  geom_point(aes(fill = factor(crop)),
             color = &quot;black&quot;,
             shape = 21,
             size = 2.5,
             alpha = 0.75,
             stroke = 0.05) +
  facet_nested(filter*resolution ~ background*crop ) +
  geom_text(aes(label=rho),
            x = 5,
            y = 135,
            hjust = 0,
            size = 3,
            data = df_ccc,
            parse = TRUE) +
  labs(x = &quot;Actual number of grains&quot;,
       y = &quot;Predicted number of grains&quot;) +
  my_theme() +
  coord_fixed() +
  scale_x_continuous(limits = c(0, 160),
                     breaks = seq(0, 160, by = 50)) +
  scale_y_continuous(limits = c(0, 160),
                     breaks = seq(0, 160, by = 50))</code></pre>
<p><img src="code_files/figure-html/count1-1.png" width="960" /></p>
<pre class="r"><code>ggsave(&quot;figs/count_objects.pdf&quot;, width = 9, height = 7)</code></pre>
</div>
<div id="source-of-errors" class="section level2" number="7.3">
<h2 number="7.3"><span class="header-section-number">7.3</span> Source of errors</h2>
<p>In the following plot, the quantification of the image <code>img_bw_50_1.jpg</code> (bean with blue background) is shown. When no filtering is used, some pixels within grains are considered as background, overestimating the number of grains when processing the image. The use of <code>filter = 2</code> improved the image binarization, providing an accuracy of 1.</p>
<pre class="r"><code>errors &lt;- image_import(&quot;figs/bean_filter.png&quot;, plot = TRUE)</code></pre>
<p><img src="code_files/figure-html/errors-1.png" width="960" /></p>
</div>
<div id="benchmarking" class="section level2" number="7.4">
<h2 number="7.4"><span class="header-section-number">7.4</span> Benchmarking</h2>
<pre class="r"><code>t1 &lt;-
  system.time(
    a &lt;- 
      analyze_objects(pattern = &quot;_50&quot;,
                      dir_original = &quot;data/count_objects/images&quot;,
                      show_image = FALSE,
                      parallel = TRUE,
                      verbose = FALSE)
  )
t2 &lt;-
  system.time(
    analyze_objects(pattern = &quot;_50&quot;,
                    dir_original = &quot;data/count_objects/images&quot;,
                    show_image = FALSE,
                    parallel = TRUE,
                    verbose = FALSE,
                    filter = 2)
  )
t3 &lt;-
  system.time(
    a &lt;-  
      analyze_objects(pattern = &quot;_100&quot;,
                      dir_original = &quot;data/count_objects/images&quot;,
                      show_image = FALSE,
                      parallel = TRUE,
                      verbose = FALSE)
  )
t4 &lt;-
  system.time(
    a &lt;-  
      analyze_objects(pattern = &quot;_100&quot;,
                      dir_original = &quot;data/count_objects/images&quot;,
                      show_image = FALSE,
                      parallel = TRUE,
                      filter = 2,
                      verbose = FALSE)
  )
t5 &lt;-
  system.time(
    a &lt;- 
      analyze_objects(pattern = &quot;_50&quot;,
                      dir_original = &quot;data/count_objects/images&quot;,
                      show_image = FALSE,
                      parallel = FALSE,
                      verbose = FALSE)
  )
t6 &lt;-
  system.time(
    a &lt;- 
      analyze_objects(pattern = &quot;_50&quot;,
                      dir_original = &quot;data/count_objects/images&quot;,
                      show_image = FALSE,
                      parallel = FALSE,
                      filter = 2,
                      verbose = FALSE)
  )
t7 &lt;-
  system.time(
    a &lt;- 
      analyze_objects(pattern = &quot;_100&quot;,
                      dir_original = &quot;data/count_objects/images&quot;,
                      show_image = FALSE,
                      parallel = FALSE,
                      verbose = FALSE)
  )
t8 &lt;-
  system.time(
    a &lt;- 
      analyze_objects(pattern = &quot;_100&quot;,
                      dir_original = &quot;data/count_objects/images&quot;,
                      show_image = FALSE,
                      parallel = FALSE,
                      filter = 2,
                      verbose = FALSE)
  )</code></pre>
<pre class="r"><code>bench &lt;- import(&quot;data/count_objects/time.xlsx&quot;)


ggplot(bench, aes(filter, avg, fill = strategy)) +
  geom_col(position =  position_dodge(width = 0.9)) +
  facet_wrap(~resolution) +
  scale_y_continuous(expand = expansion(c(0.05, 0.1))) +
  geom_text(aes(label = round(avg, 2)),
            position = position_dodge(width = 0.9),
            vjust = -0.5,
            hjust = 0.5,
            size = 3) +
  my_theme() +
  labs(x = &quot;Filter&quot;,
       y = expression(Processing~time~(s~image^{-1})))</code></pre>
<p><img src="code_files/figure-html/benchmarking-1.png" width="960" /></p>
<pre class="r"><code>ggsave(&quot;figs/benchmarking.pdf&quot;, width = 4, height = 4)</code></pre>
</div>
</div>
<div id="leaf-area" class="section level1" number="8">
<h1 number="8"><span class="header-section-number">8</span> Leaf area</h1>
<p>We can use <code>analyze_objects()</code> to compute object features such as area, perimeter, radius, etc. This can be used, for example, to compute leaf area. Let’s compute the leaf area of <code>leaves</code> with <code>analyze_objects()</code>. First, we use <code>image_segmentation()</code> to identify candidate indexes to segment foreground (leaves) from background.</p>
<pre class="r"><code>leaves &lt;- image_import(&quot;data/leaf_area/leaves2.JPG&quot;, plot = TRUE)</code></pre>
<p><img src="code_files/figure-html/leaf3-1.png" width="960" /></p>
<pre class="r"><code>image_segment(leaves, index = &quot;all&quot;)</code></pre>
<p><img src="code_files/figure-html/leaf4-1.png" width="768" /></p>
<p><code>G</code> (Green) and <code>NB</code> (Normalized Blue) are two possible candidates to segment the leaves from the background. We will use the <code>NB</code> index here (default option in <code>analyze_objects()</code>). The measurement of the leaf area in this approach can be done in two main ways: 1) using an object of known area, and 2) knowing the image resolution in dpi (dots per inch).</p>
<div id="objectsize" class="section level2" number="8.1">
<h2 number="8.1"><span class="header-section-number">8.1</span> Using an object of known area</h2>
<ul>
<li>Count the number of objects (leaves in this case)</li>
</ul>
<p>Here, we use the argument <code>marker = "id"</code> of the function <code>analyze_objects()</code> to obtain the identification of each object (leaf), allowing for further adjustment of the leaf area.</p>
<pre class="r"><code>count &lt;- analyze_objects(leaves, marker = &quot;id&quot;)</code></pre>
<p><img src="code_files/figure-html/leaf5-1.png" width="960" /></p>
<p>Note that “holes” in some leaves resulted in the segmentation of one leaf in more than one object (e.g., 5, 8, 22, 25, 18, 28). This will not affect the total leaf area, but the area of individual leaves and the average leaf area. This can be solved by either setting the argument <code>fill_hull = TRUE</code> or <code>watershed = FALSE</code> (To don’t implement the watershed-based object segmentation). Let’s see how much better we can go.</p>
<pre class="r"><code>count &lt;-
  analyze_objects(leaves,
                  marker = &quot;id&quot;,
                  fill_hull = TRUE)</code></pre>
<p><img src="code_files/figure-html/leaf6-1.png" width="960" /></p>
<p>Almost there! Due to the morphology of the leaf composed by objects 2 and 23, it was segmented into two objects. This can be solved by setting the argument <code>object_size = "large"</code> that will change the default (medium) values for <code>tolerance</code> and <code>extension</code> arguments.</p>
<pre class="r"><code>count &lt;-
  analyze_objects(leaves,
                  marker = &quot;id&quot;,
                  fill_hull = TRUE,
                  object_size = &quot;large&quot;)</code></pre>
<p><img src="code_files/figure-html/leaf7-1.png" width="960" /></p>
<p>When the objects are not touching each other, the argument <code>watershed = FALSE</code> would be a better option.</p>
<pre class="r"><code>analyze_objects(leaves,
                watershed = FALSE)</code></pre>
<p><img src="code_files/figure-html/leaf8-1.png" width="960" /></p>
<p>And here we are! Now, all leaves were identified correctly, but all measures were given in pixel units. The next step is to convert these measures to metric units.</p>
<ul>
<li>Convert the leaf area by the area of the known object</li>
</ul>
<p>The function <code>get_measures()</code> is used to adjust the leaf area using object 10, a square with a side of 5 cm (25 cm<span class="math inline">\(^2\)</span>).</p>
<pre class="r"><code>area &lt;-
  get_measures(count,
               id = 10,
               area ~ 25)
## -----------------------------------------
## measures corrected with:
## object id: 10
## area     : 25
## -----------------------------------------
## Total    : 822.014 
## Average  : 35.74 
## -----------------------------------------
area</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["id"],"name":[1],"type":["int"],"align":["right"]},{"label":["x"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["y"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["area"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["area_ch"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["perimeter"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["radius_mean"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["radius_min"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["radius_max"],"name":[9],"type":["dbl"],"align":["right"]},{"label":["radius_sd"],"name":[10],"type":["dbl"],"align":["right"]},{"label":["radius_ratio"],"name":[11],"type":["dbl"],"align":["right"]},{"label":["major_axis"],"name":[12],"type":["dbl"],"align":["right"]},{"label":["eccentricity"],"name":[13],"type":["dbl"],"align":["right"]},{"label":["theta"],"name":[14],"type":["dbl"],"align":["right"]},{"label":["solidity"],"name":[15],"type":["dbl"],"align":["right"]},{"label":["circularity"],"name":[16],"type":["dbl"],"align":["right"]}],"data":[{"1":"1","2":"276.129","3":"221.430","4":"117.823","5":"118.100","6":"38.381","7":"6.256","8":"4.469","9":"9.246","10":"27.138","11":"2.069","12":"16.615","13":"0.837","14":"1.529","15":"0.998","16":"1.005","_rn_":"1"},{"1":"2","2":"912.046","3":"191.121","4":"112.962","5":"143.620","6":"55.562","7":"5.959","8":"3.425","9":"8.575","10":"20.758","11":"2.504","12":"13.672","13":"0.548","14":"-1.558","15":"0.787","16":"0.460","_rn_":"2"},{"1":"3","2":"117.277","3":"501.002","4":"94.569","5":"100.538","6":"46.218","7":"6.267","8":"2.653","9":"10.691","10":"46.500","11":"4.030","12":"18.979","13":"0.936","14":"-1.510","15":"0.941","16":"0.556","_rn_":"3"},{"1":"4","2":"533.671","3":"164.067","4":"57.425","5":"58.129","6":"27.078","7":"4.360","8":"3.140","9":"6.364","10":"16.271","11":"2.027","12":"10.962","13":"0.788","14":"-1.487","15":"0.988","16":"0.984","_rn_":"4"},{"1":"5","2":"690.167","3":"172.731","4":"52.138","5":"54.020","6":"26.475","7":"4.231","8":"3.103","9":"6.413","10":"16.586","11":"2.066","12":"10.207","13":"0.760","14":"-1.392","15":"0.965","16":"0.935","_rn_":"5"},{"1":"6","2":"224.914","3":"751.209","4":"50.626","5":"53.551","6":"25.872","7":"4.051","8":"2.918","9":"5.930","10":"11.935","11":"2.032","12":"9.086","13":"0.572","14":"-1.471","15":"0.945","16":"0.950","_rn_":"6"},{"1":"7","2":"1047.062","3":"424.418","4":"61.884","5":"62.790","6":"28.987","7":"4.626","8":"2.986","9":"7.148","10":"23.705","11":"2.394","12":"12.675","13":"0.868","14":"1.404","15":"0.986","16":"0.926","_rn_":"7"},{"1":"8","2":"865.070","3":"761.262","4":"39.607","5":"40.831","6":"23.159","7":"3.664","8":"2.631","9":"5.519","10":"14.081","11":"2.097","12":"8.835","13":"0.740","14":"-1.329","15":"0.970","16":"0.928","_rn_":"8"},{"1":"9","2":"871.498","3":"486.609","4":"37.911","5":"40.834","6":"23.963","7":"3.574","8":"2.419","9":"5.417","10":"14.594","11":"2.239","12":"8.419","13":"0.633","14":"-1.476","15":"0.928","16":"0.830","_rn_":"9"},{"1":"10","2":"605.991","3":"664.123","4":"25.000","5":"24.876","6":"19.592","7":"2.835","8":"2.411","9":"3.475","10":"6.134","11":"1.441","12":"5.869","13":"0.254","14":"-1.563","15":"1.005","16":"0.818","_rn_":"10"},{"1":"11","2":"967.756","3":"628.918","4":"30.204","5":"30.613","6":"19.341","7":"3.189","8":"2.378","9":"4.727","10":"13.566","11":"1.988","12":"8.160","13":"0.812","14":"1.568","15":"0.987","16":"1.015","_rn_":"11"},{"1":"12","2":"597.344","3":"378.935","4":"28.379","5":"32.082","6":"21.752","7":"3.144","8":"1.962","9":"4.982","10":"15.198","11":"2.539","12":"7.543","13":"0.635","14":"-1.417","15":"0.885","16":"0.754","_rn_":"12"},{"1":"13","2":"503.668","3":"584.456","4":"25.792","5":"27.186","6":"22.707","7":"3.447","8":"1.585","9":"5.942","10":"26.280","11":"3.748","12":"9.993","13":"0.939","14":"-1.103","15":"0.949","16":"0.629","_rn_":"13"},{"1":"14","2":"385.436","3":"423.892","4":"20.684","5":"21.997","6":"20.346","7":"2.974","8":"1.402","9":"5.099","10":"22.338","11":"3.636","12":"8.773","13":"0.934","14":"-1.382","15":"0.940","16":"0.628","_rn_":"14"},{"1":"15","2":"423.393","3":"176.371","4":"15.518","5":"16.028","6":"16.578","7":"2.455","8":"1.170","9":"4.095","10":"16.808","11":"3.500","12":"7.356","13":"0.926","14":"1.554","15":"0.968","16":"0.710","_rn_":"15"},{"1":"16","2":"847.125","3":"626.891","4":"10.441","5":"10.837","6":"12.258","7":"1.924","8":"1.256","9":"3.026","10":"10.113","11":"2.409","12":"5.006","13":"0.842","14":"0.235","15":"0.963","16":"0.873","_rn_":"16"},{"1":"17","2":"712.599","3":"457.976","4":"9.118","5":"9.131","6":"13.463","7":"1.950","8":"0.777","9":"3.415","10":"14.864","11":"4.394","12":"6.087","13":"0.945","14":"1.424","15":"0.999","16":"0.632","_rn_":"17"},{"1":"18","2":"353.365","3":"740.398","4":"5.830","5":"6.231","6":"9.897","7":"1.533","8":"0.872","9":"2.624","10":"9.952","11":"3.009","12":"4.024","13":"0.878","14":"-0.519","15":"0.936","16":"0.748","_rn_":"18"},{"1":"19","2":"641.395","3":"535.291","4":"4.603","5":"4.505","6":"7.485","7":"1.213","8":"0.839","9":"1.754","10":"5.726","11":"2.089","12":"3.384","13":"0.859","14":"-1.546","15":"1.022","16":"1.032","_rn_":"19"},{"1":"20","2":"738.920","3":"711.817","4":"8.089","5":"8.646","6":"15.171","7":"1.900","8":"0.492","9":"3.533","10":"16.478","11":"7.179","12":"6.118","13":"0.955","14":"1.557","15":"0.935","16":"0.442","_rn_":"20"},{"1":"21","2":"344.537","3":"602.703","4":"5.370","5":"5.946","6":"11.806","7":"1.621","8":"0.344","9":"2.997","10":"14.938","11":"8.712","12":"5.516","13":"0.969","14":"-1.429","15":"0.903","16":"0.484","_rn_":"21"},{"1":"22","2":"714.360","3":"576.056","4":"3.788","5":"3.690","6":"7.134","7":"1.120","8":"0.645","9":"1.719","10":"6.426","11":"2.666","12":"3.312","13":"0.896","14":"1.421","15":"1.027","16":"0.935","_rn_":"22"},{"1":"23","2":"473.760","3":"785.686","4":"4.252","5":"4.661","6":"27.781","7":"3.482","8":"0.137","9":"6.947","10":"39.753","11":"50.583","12":"14.308","13":"1.000","14":"-0.037","15":"0.912","16":"0.069","_rn_":"23"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code># plot the area to the segmented image
image_segment(leaves, index = &quot;NB&quot;, verbose = FALSE)
plot_measures(area,
              measure = &quot;area&quot;,
              col = &quot;red&quot;) # default is &quot;white&quot;</code></pre>
<p><img src="code_files/figure-html/leaf9-1.png" width="960" /></p>
</div>
<div id="knowing-the-image-resolution-in-dpi-dots-per-inch" class="section level2" number="8.2">
<h2 number="8.2"><span class="header-section-number">8.2</span> knowing the image resolution in dpi (dots per inch)</h2>
<p>When the image resolution is known, the measures in pixels obtained with <code>analyze_objects()</code> are corrected by the image resolution. The function <code>dpi()</code> can be used to compute the dpi of an image, provided that the size of any object is known. See the <a href="#dpi">dpi</a> section for more details. In this case, the estimated resolution considering the calibration of object 10 was ~50.8 DPIs. We inform this value in the <code>dpi</code> argument of <code>get_measures9)</code>.</p>
<pre class="r"><code>area2 &lt;- get_measures(count, dpi = 50.8)
# compute the difference between the two methods
sum(area$area - area2$area)
## [1] 7.724</code></pre>
</div>
<div id="comparing-pliman-and-leafarea" class="section level2" number="8.3">
<h2 number="8.3"><span class="header-section-number">8.3</span> Comparing <code>pliman</code> and <code>LeafArea</code></h2>
<pre class="r"><code># Find the exact distance of 826 pixels at 100 dpi
#
kd &lt;- pixels_to_cm(826, 100)
kd

# change according to your PC
directory &lt;- &quot;E:/Desktop/paper_pliman/data/leaf_area/imagej&quot;
path_imgj &lt;- &quot;C:/Program Files/ImageJ&quot;
system.time(
  lfa &lt;-
    run.ij(path.imagej = path_imgj,
           set.directory = directory,
           known.distance = 20.9804, # run.ig has 21 as default.
           save.image = FALSE,
           trim.pixel = 0)
)

# total time: ~10.9 s</code></pre>
<pre class="r"><code>system.time(
  plm &lt;-
    analyze_objects(pattern = &quot;img&quot;,   # name pattern
                    watershed = FALSE,  # don&#39;t use watershed segmentation
                    index = &quot;G&quot;,           # index to segment leaf and background
                    dir_original = &quot;data/leaf_area/imagej&quot;,
                    show_image = FALSE,    # don&#39;t show image after processing
                    parallel = TRUE,       # multiple sections
                    verbose = FALSE)
)
##   usuário   sistema decorrido 
##      0.11      0.02      5.30
# adjust the measures considering 100 dpi (the same as LeafArea)
area &lt;- get_measures(plm, dpi = 100)</code></pre>
<pre class="r"><code>df_area &lt;- import(&quot;./data/leaf_area/leaf_area.xlsx&quot;)
hlt &lt;- c(&quot;img90&quot;, &quot;img87&quot;, &quot;img107&quot;)
df_area &lt;-
  df_area %&gt;%
  mutate(res = pliman - leaf_area,
         label = ifelse(sample %in% hlt, sample, NA))

# compute the Lin&#39;s concordance correlation
df_cor &lt;- df_area[1:150,]
ccc &lt;-
  df_cor %&gt;%
  group_by(background) %&gt;%
  get_ccc(leaf_area, pliman) %&gt;%
  mutate(rho = paste0(&quot;rho[c]:~&quot;, round(pc, 4),
                      &quot;[(&quot;,round(lwr_ci,4), &quot;-&quot;,
                      round(upr_ci,4), &quot;)]&quot; ))

# create the plot
ggplot(df_area, aes(leaf_area, pliman)) +
  geom_abline(intercept = 0, slope = 1,
              linetype = 2) +
  geom_point(aes(fill = background),
             shape = 25,
             size = 3,
             alpha = 0.6,
             color = &quot;black&quot;,
             stroke = 0.05,
             data = subset(df_area, sample %in% hlt)) +
  geom_point(aes(fill = background),
             shape = 21,
             size = 3,
             alpha = 0.6,
             color = &quot;black&quot;,
             stroke = 0.05,
             data = subset(df_area, !sample %in% hlt)) +
  geom_text_repel(aes(label = label)) +
  geom_text(aes(label=rho, color = background),
            show.legend = FALSE,
            x = c(10, 10),
            y = c(240, 260),
            hjust = 0,
            size = 4,
            data = ccc,
            parse = TRUE) +
  scale_x_continuous(limits = c(0, 275), breaks = seq(0, 275, by = 50)) +
  scale_y_continuous(limits = c(0, 275), breaks = seq(0, 275, by = 50)) +
  labs(x = &quot;LeafArea&quot;,
       y = &quot;pliman&quot;) +
  my_theme() +
  coord_fixed()
## Warning: Removed 16 rows containing missing values (geom_point).
## Warning: Removed 163 rows containing missing values (geom_text_repel).</code></pre>
<p><img src="code_files/figure-html/leaf13-1.png" width="960" /></p>
<pre class="r"><code>ggsave(&quot;figs/pliman_leafarea.pdf&quot;, width = 4, height = 4)
## Warning: Removed 16 rows containing missing values (geom_point).

## Warning: Removed 163 rows containing missing values (geom_text_repel).</code></pre>
</div>
<div id="variations-in-the-arguments-of-analyze_objects" class="section level2" number="8.4">
<h2 number="8.4"><span class="header-section-number">8.4</span> Variations in the arguments of <code>analyze_objects()</code></h2>
<p>Here, I show how to produce the masks shown in Figure 8 of the article, using the image <code>img90</code> as an example.</p>
<pre class="r"><code>img90 &lt;- image_import(&quot;img90.jpg&quot;,
                      path = &quot;data/leaf_area/imagej&quot;,
                      plot = TRUE)</code></pre>
<p><img src="code_files/figure-html/masks-1.png" width="672" /></p>
<pre class="r"><code># pliman 1
analyze_objects(img90,
                index = &quot;G&quot;,          # index to segment leaf and background
                fill_hull = TRUE,     # fill the injuried area
                show_original = FALSE)# create a mask (not original image)</code></pre>
<p><img src="code_files/figure-html/masks-2.png" width="672" /></p>
<pre class="r"><code># pliman 2
analyze_objects(img90,
                index = &quot;G&quot;,          # index to segment leaf and background
                fill_hull = FALSE,    # don&#39;t fill the injuried area (default)
                show_original = FALSE)# create a mask (not original image)</code></pre>
<p><img src="code_files/figure-html/masks-3.png" width="672" /></p>
<pre class="r"><code># pliman 3
analyze_objects(img90,
                index = &quot;G&quot;,             # index to segment leaf and background
                fill_hull = FALSE,       # don&#39;t fill the injuried area (default)
                show_contour = FALSE,    # don&#39;t show object contour
                show_original = TRUE,    # show original object
                col_background = &quot;black&quot;)# black background</code></pre>
<p><img src="code_files/figure-html/masks-4.png" width="672" /></p>
<pre class="r"><code># pliman 4
analyze_objects(img90,
                index = &quot;G&quot;,             # index to segment leaf and background
                fill_hull = FALSE,       # don&#39;t fill the injuried area (default)
                show_original = FALSE,   # show original object
                col_background = &quot;black&quot;,# black background
                col_foreground = &quot;green&quot;)# green foreground</code></pre>
<p><img src="code_files/figure-html/masks-5.png" width="672" /></p>
</div>
</div>
<div id="leaf-shape" class="section level1" number="9">
<h1 number="9"><span class="header-section-number">9</span> Leaf shape</h1>
<p>The function <code>analyze_objects()</code> computes a range of object features that can be used to study leaf shape. As a motivating example, I will use the image <code>potato_leaves.png</code>, that was gathered from Gupta et al. (2020)<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></p>
<pre class="r"><code>potato &lt;- image_import(&quot;data/leaf_area/potato_leaves.png&quot;, plot = TRUE)
pot_meas &lt;-
  analyze_objects(potato,
                  watershed = FALSE,
                  marker = &quot;id&quot;,
                  show_chull = TRUE) # shows the convex hull</code></pre>
<p><img src="code_files/figure-html/potato-1.png" width="960" /></p>
<pre class="r"><code>print(pot_meas$results)
##   id        x        y  area area_ch perimeter radius_mean radius_min
## 1  1 854.5021 223.9845 51409   54604       864    131.6104   92.00580
## 2  2 197.7975 217.9751 58849   76661      1088    140.1460   70.14579
## 3  3 536.2565 240.1453 35203   63154      1323    109.9245   38.04980
##   radius_max radius_sd radius_ratio major_axis eccentricity       theta
## 1   198.8997  26.27966     2.161817   305.8835    0.6103275  1.39474531
## 2   191.2485  28.62491     2.726444   318.2787    0.5095139 -0.09807888
## 3   188.6634  35.58658     4.958329   253.9835    0.2832585  1.09847274
##    solidity circularity
## 1 0.9414878   0.8654093
## 2 0.7676524   0.6247283
## 3 0.5574152   0.2527376</code></pre>
<p>Three key measures (in pixel units) are:</p>
<ol style="list-style-type: decimal">
<li><code>area</code> the area of the object.</li>
<li><code>area_ch</code> the area of the convex hull.</li>
<li><code>perimeter</code> the perimeter of the object.</li>
</ol>
<p>Using these measures, circularity and solidity are computed as shown in (Gupta et al, 2020).</p>
<p><span class="math display">\[ circularity = 4\pi(area / perimeter^2)\]</span></p>
<p><span class="math display">\[solidity = area / area\_ch\]</span></p>
<p>Circularity is influenced by serrations and lobing. Solidity is sensitive to leaves with deep lobes, or with a distinct petiole, and can be used to distinguish leaves lacking such structures. Unlike circularity, it is not very sensitive to serrations and minor lobings, since the convex hull remains largely unaffected.</p>
<div id="object-contour" class="section level2" number="9.1">
<h2 number="9.1"><span class="header-section-number">9.1</span> Object contour</h2>
<p>Users can also obtain the object contour and convex hull as follows:</p>
<pre class="r"><code>cont &lt;-
  object_contour(potato,
                 watershed = FALSE,
                 show_image = FALSE)
plot(potato)
plot_contour(cont, col = &quot;red&quot;, lwd = 3)</code></pre>
<p><img src="code_files/figure-html/cont-1.png" width="960" /></p>
</div>
<div id="convex-hull" class="section level2" number="9.2">
<h2 number="9.2"><span class="header-section-number">9.2</span> Convex hull</h2>
<p>The function <code>object_contour()</code> returns a list with the coordinate points for each object contour that can be further used to obtain the convex hull with <code>conv_hull()</code>.</p>
<pre class="r"><code>conv &lt;- conv_hull(cont)
plot(potato)
plot_contour(conv, col = &quot;red&quot;, lwd = 3)</code></pre>
<p><img src="code_files/figure-html/conv-1.png" width="960" /></p>
</div>
<div id="area-of-the-convex-hull" class="section level2" number="9.3">
<h2 number="9.3"><span class="header-section-number">9.3</span> Area of the convex hull</h2>
<p>Then, the area of the convex hull can be obtained with <code>poly_area()</code>.</p>
<pre class="r"><code>(area &lt;- poly_area(conv))
## $`1`
## [1] 54604
## 
## $`2`
## [1] 76661
## 
## $`3`
## [1] 63154</code></pre>
</div>
<div id="leaves-as-ggplot2-plot" class="section level2" number="9.4">
<h2 number="9.4"><span class="header-section-number">9.4</span> Leaves as <code>ggplot2</code> plot</h2>
<pre class="r"><code># create a data frame for contour and convex hull
df_cont &lt;- bind_rows(cont, .id = &quot;object&quot;)
df_conv &lt;- bind_rows(conv, .id = &quot;object&quot;)

# create a plot
ggplot(df_cont, aes(X1, X2, group = object)) +
  geom_polygon(aes(fill = object)) +
  geom_polygon(data = df_conv,
               aes(x, y, fill = object),
               alpha = 0.3) +
  theme_void() + 
  theme(legend.position = &quot;bottom&quot;)</code></pre>
<p><img src="code_files/figure-html/maskpoly-1.png" width="960" /></p>
</div>
<div id="simple-and-compound-leaves" class="section level2" number="9.5">
<h2 number="9.5"><span class="header-section-number">9.5</span> Simple and compound leaves</h2>
<p>A simple leaf blade is undivided. The blade of a compound leaf is divided into several leaflets. In the following examples, I will show how to analyze simple and compound leaves with <code>analyze_objects()</code>, mainly if the goal is to obtain the measures for each leaf (e.g., mean area), where the number of objects (leaves) will influence the results.</p>
<p>The following images by <a href="https://www.florestaombrofilamista.com.br/sidol/?menu=contact">Daniel Saueressig</a> were obtained from the <a href="https://www.florestaombrofilamista.com.br/sidol/?menu=glossary">“<em>Sistema de Identificação Dendrológica Online - Floresta Ombrófila Mista</em>”</a> and show examples of simple and compound leaves.</p>
<pre class="r"><code>imgs &lt;- 
  image_import(c(&quot;simple.jpg&quot;, &quot;compound.jpg&quot;),
               path = &quot;data/leaf_area&quot;,
               plot = TRUE)</code></pre>
<p><img src="code_files/figure-html/sc1-1.png" width="960" /></p>
<div id="simple-leaves" class="section level3" number="9.5.1">
<h3 number="9.5.1"><span class="header-section-number">9.5.1</span> Simple leaves</h3>
<p>Analyzing non-touching simple leaves is fairly simple. We already saw that the normalized blue index provides satisfactory object segmentation using images with a blue background like in this case. So, the default option (<code>index = "NB"</code>) is used. The squares in the background have 4 cm<span class="math inline">\(^2\)</span>. With this information, it is possible to obtain the image resolution with <code>dpi(simple)</code>, which will be useful to adjust the measures. In this case, the estimated dpi is 48.65.</p>
<pre class="r"><code>simple &lt;- imgs$simple.jpg
sarea &lt;- analyze_objects(simple, marker = &quot;id&quot;)</code></pre>
<p><img src="code_files/figure-html/sc2-1.png" width="672" /></p>
<p>Note that with the default settings, the simple leaf was partitioned into small, segmented leaves. As shown in <a href="#objectsize">section 8.1</a> this can be solved by either using <code>object_size = "large"</code> or <code>watershed = FALSE</code>, to omit the watershed segmentation algorithm. The last is used here.</p>
<pre class="r"><code>sarea &lt;- 
  analyze_objects(simple,
                  watershed = FALSE,
                  marker = &quot;id&quot;,
                  show_chull = TRUE)</code></pre>
<p><img src="code_files/figure-html/sc3-1.png" width="672" /></p>
<pre class="r"><code>sarea_cor &lt;- get_measures(sarea, dpi = 48.65)
sarea_cor</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["id"],"name":[1],"type":["int"],"align":["right"]},{"label":["x"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["y"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["area"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["area_ch"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["perimeter"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["radius_mean"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["radius_min"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["radius_max"],"name":[9],"type":["dbl"],"align":["right"]},{"label":["radius_sd"],"name":[10],"type":["dbl"],"align":["right"]},{"label":["radius_ratio"],"name":[11],"type":["dbl"],"align":["right"]},{"label":["major_axis"],"name":[12],"type":["dbl"],"align":["right"]},{"label":["eccentricity"],"name":[13],"type":["dbl"],"align":["right"]},{"label":["theta"],"name":[14],"type":["dbl"],"align":["right"]},{"label":["solidity"],"name":[15],"type":["dbl"],"align":["right"]},{"label":["circularity"],"name":[16],"type":["dbl"],"align":["right"]}],"data":[{"1":"1","2":"184.644","3":"156.252","4":"41.318","5":"55.705","6":"36.077","7":"4.276","8":"1.086","9":"7.970","10":"34.310","11":"7.341","12":"13.642","13":"0.951","14":"1.490","15":"0.742","16":"0.399","_rn_":"1"},{"1":"2","2":"68.644","3":"151.805","4":"19.926","5":"31.421","6":"27.462","7":"3.011","8":"1.091","9":"5.733","10":"23.037","11":"5.253","12":"9.206","13":"0.939","14":"1.552","15":"0.634","16":"0.332","_rn_":"2"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
<div id="compound-leaves" class="section level3" number="9.5.2">
<h3 number="9.5.2"><span class="header-section-number">9.5.2</span> Compound leaves</h3>
<p>For compound leaves, if the watershed segmentation is used, leaflets will probably be considered as different leaves, as can be seen below.</p>
<pre class="r"><code>compound &lt;- imgs$compound.jpg
carea &lt;- 
  analyze_objects(compound,
                  show_segmentation = TRUE,
                  show_contour = FALSE,
                  marker = &quot;id&quot;)</code></pre>
<p><img src="code_files/figure-html/sc4-1.png" width="672" /></p>
<p>Therefore, using <code>watershed = FALSE</code> will solve this problem, since all leaflets connected by at least one pixel will be considered part of the same leaf.</p>
<pre class="r"><code>carea &lt;- 
  analyze_objects(compound,
                  watershed = FALSE,
                  show_segmentation = TRUE,
                  show_contour = FALSE,
                  show_chull = TRUE,
                  marker = &quot;id&quot;)</code></pre>
<p><img src="code_files/figure-html/sc5-1.png" width="672" /></p>
<pre class="r"><code>carea_cor &lt;- get_measures(carea, dpi = 49.5)
carea_cor</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["id"],"name":[1],"type":["int"],"align":["right"]},{"label":["x"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["y"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["area"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["area_ch"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["perimeter"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["radius_mean"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["radius_min"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["radius_max"],"name":[9],"type":["dbl"],"align":["right"]},{"label":["radius_sd"],"name":[10],"type":["dbl"],"align":["right"]},{"label":["radius_ratio"],"name":[11],"type":["dbl"],"align":["right"]},{"label":["major_axis"],"name":[12],"type":["dbl"],"align":["right"]},{"label":["eccentricity"],"name":[13],"type":["dbl"],"align":["right"]},{"label":["theta"],"name":[14],"type":["dbl"],"align":["right"]},{"label":["solidity"],"name":[15],"type":["dbl"],"align":["right"]},{"label":["circularity"],"name":[16],"type":["dbl"],"align":["right"]}],"data":[{"1":"1","2":"114.670","3":"91.252","4":"15.896","5":"32.768","6":"40.999","7":"2.253","8":"0.026","9":"4.931","10":"22.218","11":"192.057","12":"6.956","13":"0.606","14":"-0.258","15":"0.485","16":"0.119","_rn_":"1"},{"1":"2","2":"113.051","3":"244.551","4":"18.747","5":"42.155","6":"45.925","7":"2.534","8":"0.071","9":"5.896","10":"24.435","11":"82.740","12":"8.406","13":"0.626","14":"0.706","15":"0.445","16":"0.112","_rn_":"2"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
</div>
</div>
<div id="get-the-rgb-values-for-each-object" class="section level1" number="10">
<h1 number="10"><span class="header-section-number">10</span> Get the RGB values for each object</h1>
<p>To obtain the RGB intensity of each image object we use the argument <code>object_rgb = TRUE</code> in the function <code>analyze_objects()</code>. In this example,</p>
<pre class="r"><code>img &lt;- image_import(&quot;data/objects_rgb/thetrazolium.jpg&quot;)

# identify the index that better segments the image
a &lt;- image_binary(img, &quot;all&quot;)</code></pre>
<p><img src="code_files/figure-html/rgb1-1.png" width="960" /></p>
<p>The index <code>HUE2</code> was chosen to segment the grains from the background. The mean of blue values will be computed by declaring <code>object_index = "B"</code>.</p>
<pre class="r"><code>ids &lt;-
  analyze_objects(img,
                  index = &quot;HUE2&quot;,
                  object_index = &quot;B&quot;,
                  fill_hull = TRUE,
                  marker = &quot;id&quot;,
                  marker_col = &quot;black&quot;)</code></pre>
<p><img src="code_files/figure-html/rgb2-1.png" width="960" /></p>
<div id="plot-the-index" class="section level2" number="10.1">
<h2 number="10.1"><span class="header-section-number">10.1</span> Plot the index</h2>
<p>Here, I use <code>image_segment()</code> and <code>plot_measures()</code> to plot the mean of blue values for each object.</p>
<pre class="r"><code>image_segment(img,
              index = &quot;HUE2&quot;,
              verbose = FALSE)
plot_measures(ids,
              measure = &quot;index&quot;, # plot the mean of blue values for each object
              col = &quot;black&quot;)</code></pre>
<p><img src="code_files/figure-html/rgb3-1.png" width="960" /></p>
<p>It seems that grains with mean blue values higher than 0.3 present some level of damage. Users can then work with this feature and adapt it to their case.</p>
<pre class="r"><code>length(which(ids$results$index &gt; 0.3))
## [1] 18</code></pre>
</div>
<div id="getting-the-id-for-each-object" class="section level2" number="10.2">
<h2 number="10.2"><span class="header-section-number">10.2</span> Getting the id for each object</h2>
<p>Knowing the object identification (id) is useful, for example, when correcting the objects’ measures by the measure of some object, e.g., with <code>get_measures()</code>. To get the object id, we use <code>object_id()</code>.</p>
<pre class="r"><code>img &lt;- image_import(image_pliman(&quot;la_leaves.jpg&quot;))
object_id(img)</code></pre>
<p><img src="code_files/figure-html/objec1-1.png" width="672" /></p>
</div>
<div id="getting-the-object-coordinates" class="section level2" number="10.3">
<h2 number="10.3"><span class="header-section-number">10.3</span> Getting the object coordinates</h2>
<p>Users can get the coordinates for all or desired objects with <code>object_coord()</code>. When the <code>id</code> argument is set to <code>NULL</code> (default), a bounding rectangle is drawn including all the objects. Set <code>id = "all"</code> to compute the coordinates for all objects in the image, or use a numeric vector to indicate the objects to compute the coordinates</p>
<pre class="r"><code># Get the coordinates for a bounding rectangle around all objects
object_coord(img)</code></pre>
<p><img src="code_files/figure-html/objec2-1.png" width="672" /></p>
<pre><code>## $col_min
## [1] 13
## 
## $col_max
## [1] 692
## 
## $row_min
## [1] 21
## 
## $row_max
## [1] 641
# Get the coordinates for all objects
object_coord(img, id = &quot;all&quot;)</code></pre>
<p><img src="code_files/figure-html/objec2-2.png" width="672" /></p>
<pre><code>## $col_min
## [1] 320  13 304  21 358 619
## 
## $col_max
## [1] 641 297 606 288 505 692
## 
## $row_min
## [1] 436 338  21  93 268 279
## 
## $row_max
## [1] 641 537 202 266 363 348
# Get the coordinates of objects 1 and 3
object_coord(img, id = c(2, 3))</code></pre>
<p><img src="code_files/figure-html/objec2-3.png" width="672" /></p>
<pre><code>## $col_min
## [1]  13 304
## 
## $col_max
## [1] 297 606
## 
## $row_min
## [1] 338  21
## 
## $row_max
## [1] 537 202</code></pre>
</div>
<div id="isolating-objects" class="section level2" number="10.4">
<h2 number="10.4"><span class="header-section-number">10.4</span> Isolating objects</h2>
<p>To isolate objects, the function <code>object_isolate()</code> is used. In the following example, I will isolate object 1 and set an edge of 10 pixels around the object.</p>
<pre class="r"><code>id1 &lt;- object_isolate(img, id = 1, edge = 10)
plot(id1)</code></pre>
<p><img src="code_files/figure-html/objec3-1.png" width="672" /></p>
</div>
</div>
<div id="phytopathometry" class="section level1" number="11">
<h1 number="11"><span class="header-section-number">11</span> Phytopathometry</h1>
<div id="single-images" class="section level2" number="11.1">
<h2 number="11.1"><span class="header-section-number">11.1</span> Single images</h2>
<pre class="r"><code># set the path directory
path_soy &lt;- &quot;data/disease_severity/soybean&quot;
# import images
img &lt;- image_import(&quot;leaf.jpg&quot;, path = path_soy)
healthy &lt;- image_import(&quot;healthy.jpg&quot;, path = path_soy)
symptoms &lt;- image_import(&quot;sympt.jpg&quot;, path = path_soy)
background &lt;- image_import(&quot;back.jpg&quot;, path = path_soy)
image_combine(img, healthy, symptoms, background, ncol = 4)</code></pre>
<p><img src="code_files/figure-html/disease1-1.png" width="1152" /></p>
</div>
<div id="image-palettes" class="section level2" number="11.2">
<h2 number="11.2"><span class="header-section-number">11.2</span> Image palettes</h2>
<p>Sample palettes can be made by simply manually sampling small areas of representative images and producing a composite image that will represent each of the desired classes (background, healthy, and symptomatic tissues). Another way is to use the <code>image_palette()</code> function to create sample color palettes</p>
<pre class="r"><code>pals &lt;- image_palette(img, npal = 8)
image_combine(pals, ncol = 4)</code></pre>
<p><img src="code_files/figure-html/unnamed-chunk-14-1.png" width="672" /></p>
<pre class="r"><code># default settings
res &lt;-
  measure_disease(img = img,
                  img_healthy = healthy,
                  img_symptoms = symptoms,
                  img_background = background,
                  save_image = TRUE,
                  dir_processed = &quot;data/disease_severity/soybean_rust/single&quot;)</code></pre>
<p><img src="code_files/figure-html/disease2-1.png" width="960" /></p>
<pre class="r"><code># create a personalized mask
measure_disease(img = img,
                img_healthy = healthy,
                img_symptoms = symptoms,
                img_background = background,
                save_image = TRUE,
                show_original = FALSE,
                dir_processed = &quot;data/disease_severity/soybean_rust/single2&quot;)</code></pre>
<p><img src="code_files/figure-html/disease2-2.png" width="960" /></p>
<pre><code>## $severity
##   healthy symptomatic
## 1 88.8797     11.1203
## 
## $shape
## NULL
## 
## $statistics
## NULL
## 
## attr(,&quot;class&quot;)
## [1] &quot;plm_disease&quot;
# import generated masks
mask &lt;- image_import(&quot;data/disease_severity/soybean_rust/single/proc_img.jpg&quot;)
mask2 &lt;- image_import(&quot;data/disease_severity/soybean_rust/single2/proc_img.jpg&quot;)

# combine the masks with the original image
image_combine(img, mask, mask2, ncol = 3)</code></pre>
<p><img src="code_files/figure-html/disease2-3.png" width="960" /></p>
</div>
<div id="variations-in-image-palettes" class="section level2" number="11.3">
<h2 number="11.3"><span class="header-section-number">11.3</span> Variations in image palettes</h2>
<p>In the following example, I show a second example with a variation in the color palettes, where only the necrotic area is assumed to be the diseased tissue. Therefore, the symptomatic area will be smaller than the previous one.</p>
<pre class="r"><code># set the path directory
path_soy &lt;- &quot;data/disease_severity/soybean&quot;
# import images
healthy2 &lt;- image_import(&quot;healthy2.jpg&quot;, path = path_soy)
symptoms2 &lt;- image_import(&quot;sympt2.jpg&quot;, path = path_soy)
background2 &lt;- image_import(&quot;back2.jpg&quot;, path = path_soy)
image_combine(healthy2, symptoms2, background2, ncol = 3)</code></pre>
<p><img src="code_files/figure-html/disease3-1.png" width="960" /></p>
<pre class="r"><code>img2 &lt;- img
res &lt;-
  measure_disease(img = img2,
                  img_healthy = healthy2,
                  img_symptoms = symptoms2,
                  img_background = background2,
                  show_image = TRUE,
                  contour_col = &quot;black&quot;,
                  save_image = TRUE,
                  prefix = &quot;proc2_&quot;,
                  dir_processed = &quot;data/disease_severity/soybean_rust/single&quot;)</code></pre>
<p><img src="code_files/figure-html/disease3-2.png" width="960" /></p>
<pre class="r"><code>res$severity</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["healthy"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["symptomatic"],"name":[2],"type":["dbl"],"align":["right"]}],"data":[{"1":"93.76847","2":"6.231528"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>imgs_pal &lt;-
  image_import(c(&quot;proc_img.jpg&quot;, &quot;proc2_img.jpg&quot;),
               path = &quot;data/disease_severity/soybean_rust/single&quot;)
image_combine(imgs_pal)</code></pre>
<p><img src="code_files/figure-html/disease3-3.png" width="960" /></p>
</div>
<div id="batch-processing" class="section level2" number="11.4">
<h2 number="11.4"><span class="header-section-number">11.4</span> Batch processing</h2>
<p>Fifty soybean leaves and 19 bean leaves previously processed in APS Assess software were used. The soybean images were retrieved from <a href="https://osf.io/4hbr6" class="uri">https://osf.io/4hbr6</a>, a Plant Disease Severity Annotation Image Database. Thanks to <a href="https://osf.io/jb6yd/">Emerson M. Del Ponte</a> and his collaborators for keeping this important project publicly available.</p>
<div id="soybean-rust" class="section level3" number="11.4.1">
<h3 number="11.4.1"><span class="header-section-number">11.4.1</span> Soybean rust</h3>
<div id="using-sample-palettes" class="section level4" number="11.4.1.1">
<h4 number="11.4.1.1"><span class="header-section-number">11.4.1.1</span> Using sample palettes</h4>
<ul>
<li>Soybean leaves to be processed</li>
</ul>
<pre class="r"><code># image directory
path_soy &lt;- &quot;E:/Desktop/paper_pliman/data/disease_severity/soybean_rust&quot;
soy_leaves &lt;- image_import(pattern = &quot;soy&quot;, path = path_soy)
image_combine(soy_leaves, ncol = 5)</code></pre>
<p><img src="code_files/figure-html/batch-1.png" width="960" /></p>
<ul>
<li>Image palettes with the different pixel classes</li>
</ul>
<pre class="r"><code># image directory
path_soy &lt;- &quot;E:/Desktop/paper_pliman/data/disease_severity/soybean_rust&quot;
soy_palettes &lt;-
  image_import(image = c(&quot;back.png&quot;, &quot;disease.png&quot;, &quot;health.png&quot;),
               path = path_soy)
image_combine(soy_palettes, ncol = 3)</code></pre>
<p><img src="code_files/figure-html/batch1-1.png" width="672" /></p>
<pre class="r"><code>system.time(
  soy_rust &lt;-
    measure_disease(pattern = &quot;soy_&quot;,
                    img_symptoms = &quot;disease&quot;,
                    img_healthy = &quot;health&quot;,
                    img_background = &quot;back&quot;,
                    dir_original = &quot;data/disease_severity/soybean_rust&quot;,
                    dir_processed = &quot;data/disease_severity/soybean_rust/processed&quot;,
                    show_contour = FALSE,
                    parallel = TRUE)
)
## Image processing using multiple sessions (6). Please wait.
##   usuário   sistema decorrido 
##      0.22      0.06     20.01
soy_rust$severity</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["img"],"name":[1],"type":["chr"],"align":["left"]},{"label":["healthy"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["symptomatic"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"soy_1","2":"92.52839","3":"7.4716096"},{"1":"soy_10","2":"84.83587","3":"15.1641263"},{"1":"soy_11","2":"16.61252","3":"83.3874781"},{"1":"soy_12","2":"66.56087","3":"33.4391275"},{"1":"soy_13","2":"77.33437","3":"22.6656332"},{"1":"soy_14","2":"64.82341","3":"35.1765938"},{"1":"soy_15","2":"58.93274","3":"41.0672616"},{"1":"soy_16","2":"41.84375","3":"58.1562535"},{"1":"soy_17","2":"77.79183","3":"22.2081728"},{"1":"soy_18","2":"55.24535","3":"44.7546514"},{"1":"soy_19","2":"87.50574","3":"12.4942641"},{"1":"soy_2","2":"63.20047","3":"36.7995250"},{"1":"soy_20","2":"53.12475","3":"46.8752518"},{"1":"soy_21","2":"99.77615","3":"0.2238536"},{"1":"soy_22","2":"72.15168","3":"27.8483230"},{"1":"soy_23","2":"30.97402","3":"69.0259819"},{"1":"soy_24","2":"21.85198","3":"78.1480241"},{"1":"soy_25","2":"82.17955","3":"17.8204499"},{"1":"soy_26","2":"38.11911","3":"61.8808913"},{"1":"soy_27","2":"32.93089","3":"67.0691101"},{"1":"soy_28","2":"33.66006","3":"66.3399434"},{"1":"soy_29","2":"74.57071","3":"25.4292880"},{"1":"soy_3","2":"58.92805","3":"41.0719519"},{"1":"soy_30","2":"73.57798","3":"26.4220192"},{"1":"soy_31","2":"10.01063","3":"89.9893718"},{"1":"soy_32","2":"28.66146","3":"71.3385400"},{"1":"soy_33","2":"31.30787","3":"68.6921304"},{"1":"soy_34","2":"52.48275","3":"47.5172514"},{"1":"soy_35","2":"23.16749","3":"76.8325068"},{"1":"soy_36","2":"43.28757","3":"56.7124265"},{"1":"soy_37","2":"13.54388","3":"86.4561224"},{"1":"soy_38","2":"45.67236","3":"54.3276397"},{"1":"soy_39","2":"90.85519","3":"9.1448142"},{"1":"soy_4","2":"45.41657","3":"54.5834316"},{"1":"soy_40","2":"59.34984","3":"40.6501609"},{"1":"soy_41","2":"93.83417","3":"6.1658343"},{"1":"soy_42","2":"36.23164","3":"63.7683564"},{"1":"soy_43","2":"50.78055","3":"49.2194509"},{"1":"soy_44","2":"39.95107","3":"60.0489329"},{"1":"soy_45","2":"69.76436","3":"30.2356415"},{"1":"soy_46","2":"97.32533","3":"2.6746701"},{"1":"soy_47","2":"86.53686","3":"13.4631364"},{"1":"soy_48","2":"90.25917","3":"9.7408317"},{"1":"soy_49","2":"58.44663","3":"41.5533728"},{"1":"soy_5","2":"83.83833","3":"16.1616693"},{"1":"soy_50","2":"83.88256","3":"16.1174441"},{"1":"soy_6","2":"73.32524","3":"26.6747559"},{"1":"soy_7","2":"75.85773","3":"24.1422732"},{"1":"soy_8","2":"69.91464","3":"30.0853634"},{"1":"soy_9","2":"53.67571","3":"46.3242852"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code># image directory
path_soy_proc &lt;- &quot;E:/Desktop/paper_pliman/data/disease_severity/soybean_rust/processed&quot;
soy_proc &lt;- image_import(pattern = &quot;proc&quot;, path = path_soy_proc)
image_combine(soy_proc, ncol = 5)</code></pre>
<p><img src="code_files/figure-html/batch3-1.png" width="960" /></p>
</div>
<div id="using-an-rgb-based-index" class="section level4" number="11.4.1.2">
<h4 number="11.4.1.2"><span class="header-section-number">11.4.1.2</span> Using an RGB-based index</h4>
<p>Another way to compute the diased area is by using an RGB-based phenotyping<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>. The first step is to find a suitable index for disease segmentation.</p>
<pre class="r"><code>img &lt;- image_import(&quot;soy_1.jpg&quot;, path = path_soy, plot = TRUE)</code></pre>
<p><img src="code_files/figure-html/unnamed-chunk-15-1.png" width="960" /></p>
<pre class="r"><code># find a suitable index to segment disease and healthy tissues
image_segment(img, index = &quot;all&quot;)</code></pre>
<p><img src="code_files/figure-html/unnamed-chunk-15-2.png" width="960" /></p>
<p>The NGRDI (Normalized green red difference index) computed as <span class="math inline">\(G-R/G+R\)</span> seems to segment lesions from healthy areas satisfactorily. Next, I <code>plot()</code> the output of <code>image_index()</code> to find a suitable threshold.</p>
<pre class="r"><code># Find a threshold
img_ind &lt;- image_index(img, index = &quot;NGRDI&quot;, show_image = FALSE)
plot(img_ind)</code></pre>
<p><img src="code_files/figure-html/unnamed-chunk-16-1.png" width="672" /></p>
<p>A threshold of <code>0</code> has been chosen. So, the next step is to use the function <code>measure_disease()</code> now. In this approach, color palettes are not informed. Instead, the user needs to declare two other arguments: <code>index_lb</code> to segment leaf from the background and <code>index_dh</code> to segment diseased from healthy tissues.</p>
<pre class="r"><code>system.time(
  soy_rust2 &lt;-
    measure_disease(pattern = &quot;soy_&quot;,
                    index_lb = &quot;G&quot;, # segment leaf from background
                    index_dh = &quot;NGRDI&quot;, # segment diseased from healthy tissues
                    threshold = 0,
                    dir_original = &quot;data/disease_severity/soybean_rust&quot;,
                    show_image = FALSE,
                    parallel = TRUE)
)
## Image processing using multiple sessions (6). Please wait.
##   usuário   sistema decorrido 
##      0.20      0.08     12.80</code></pre>
</div>
</div>
<div id="bean-angular-spot" class="section level3" number="11.4.2">
<h3 number="11.4.2"><span class="header-section-number">11.4.2</span> Bean angular spot</h3>
<div id="using-sample-palettes-1" class="section level4" number="11.4.2.1">
<h4 number="11.4.2.1"><span class="header-section-number">11.4.2.1</span> Using sample palettes</h4>
<pre class="r"><code># image directory
path_bean &lt;- &quot;E:/Desktop/paper_pliman/data/disease_severity/bean_spot&quot;
bean_leaves &lt;- image_import(pattern = &quot;bean&quot;, path = path_bean)
image_combine(bean_leaves, ncol = 5)</code></pre>
<p><img src="code_files/figure-html/batch4-1.png" width="960" /></p>
<pre class="r"><code>system.time(
  bean_spot &lt;-
    measure_disease(pattern = &quot;bean&quot;,
                    img_symptoms = &quot;disease&quot;,
                    img_healthy = &quot;health&quot;,
                    img_background = &quot;back&quot;,
                    dir_original = &quot;data/disease_severity/bean_spot&quot;,
                    dir_processed = &quot;data/disease_severity/bean_spot/processed&quot;,
                    save_image = TRUE,
                    show_contour = FALSE,
                    parallel = TRUE)
)
## Image processing using multiple sessions (6). Please wait.
##   usuário   sistema decorrido 
##      0.21      0.05      4.20
bean_spot$severity</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["img"],"name":[1],"type":["chr"],"align":["left"]},{"label":["healthy"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["symptomatic"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"bean_F1","2":"98.69845","3":"1.3015461"},{"1":"bean_F10","2":"99.52256","3":"0.4774434"},{"1":"bean_F11","2":"72.33917","3":"27.6608324"},{"1":"bean_F12","2":"90.92810","3":"9.0719046"},{"1":"bean_F13","2":"86.62027","3":"13.3797308"},{"1":"bean_F14","2":"87.65239","3":"12.3476101"},{"1":"bean_F15","2":"86.88767","3":"13.1123317"},{"1":"bean_F16","2":"26.99981","3":"73.0001949"},{"1":"bean_F17","2":"99.80841","3":"0.1915854"},{"1":"bean_F18","2":"92.66869","3":"7.3313073"},{"1":"bean_F19","2":"90.49565","3":"9.5043530"},{"1":"bean_F2","2":"85.37360","3":"14.6264008"},{"1":"bean_F3","2":"76.82394","3":"23.1760555"},{"1":"bean_F4","2":"82.11900","3":"17.8810032"},{"1":"bean_F5","2":"94.86007","3":"5.1399326"},{"1":"bean_F6","2":"97.56477","3":"2.4352289"},{"1":"bean_F7","2":"99.33540","3":"0.6645957"},{"1":"bean_F8","2":"76.16135","3":"23.8386528"},{"1":"bean_F9","2":"76.66136","3":"23.3386418"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code># image directory
path_bean_proc &lt;- &quot;E:/Desktop/paper_pliman/data/disease_severity/bean_spot/processed&quot;
bean_proc &lt;- image_import(pattern = &quot;proc&quot;, path = path_bean_proc)
image_combine(bean_proc, ncol = 5)</code></pre>
<p><img src="code_files/figure-html/batch6-1.png" width="960" /></p>
</div>
<div id="using-an-rgb-based-index-1" class="section level4" number="11.4.2.2">
<h4 number="11.4.2.2"><span class="header-section-number">11.4.2.2</span> Using an RGB-based index</h4>
<pre class="r"><code>img_bean &lt;- image_import(&quot;bean_F3.jpg&quot;, path = path_bean, plot = TRUE)</code></pre>
<p><img src="code_files/figure-html/beanleaf-1.png" width="960" /></p>
<p>First, we need to choose an index to segment the leaf from the background. The <code>image_segment()</code> function is used again.</p>
<pre class="r"><code>image_segment(img_bean, index = &quot;all&quot;)</code></pre>
<p><img src="code_files/figure-html/segbean2-1.png" width="960" /></p>
<p>Let’s try to use the <code>NB</code> index to segment the leaf and background, and the <code>NGRDI</code> again to segment lesion and heathy tissues.</p>
<pre class="r"><code>seg &lt;-
  image_segment_iter(img_bean,
                     index = c(&quot;NB&quot;, &quot;NGRDI&quot;),
                     nseg = 2,
                     ncol = 3)
##      image pixels   percent
## 1 original 600000 100.00000
## 2     seg1 185067  30.84450
## 3     seg2  51525  27.84127</code></pre>
<p><img src="code_files/figure-html/segiter-1.png" width="960" /></p>
<pre class="r"><code># Find a threshold
img_ind &lt;- image_index(seg$images$seg1,
                       index = &quot;NGRDI&quot;,
                       resize = FALSE,
                       show_image = FALSE)
plot(img_ind)</code></pre>
<p><img src="code_files/figure-html/segthresh-1.png" width="672" /></p>
<pre class="r"><code>system.time(
  bean_spot2 &lt;-
    measure_disease(pattern = &quot;bean&quot;,
                    index_lb = &quot;NB&quot;,
                    index_dh = &quot;NGRDI&quot;,
                    threshold = 0,
                    dir_original = &quot;data/disease_severity/bean_spot&quot;,
                    show_image = FALSE,
                    parallel = TRUE)
)
## Image processing using multiple sessions (6). Please wait.
##   usuário   sistema decorrido 
##      0.18      0.03      2.28</code></pre>
</div>
</div>
</div>
<div id="concordance-correlation-coefficient" class="section level2" number="11.5">
<h2 number="11.5"><span class="header-section-number">11.5</span> Concordance correlation coefficient</h2>
<pre class="r"><code>disease &lt;- import(&quot;data/disease_severity/disease.xlsx&quot;)


ggpairs(disease,
        legend = 1,
        aes(color = disease, fill = disease),
        axisLabels = &quot;none&quot;,
        columns = c(&quot;Assess&quot;, &quot;palettes&quot;, &quot;RGB&quot;),
        lower = list(continuous = custom_smoth),
        upper = list(continuous = custom_ccc),
        diag = list(continuous = wrap(&quot;densityDiag&quot;,
                                      alpha =  0.7,
                                      size = 0.2,
                                      color = &quot;black&quot;))) +
  my_theme()</code></pre>
<p><img src="code_files/figure-html/corcordance-1.png" width="672" /></p>
<pre class="r"><code>ggsave(&quot;figs/disease_severity.pdf&quot;, width = 5, height = 5)</code></pre>
</div>
<div id="lesion-features" class="section level2" number="11.6">
<h2 number="11.6"><span class="header-section-number">11.6</span> Lesion features</h2>
<p>In this example, I will use a sample of leaf with symptoms of soybean rust (<em>Phakopsora pachyrhizi</em>).</p>
<pre class="r"><code>lesion &lt;-
  image_import(&quot;data/disease_severity/soybean_rust/rust.png&quot;,
               plot = TRUE)</code></pre>
<p><img src="code_files/figure-html/unnamed-chunk-21-1.png" width="672" /></p>
<p>Here, an RGB-based indexe will be used to segment the diseased and healthy tissues. The first step is to choose an appropriate index.</p>
<pre class="r"><code>image_segment(lesion, index = &quot;all&quot;)</code></pre>
<p><img src="code_files/figure-html/unnamed-chunk-22-1.png" width="960" /></p>
<p>Both <code>"NGRDI"</code> and <code>"VARI"</code> provided satisfactory segmentation. So, the <code>"NGRDI"</code> will be chosen. The next step is to use the function <code>measure_disease()</code> with the argument <code>index_dh</code>. Note that <code>index_lb</code> is not mandatory and will not be used here, since the image has no background.</p>
<pre class="r"><code>les &lt;-
  measure_disease(lesion,
                  index_dh = &quot;NGRDI&quot;)</code></pre>
<p><img src="code_files/figure-html/unnamed-chunk-23-1.png" width="960" /></p>
<pre class="r"><code>les$severity</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["healthy"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["symptomatic"],"name":[2],"type":["dbl"],"align":["right"]}],"data":[{"1":"85.89737","2":"14.10263"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>The results show satisfactory results. All lesions were identified and the severity, in this case, was ~14%.</p>
<p>By default, Otsu’s thresholding method is used. Bellow, we can see which was the threshold value used in the segmentation.</p>
<pre class="r"><code>index_lesion &lt;- image_index(lesion,
                            index = &quot;NGRDI&quot;,
                            resize = FALSE,
                            show_image = FALSE)
EBImage::otsu(index_lesion$NGRDI, range = range(index_lesion$NGRDI))
## [1] -0.007994186</code></pre>
<p>Users can set the argument <code>threshold</code> in order to provide more reliable segmentations. If any non-numeric value different than <code>"Otsu"</code> is provided in the <code>threshold</code> argument, an iterative section will be open so that users can choose a threshold value. In this case, I will simply plot the index computed above.</p>
<pre class="r"><code>plot(index_lesion)</code></pre>
<p><img src="code_files/figure-html/unnamed-chunk-25-1.png" width="672" /></p>
<p>In this example, negative values of <code>NGRDI</code> are attributed to diseased tissues and positive to healthy tissues. Let’s see how the results (both for severity and number of lesions) change when the <code>threshold</code> argument is used. To do that, the arguments <code>watershed = TRUE</code>(implement the watershed segmentation algorithm) and <code>show_features = TRUE</code> (compute lesions’ features) will be used.</p>
<pre class="r"><code>les2 &lt;-
  measure_disease(lesion,
                  index_dh = &quot;NGRDI&quot;,
                  threshold = 0.1,
                  watershed = TRUE,
                  show_features = TRUE)</code></pre>
<p><img src="code_files/figure-html/unnamed-chunk-26-1.png" width="960" /></p>
<pre class="r"><code>les2$severity</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["healthy"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["symptomatic"],"name":[2],"type":["dbl"],"align":["right"]}],"data":[{"1":"76.28737","2":"23.71263"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>les2$statistics</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["stat"],"name":[1],"type":["chr"],"align":["left"]},{"label":["value"],"name":[2],"type":["dbl"],"align":["right"]}],"data":[{"1":"n","2":"161.0000"},{"1":"min_area","2":"24.0000"},{"1":"mean_area","2":"278.8261"},{"1":"max_area","2":"2309.0000"},{"1":"sd_area","2":"283.3717"},{"1":"sum_area","2":"44891.0000"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>les3 &lt;-
  measure_disease(lesion,
                  index_dh = &quot;NGRDI&quot;,
                  threshold = -0.1,
                  watershed = TRUE,
                  show_features = TRUE)</code></pre>
<p><img src="code_files/figure-html/unnamed-chunk-27-1.png" width="960" /></p>
<pre class="r"><code>les3$severity</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["healthy"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["symptomatic"],"name":[2],"type":["dbl"],"align":["right"]}],"data":[{"1":"90.13789","2":"9.862105"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>les3$statistics</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["stat"],"name":[1],"type":["chr"],"align":["left"]},{"label":["value"],"name":[2],"type":["dbl"],"align":["right"]}],"data":[{"1":"n","2":"147.00000"},{"1":"min_area","2":"23.00000"},{"1":"mean_area","2":"127.55102"},{"1":"max_area","2":"408.00000"},{"1":"sd_area","2":"69.50463"},{"1":"sum_area","2":"18750.00000"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
<div id="benchmarking-1" class="section level2" number="11.7">
<h2 number="11.7"><span class="header-section-number">11.7</span> Benchmarking</h2>
<pre class="r"><code>bench &lt;- import(&quot;data/disease_severity/time.xlsx&quot;)


ggplot(bench, aes(resolution, avg, fill = strategy)) +
  geom_col(position =  position_dodge(width = 0.9)) +
  # facet_wrap(~resolution) +
  scale_y_continuous(expand = expansion(c(0.05, 0.1))) +
  geom_text(aes(label = round(avg, 2)),
            position = position_dodge(width = 0.9),
            vjust = -0.5,
            hjust = 0.5,
            size = 3) +
  my_theme() +
  labs(x = &quot;Filter&quot;,
       y = expression(Processing~time~(s~image^{-1})))</code></pre>
<p><img src="code_files/figure-html/benchmarking2-1.png" width="960" /></p>
<pre class="r"><code>ggsave(&quot;figs/benchmarking_sev.pdf&quot;, width = 4, height = 4.5)</code></pre>
</div>
<div id="challenges" class="section level2" number="11.8">
<h2 number="11.8"><span class="header-section-number">11.8</span> Challenges</h2>
<div id="low-contrasting-lesions" class="section level3" number="11.8.1">
<h3 number="11.8.1"><span class="header-section-number">11.8.1</span> low-contrasting lesions</h3>
<pre class="r"><code>path_challenge &lt;- &quot;data/disease_severity/challenges&quot;
pepper &lt;- image_import(&quot;pepper.png&quot;,
                       path = path_challenge,
                       plot = TRUE)</code></pre>
<p><img src="code_files/figure-html/challenge1-1.png" width="960" /></p>
<pre class="r"><code>image_index(pepper, index = &quot;all&quot;, resize = FALSE)</code></pre>
<p><img src="code_files/figure-html/challenge1-2.png" width="960" /></p>
</div>
<div id="complex-backgrounds" class="section level3" number="11.8.2">
<h3 number="11.8.2"><span class="header-section-number">11.8.2</span> Complex backgrounds</h3>
<p>Segmenting the leaf from complex backgrounds is a challenge In the following example, a maize leaf needs to be segmented from the background that contains both green leaves (similar to leaf) and soil (similar to the disease).</p>
<pre class="r"><code>img &lt;- 
  image_import(&quot;maize_1.png&quot;,
               path = path_challenge,
               plot = TRUE)</code></pre>
<p><img src="code_files/figure-html/challenge2-1.png" width="960" /></p>
<pre class="r"><code>image_segment(img, index = &quot;all&quot;)</code></pre>
<p><img src="code_files/figure-html/challenge2-2.png" width="960" /></p>
<p>In the following example, the background have similar color than the midrib. In this case, cropping the image so that the background is removed would solve the issue.</p>
<pre class="r"><code>img2 &lt;- 
  image_import(&quot;maize_2.png&quot;,
               path = path_challenge,
               plot = TRUE)</code></pre>
<p><img src="code_files/figure-html/challenge3-1.png" width="960" /></p>
<pre class="r"><code>image_segment(img2, index = &quot;all&quot;)</code></pre>
<p><img src="code_files/figure-html/challenge3-2.png" width="960" /></p>
<pre class="r"><code># crop the image to isolate the background
img2_crop &lt;- image_crop(img2,
                   width = 959:32,
                   height = 163:557,
                   plot = TRUE)</code></pre>
<p><img src="code_files/figure-html/challenge3-3.png" width="960" /></p>
<pre class="r"><code>image_segment(img2_crop)</code></pre>
<p><img src="code_files/figure-html/challenge3-4.png" width="960" /></p>
<pre class="r"><code># use the NR index and invert the segmentation to isolate the diseased tissues
measure_disease(img2_crop, 
                index_dh = &quot;NR&quot;,
                invert = TRUE)</code></pre>
<p><img src="code_files/figure-html/challenge3-5.png" width="960" /></p>
<pre><code>## $severity
##    healthy symptomatic
## 1 93.16647    6.833533
## 
## $shape
## NULL
## 
## $statistics
## NULL
## 
## attr(,&quot;class&quot;)
## [1] &quot;plm_disease&quot;</code></pre>
<p>In the following image gathered from Barbedo (2016)<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a> is shown an example of an image containing specular reflections and several light/shadow transitions. Segmenting the leaf, in this case, is very difficult.</p>
<pre class="r"><code>img3 &lt;- 
  image_import(&quot;maize.jpg&quot;,
               path = path_challenge,
               plot = TRUE)</code></pre>
<p><img src="code_files/figure-html/challenge4-1.png" width="960" /></p>
<pre class="r"><code>image_segment(img3, index = &quot;all&quot;)</code></pre>
<p><img src="code_files/figure-html/challenge4-2.png" width="960" /></p>
</div>
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Gupta, S., Rosenthal, D. M., Stinchcombe, J. R., &amp; Baucom, R. S. (2020). The remarkable morphological diversity of leaf shape in sweet potato (<em>Ipomoea batatas</em>): the influence of genetics, environment, and G×E. <em>New Phytologist</em>, 225(5), 2183–2195. <a href="https://doi.org/10.1111/nph.16286" class="uri">https://doi.org/10.1111/nph.16286</a><a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p><a href="https://link.springer.com/article/10.1007/s40858-021-00448-y" class="uri">https://link.springer.com/article/10.1007/s40858-021-00448-y</a><a href="#fnref2" class="footnote-back">↩︎</a></p></li>
<li id="fn3"><p>Barbedo, J. G. A. (2016). A review on the main challenges in automatic plant disease identification based on visible range images. Biosystems Engineering, 144, 52–60. <a href="doi:10.1016/J.BIOSYSTEMSENG.2016.01.017" class="uri">doi:10.1016/J.BIOSYSTEMSENG.2016.01.017</a><a href="#fnref3" class="footnote-back">↩︎</a></p></li>
</ol>
</div>

<div id="rmd-source-code">JSBBbmFseXNpcyANCg0KYGBge3IgZ2xvYmFsX29wdGlvbnMsIGluY2x1ZGUgPSBGQUxTRX0NCmtuaXRyOjpvcHRzX2NodW5rJHNldChjYWNoZSA9IFRSVUUsIGNvbW1lbnQgPSAiIyMiLCBjb2xsYXBzZSA9IFRSVUUpDQoNCmBgYA0KDQojIFBhY2thZ2VzDQpUbyByZXByb2R1Y2UgdGhlIGV4YW1wbGVzIG9mIHRoaXMgbWF0ZXJpYWwsIHRoZSBmb2xsb3dpbmcgcGFja2FnZXMgYXJlIG5lZWRlZC4NCg0KYGBge3IgcGFja2FnZXMsIHdhcm5pbmc9RkFMU0V9DQpsaWJyYXJ5KHRpZHl2ZXJzZSkgICMgZGF0YSBtYW5pcHVsYXRpb24gYW5kIHBsb3RzDQpsaWJyYXJ5KHBsaW1hbikgICAgICMgcGxhbnQgaW1hZ2UgYW5hbHlzaXMNCmxpYnJhcnkoRGVzY1Rvb2xzKSAgIyBjb25jb3JkYW5jZSBjb3JyZWxhdGlvbiBjb2VmZmljaWVudA0KbGlicmFyeShyaW8pICAgICAgICAjIGltcG9ydC9leHBvcnQgZGF0YQ0KbGlicmFyeShMZWFmQXJlYSkgICAjIGxlYWYgYXJlYQ0KbGlicmFyeShnZ3JlcGVsKSAgICAjIHBsb3RzDQpsaWJyYXJ5KGdnaDR4KSAgICAgICMgcGxvdHMNCmxpYnJhcnkoR0dhbGx5KSAgICAgIyBwYWlyd2lzZSBjb3JyZWxhdGlvbiBwbG90cw0KYGBgDQoNCg0KIyBJbnN0YWxsaW5nIHBsaW1hbg0KDQpUbyBpbnN0YWxsIHRoZSByZWxlYXNlZCB2ZXJzaW9uIG9mIGBwbGltYW5gIGZyb20gQ1JBTiB0eXBlOg0KYGBge3IgZXZhbCA9IEZBTFNFfQ0KaW5zdGFsbC5wYWNrYWdlcygicGxpbWFuIikNCmBgYA0KDQoNClRoZSBsYXRlc3QgZGV2ZWxvcG1lbnQgdmVyc2lvbiBvZiBgcGxpbWFuYCBjYW4gYmUgaW5zdGFsbGVkIGZyb20gdGhlIEdpdEh1YiByZXBvc2l0b3J5LiBUaGUgaW5zdGFsbGF0aW9uIHByb2Nlc3MgcmVxdWlyZXMgdGhlIGBkZXZ0b29sc2AgcGFja2FnZSwgd2hpY2ggbmVlZHMgdG8gYmUgaW5zdGFsbGVkIGZpcnN0LiBJZiB5b3UgYXJlIGEgV2luZG93cyB1c2VyLCB5b3Ugc2hvdWxkIGFsc28gZmlyc3QgZG93bmxvYWQgYW5kIGluc3RhbGwgdGhlIGxhdGVzdCB2ZXJzaW9uIG9mIFtSdG9vbHNdKGh0dHBzOi8vY3Jhbi5yLXByb2plY3Qub3JnL2Jpbi93aW5kb3dzL1J0b29scy8pLg0KDQpgYGB7ciwgZXZhbD1GQUxTRX0NCmlmKCFyZXF1aXJlKGRldnRvb2xzKSkgaW5zdGFsbC5wYWNrYWdlcygiZGV2dG9vbHMiKQ0KDQpgYGANCg0KQWZ0ZXIgYGRldnRvb2xzYCBpcyBwcm9wZXJseSBpbnN0YWxsZWQsIHlvdSBjYW4gaW5zdGFsbCBgcGxpbWFuYCBieSBydW5uaW5nIHRoZSBmb2xsb3dpbmcgY29kZS4gUGxlYXNlLCBub3RlIHRoYXQgdGhlIGluc3RhbGxhdGlvbiB3aWxsIGFsc28gZG93bmxvYWQgdGhlIGRlcGVuZGVuY2llcyByZXF1aXJlZCB0byBydW4gdGhlIHBhY2thZ2UuDQoNCmBgYHtyLCBldmFsPUZBTFNFfQ0KZGV2dG9vbHM6Omluc3RhbGxfZ2l0aHViKCJUaWFnb09saXZvdG8vcGxpbWFuIikNCmBgYA0KDQoNClRoZW0sIGxvYWQgYHBsaW1hbmAgYnkgcnVubmluZyANCmBgYHtyIGxvYWQsIG1lc3NhZ2U9RkFMU0UsIHdhcm5pbmc9RkFMU0V9DQpsaWJyYXJ5KHBsaW1hbikNCmBgYA0KDQoNCiMgSGVscGVyIGZ1bmN0aW9ucw0KYGBge3J9DQojIGhlbHBlciBmdW5jdGlvbiB0byBjb21wdXRlIGNvbmNvcmRhbmNlIHN0YXRpc3RpY3MNCmdldF9jY2MgPC0gZnVuY3Rpb24oZGYsIHByZWRpY3RlZCwgcmVhbCl7DQogIGlmKGlzLmdyb3VwZWRfZGYoZGYpKXsNCiAgICBkZiAlPiUgDQogICAgICBncm91cF9tb2RpZnkofmdldF9jY2MoLngsIHt7cHJlZGljdGVkfX0sIHt7cmVhbH19KSkgJT4lIA0KICAgICAgdW5ncm91cCgpDQogIH0gZWxzZXsNCiAgICBwcmVkaWN0ZWQgPC0gcHVsbChkZiwge3twcmVkaWN0ZWR9fSkNCiAgICByZWFsIDwtIHB1bGwoZGYsIHt7cmVhbH19KQ0KICAgIGNvciA8LSBDQ0MocmVhbCwgcHJlZGljdGVkLCBuYS5ybSA9IFRSVUUpDQogICAgZGF0YS5mcmFtZShyID0gY29yKHJlYWwsIHByZWRpY3RlZCwgdXNlID0gInBhaXJ3aXNlLmNvbXBsZXRlLm9icyIpLA0KICAgICAgICAgICAgICAgcGMgPSBjb3IkcmhvLmNbWzFdXSwNCiAgICAgICAgICAgICAgIGx3cl9jaSA9IGNvciRyaG8uY1tbMl1dLA0KICAgICAgICAgICAgICAgdXByX2NpID0gY29yJHJoby5jW1szXV0sDQogICAgICAgICAgICAgICBiYyA9IGNvciRDLmIpDQogIH0NCn0NCg0KIyBoZWxwZXIgZnVuY3Rpb24gdG8gcGxvdCB0aGUgQ0NDIGluIGdncGFpcnMoKQ0KY3VzdG9tX2NjYyA8LSBmdW5jdGlvbihkYXRhLCBtYXBwaW5nLC4uLil7DQogIGRhdGEyIDwtIGRhdGENCiAgZGF0YTIkeCA8LSBhcy5udW1lcmljKGRhdGFbLGFzX2xhYmVsKG1hcHBpbmckeCldKQ0KICBkYXRhMiR5IDwtIGFzLm51bWVyaWMoZGF0YVssYXNfbGFiZWwobWFwcGluZyR5KV0pDQogIGRhdGEyJGdyb3VwIDwtIGRhdGFbLGFzX2xhYmVsKG1hcHBpbmckY29sb3VyKV0NCiAgY29ycmVsYXRpb25fZGYgPC0gZGF0YTIgJT4lIA0KICAgIGdyb3VwX2J5KGdyb3VwKSAlPiUNCiAgICBzdW1tYXJpemUoZXN0aW1hdGUgPSByb3VuZChhcy5udW1lcmljKERlc2NUb29sczo6Q0NDKHgsIHkpJHJoby5jWzFdKSwzKSkNCiAgZ2dwbG90KGRhdGE9Y29ycmVsYXRpb25fZGYsIGFlcyh4PTEseT1ncm91cCwgY29sb3IgPSBncm91cCkpKw0KICAgIGdlb21fdGV4dChhZXMobGFiZWwgPSBwYXN0ZTAoInJob1tjXTogIiwgZXN0aW1hdGUpKSwNCiAgICAgICAgICAgICAgZGF0YSA9IGNvcnJlbGF0aW9uX2RmLA0KICAgICAgICAgICAgICBwYXJzZSA9IFRSVUUsDQogICAgICAgICAgICAgIHNpemUgPSA0KQ0KfQ0KY3VzdG9tX3Ntb3RoIDwtIGZ1bmN0aW9uKGRhdGEsIG1hcHBpbmcsIG1ldGhvZD0ibG0iLCAuLi4pew0KICBwIDwtIGdncGxvdChkYXRhID0gZGF0YSwgbWFwcGluZyA9IG1hcHBpbmcpICsgDQogICAgZ2VvbV9hYmxpbmUoY29sb3IgPSAiYmxhY2siLA0KICAgICAgICAgICAgICAgIGludGVyY2VwdCA9IDAsDQogICAgICAgICAgICAgICAgc2l6ZSA9IDAuNywNCiAgICAgICAgICAgICAgICBzbG9wZSA9IDEsDQogICAgICAgICAgICAgICAgbGluZXR5cGUgPSAyKSArDQogICAgZ2VvbV9wb2ludChhbHBoYSA9IDAuNiwNCiAgICAgICAgICAgICAgIHNoYXBlID0gMjEsDQogICAgICAgICAgICAgICBzaXplID0gMi41LA0KICAgICAgICAgICAgICAgc3Ryb2tlID0gMCwNCiAgICAgICAgICAgICAgIGNvbG9yID0gImJsYWNrIikgDQogIHANCn0NCg0KIyBnZ3Bsb3QgdGhlbWUNCm15X3RoZW1lIDwtIGZ1bmN0aW9uKCl7DQogIHRoZW1lX2dyZXkoKSAlKyUNCiAgICB0aGVtZShsZWdlbmQucG9zaXRpb24gPSAiYm90dG9tIiwNCiAgICAgICAgICBsZWdlbmQuYm94Lm1hcmdpbj1tYXJnaW4oLTEwLC0xMCwtMTAsLTEwKSwNCiAgICAgICAgICBsZWdlbmQudGl0bGUgPSBlbGVtZW50X2JsYW5rKCksDQogICAgICAgICAgYXhpcy50aWNrcy5sZW5ndGggPSB1bml0KDAuMiwgImNtIiksDQogICAgICAgICAgcGFuZWwuZ3JpZCA9IGVsZW1lbnRfYmxhbmsoKSwNCiAgICAgICAgICBwYW5lbC5zcGFjaW5nID0gdW5pdCgwLCAiY20iKSwNCiAgICAgICAgICBwYW5lbC5iYWNrZ3JvdW5kID0gZWxlbWVudF9yZWN0KGNvbG9yID0gImJsYWNrIiwgZmlsbCA9IE5BKSwNCiAgICAgICAgICBheGlzLnRleHQgPSBlbGVtZW50X3RleHQoY29sb3IgPSAiYmxhY2siLCBzaXplID0gMTApLA0KICAgICAgICAgIGF4aXMudGl0bGUgPSBlbGVtZW50X3RleHQoY29sb3IgPSAiYmxhY2siLCBzaXplID0gMTApLA0KICAgICAgICAgIGxlZ2VuZC5rZXkgPSBlbGVtZW50X3JlY3QoZmlsbCA9IE5BKSwNCiAgICAgICAgICBzdHJpcC5iYWNrZ3JvdW5kID0gZWxlbWVudF9yZWN0KGNvbG9yID0gImJsYWNrIiwgZmlsbCA9IE5BKSkNCn0NCg0KDQpgYGANCg0KIyBJbWFnZSBtYW5pcHVsYXRpb24NCg0KIyMgSW1wb3J0aW5nIGltYWdlcyANCg0KYGBge3IgaW1wb3J0MSB9DQpzb3kgPC0gaW1hZ2VfaW1wb3J0KCJkYXRhL3NveV9ncmFpbnMuanBnIikNCnNveTIgPC0gaW1hZ2VfaW1wb3J0KCJkYXRhL3NveV9ncmFpbnNfMi5qcGciKQ0KDQpgYGANCg0KDQpUbyBpbXBvcnQgYSBsaXN0IG9mIGltYWdlcywgdGhlIGFyZ3VtZW50IGBwYXR0ZXJuYCBvZiB0aGUgZnVuY3Rpb24gYGltYWdlX2ltcG9ydCgpYCBpcyB1c2VkLiBBbGwgaW1hZ2VzIHRoYXQgbWF0Y2ggdGhlIHBhdHRlcm4gbmFtZSBhcmUgaW1wb3J0ZWQgaW50byBhIGxpc3QuDQoNCmBgYHtyIGltcG9ydDIgfQ0Kc295X2xpc3QgPC0gDQogIGltYWdlX2ltcG9ydChwYXR0ZXJuID0gInNveV8iLA0KICAgICAgICAgICAgICAgcGF0aCA9ICIuL2RhdGEiKSAjIGNob29zZSBwYXRoIGRpcmVjdG9yeQ0KbmFtZXMoc295X2xpc3QpDQpgYGANCg0KDQoNCg0KIyMgRGlzcGxheWluZyBpbWFnZXMgDQpTaW5nbGUgaW1hZ2VzIGFyZSBkaXNwbGF5ZWQgd2l0aCBgcGxvdCgpYC4gRm9yIGNvbWJpbmluZyBpbWFnZXMsIHRoZSBmdW5jdGlvbiBgaW1hZ2VfY29tYmluZSgpYCBpcyB1c2VkLiBVc2VycyBjYW4gaW5mb3JtIGVpdGhlciBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIG9iamVjdHMgb3IgYSBsaXN0IG9mIG9iamVjdHMgb2YgY2xhc3MgYEltYWdlYC4NCg0KYGBge3IgZGlzcGxheTEsIGZpZy53aWR0aD0xMn0NCiMgU2luZ2xlIGltYWdlcw0KcGxvdChzb3kpDQoNCg0KYGBgDQoNCg0KDQpgYGB7ciBkaXNwbGF5MiwgZmlnLndpZHRoPTEyfQ0KIyBDb21iaW5lIGltYWdlcw0KaW1hZ2VfY29tYmluZShzb3ksIHNveTIpDQoNCiMgQ29tYmluZSBpbWFnZXMNCmltYWdlX2NvbWJpbmUoc295X2xpc3QpDQoNCg0KYGBgDQoNCg0KIyMgTWFuaXB1bGF0aW5nIGltYWdlcw0KDQoNCmBwbGltYW5gIHByb3ZpZGVzIGEgc2V0IG9mIGBpbWFnZV8qKClgIGZ1bmN0aW9ucyB0byBwZXJmb3JtIGltYWdlIG1hbmlwdWxhdGlvbiBhbmQgdHJhbnNmb3JtYXRpb24gb2YgdW5pcXVlIGltYWdlcyBvciBhIGxpc3Qgb2YgaW1hZ2VzIGJhc2VkIG9uIHRoZSBbRUJJbWFnZSBwYWNrYWdlXShodHRwczovL3d3dy5iaW9jb25kdWN0b3Iub3JnL3BhY2thZ2VzL3JlbGVhc2UvYmlvYy92aWduZXR0ZXMvRUJJbWFnZS9pbnN0L2RvYy9FQkltYWdlLWludHJvZHVjdGlvbi5odG1sKS4NCg0KIyMjIFJlc2l6ZSBhbiBpbWFnZQ0KU29tZXRpbWVzIHJlc2l6aW5nIG9mIGhpZ2gtcmVzb2x1dGlvbiBpbWFnZXMgaXMgbmVlZGVkIHRvIHJlZHVjZSB0aGUgcHJvY2Vzc2luZyB0aW1lLiBUaGUgZnVuY3Rpb24gYGltYWdlX3Jlc2l6ZSgpYCBpcyB1c2VkIHRvIHJlc2l6ZSBhbiBpbWFnZS4gVGhlIGFyZ3VtZW50IGByZWxfc2l6ZWAgY2FuIGJlIHVzZWQgdG8gcmVzaXplIHRoZSBpbWFnZSBieSByZWxhdGl2ZSBzaXplLiBGb3IgZXhhbXBsZSwgYnkgc2V0dGluZyBgcmVsX3NpemUgPSA1MGAgdG8gYW4gaW1hZ2Ugb2Ygd2lkdGggMTI4MCB4IDcyMCwgdGhlIG5ldyBpbWFnZSB3aWxsIGhhdmUgYSBzaXplIG9mIDY0MCB4IDM2MC4gVGhpcyBpcyB1c2VmdWwgdG8gc3BlZWQgdXAgdGhlIHRpbWUgb2YgYW5hbHlzaXMgc3VjaCBhcyB0aG9zZSBjb21wdXRlZCB3aXRoIGBhbmFseXplX29iamVjdHMoKWAgYW5kIGBtZWFzdXJlX2Rpc2Vhc2UoKWAuDQoNCmBgYHtyIG1hbmlwdWxhdGUxfQ0KaW1hZ2VfZGltZW5zaW9uKHNveSkNCnNveV9yZXNpemVkIDwtIGltYWdlX3Jlc2l6ZShzb3ksIHJlbF9zaXplID0gNTApDQppbWFnZV9kaW1lbnNpb24oc295X3Jlc2l6ZWQpDQpgYGANCg0KDQojIyMgQ3JvcCBhbiBpbWFnZQ0KQ3JvcHBpbmcgaW1hZ2VzIGlzIHVzZWZ1bCB0byByZW1vdmUgbm9pc2VzIGZyb20gdGhlIGltYWdlIGVkZ2UsIGFzIHdlbGwgYXMgdG8gcmVkdWNlIHRoZSBzaXplIG9mIGltYWdlcyBiZWZvcmUgcHJvY2Vzc2luZy4gVG8gY3JvcCBhbiBpbWFnZSwgdGhlIGZ1bmN0aW9uIGBpbWFnZV9jcm9wKClgIGlzIHVzZWQuIFVzZXJzIG5lZWQgdG8gaW5mb3JtIGEgbnVtZXJpYyB2ZWN0b3IgaW5kaWNhdGluZyB0aGUgcGl4ZWwgcmFuZ2UgKGB3aWR0aGAgYW5kIGBoZWlnaHRgKSB0aGF0IHdpbGwgYmUgbWFpbnRhaW5lZCBpbiB0aGUgY3JvcHBlZCBpbWFnZS4NCg0KYGBge3J9DQpjcm9wMSA8LQ0KICBpbWFnZV9jcm9wKHNveSwNCiAgICAgICAgICAgICB3aWR0aCA9IDE3MDo3MjAsDQogICAgICAgICAgICAgaGVpZ2h0ID0gMzAwOjY1MCwNCiAgICAgICAgICAgICBwbG90ID0gVFJVRSkNCmBgYA0KDQpJZiBvbmx5IGB3aWR0aGAgb3IgYGhlaWdodGAgYXJlIGluZm9ybWVkLCB0aGUgaW1hZ2Ugd2lsbCBiZSBjcm9wcGVkIHZlcnRpY2FsbHkgb3IgaG9yaXpvbnRhbGx5Lg0KDQpgYGB7cn0NCmNyb3AyIDwtDQogIGltYWdlX2Nyb3Aoc295LA0KICAgICAgICAgICAgIHdpZHRoID0gMTcwOjcyMCwNCiAgICAgICAgICAgICBwbG90ID0gVFJVRSkNCmBgYA0KDQpJZiBib3RoIGB3aWR0aGAgYW5kIGBoZWlnaHRgIGFyZSBtaXNzaW5nLCBhbiBpdGVyYXRpdmUgcHJvY2VzcyBvZiBpbWFnZSBjcm9wcGluZyBpcyBwZXJmb3JtZWQuDQoNCmBgYHtyIGV2YWw9RkFMU0V9DQojIG9ubHkgcnVuIGluIGFuIGl0ZXJhdGl2ZSBzZWN0aW9uDQppbWFnZV9jcm9wKHNveSkNCmBgYA0KDQoNCkFkZGl0aW9uYWxseSwgYW4gYXV0b21hdGVkIGNyb3BwaW5nIHByb2Nlc3MgY2FuIGJlIHBlcmZvcm1lZC4gSW4gdGhpcyBjYXNlLCB0aGUgaW1hZ2Ugd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGNyb3BwZWQgdG8gdGhlIGFyZWEgb2Ygb2JqZWN0cyB3aXRoIGFuIGVkZ2Ugb2YgZml2ZSBwaXhlbHMgYnkgZGVmYXVsdC4NCg0KYGBge3J9DQphdXRvX2Nyb3AgPC0gaW1hZ2VfYXV0b2Nyb3Aoc295LCBwbG90ID0gVFJVRSkNCmBgYA0KDQoNClRoZSBmdW5jdGlvbiBgaW1hZ2VfdHJpbSgpYCBpcyB1c2VkIHRvIHRyaW0gcGl4ZWxzIGZyb20gaW1hZ2UgZWRnZXMuDQoNCg0KYGBge3IgbWFuaXB1bGF0ZTIsIGZpZy53aWR0aD0xMH0NCiMgdHJpbSAxMDAgcGl4ZWxzIGZyb20gYWxsIGVkZ2VzDQpzb3lfdHJpbSA8LSBpbWFnZV90cmltKHNveSwgZWRnZSA9IDEwMCwgcGxvdCA9IFRSVUUpDQoNCiMgVGhlIHNhbWUgaXMgYWNoaWV2ZWQgd2l0aA0Kc295X3RyaW0yIDwtDQogIGltYWdlX3RyaW0oc295LA0KICAgICAgICAgICAgIHRvcCA9IDEwMCwNCiAgICAgICAgICAgICBib3R0b20gPSAxMDAsDQogICAgICAgICAgICAgbGVmdCA9IDEwMCwNCiAgICAgICAgICAgICByaWdodCA9IDEwMCwNCiAgICAgICAgICAgICBwbG90ID0gVFJVRSkNCg0KIyB0cmltIDIwMCBwaXhlbHMgZnJvbSB0b3AgYW5kIGJvdHRvbQ0Kc295X3RyaW0zIDwtDQogIGltYWdlX3RyaW0oc295LA0KICAgICAgICAgICAgIHRvcCA9IDIwMCwNCiAgICAgICAgICAgICBib3R0b20gPSAyMDAsDQogICAgICAgICAgICAgcGxvdCA9IFRSVUUpDQojIHRyaW0gdG8gNSBwaXhlbHMgYXJvdW5kIG9iamVjdHMnIGFyZWENCg0KYGBgDQoNCg0KDQoNCiMjIyBJbWFnZSByZXNvbHV0aW9uIChEUEkpIHsjZHBpfQ0KVGhlIGZ1bmN0aW9uIGBkcGkoKWAgcnVucyBhbiBpbnRlcmFjdGl2ZSBmdW5jdGlvbiB0byBjb21wdXRlIHRoZSBpbWFnZSByZXNvbHV0aW9uIGdpdmVuIGEga25vd24gZGlzdGFuY2UgaW5mb3JtZWQgYnkgdGhlIHVzZXIuIFRvIGNvbXB1dGUgdGhlIGltYWdlIHJlc29sdXRpb24gKGRwaSkgdGhlIHVzZXIgbXVzdCB1c2UgdGhlIGxlZnQgYnV0dG9uIG1vdXNlIHRvIGNyZWF0ZSBhIGxpbmUgb2Yga25vd24gZGlzdGFuY2UuIFRoaXMgY2FuIGJlIGRvbmUsIGZvciBleGFtcGxlLCB1c2luZyBhIHRlbXBsYXRlIHdpdGgga25vd24gZGlzdGFuY2UgaW4gdGhlIGltYWdlIChlLmcuLCBgbGVhdmVzLkpQR2ApLg0KDQpgYGB7ciBldmFsPUZBTFNFfQ0KIyBvbmx5IHJ1biBpbiBhbiBpbnRlcmFjdGl2ZSBzZWN0aW9uDQpsZWF2ZXMgPC0gaW1hZ2VfaW1wb3J0KCIuL2RhdGEvbGVhZl9hcmVhL2xlYXZlcy5KUEciKQ0KZHBpKGxlYXZlcykNCmBgYA0KDQoNCjxpZnJhbWUgd2lkdGg9Ijc2MCIgaGVpZ2h0PSI0MzAiIHNyYz0iaHR0cHM6Ly93d3cueW91dHViZS5jb20vZW1iZWQvUmgxMF9wTGdlbmciIHRpdGxlPSJZb3VUdWJlIHZpZGVvIHBsYXllciIgZnJhbWVib3JkZXI9IjAiIGFsbG93PSJhY2NlbGVyb21ldGVyOyBhdXRvcGxheTsgY2xpcGJvYXJkLXdyaXRlOyBlbmNyeXB0ZWQtbWVkaWE7IGd5cm9zY29wZTsgcGljdHVyZS1pbi1waWN0dXJlIiBhbGxvd2Z1bGxzY3JlZW4+PC9pZnJhbWU+DQoNCg0KDQojIyMgUm90YXRlIGFuIGltYWdlDQpgaW1hZ2Vfcm90YXRlKClgIGlzIHVzZWQgdG8gcm90YXRlcyB0aGUgaW1hZ2UgY2xvY2t3aXNlIGJ5IHRoZSBnaXZlbiBhbmdsZS4NCg0KYGBge3IgbWFuaXB1bGF0ZTMgfQ0Kc295X3JvdGF0ZWQgPC0gaW1hZ2Vfcm90YXRlKHNveSwgYW5nbGUgPSA0NSwgcGxvdCA9IFRSVUUpDQpgYGANCg0KDQojIyMgSG9yaXpvbnRhbCBhbmQgdmVydGljYWwgcmVmbGVjdGlvbg0KYGltYWdlX2hyZWZsZWN0KClgIGFuZCBgaW1hZ2VfdnJlZmxlY3QoKWAgcGVyZm9ybXMgdmVydGljYWwgYW5kIGhvcml6b250YWwgcmVmbGVjdGlvbiBvZiBpbWFnZXMsIHJlc3BlY3RpdmVseS4NCg0KYGBge3IgbWFuaXB1bGF0ZTQsIGZpZy53aWR0aD0yMH0NCnNveV9ocmVmbCA8LSBpbWFnZV9ocmVmbGVjdChzb3kpDQpzb3lfdnJlZmwgPC0gaW1hZ2VfdnJlZmxlY3Qoc295KQ0KaW1hZ2VfY29tYmluZShzb3ksIHNveV9ocmVmbCwgc295X3ZyZWZsLCBuY29sID0gMykNCmBgYA0KDQoNCg0KIyMjIEhvcml6b250YWwgYW5kIHZlcnRpY2FsIGNvbnZlcnNpb24NCmBpbWFnZV9ob3Jpem9udGFsKClgIGFuZCBgaW1hZ2VfdmVydGljYWwoKWAgY29udmVydHMgKGlmIG5lZWRlZCkgYW4gaW1hZ2UgdG8gYSBob3Jpem9udGFsIG9yIHZlcnRpY2FsIGltYWdlLCByZXNwZWN0aXZlbHkuDQoNCmBgYHtyIG1hbmlwdWxhdGU1LCBmaWcud2lkdGg9MjB9DQpzb3lfaCA8LSBpbWFnZV9ob3Jpem9udGFsKHNveSkNCnNveV92IDwtIGltYWdlX3ZlcnRpY2FsKHNveSkNCmltYWdlX2NvbWJpbmUoc295LCBzb3lfaCwgc295X3YsIG5jb2wgPSAzKQ0KDQpgYGANCg0KDQojIyMgRmlsdGVyLCBibHVyLCBjb250cmFzdCwgZGlsYXRhdGlvbiwgYW5kIGVyb3Npb24NCg0KYGBge3IgbWFuaXB1bGF0ZTYsIGZpZy53aWR0aD0xMCwgZmlnLmhlaWdodD02fQ0Kc295X2ZpbHRlciA8LSBpbWFnZV9maWx0ZXIoc295KQ0Kc295X2JsdXIgPC0gaW1hZ2VfYmx1cihzb3kpDQpzb3lfY29udHJhc3QgPC0gaW1hZ2VfY29udHJhc3Qoc295KQ0Kc295X2RpbGF0YXRpb24gPC0gaW1hZ2VfZGlsYXRlKHNveSkNCnNveV9lcm9zaW9uIDwtIGltYWdlX2Vyb2RlKHNveSkNCmltYWdlX2NvbWJpbmUoc295LCBzb3lfZmlsdGVyLCBzb3lfYmx1ciwgc295X2NvbnRyYXN0LCBzb3lfZGlsYXRhdGlvbiwgc295X2Vyb3Npb24pDQpgYGANCg0KDQoNCiMjIyBFeHBvcnRpbmcgaW1hZ2VzDQpUbyBleHBvcnQgaW1hZ2VzIHRvIHRoZSBjdXJyZW50IGRpcmVjdG9yeSwgdXNlIHRoZSBmdW5jdGlvbiBgaW1hZ2VfZXhwb3J0KClgLiBJZiBhIGxpc3Qgb2YgaW1hZ2VzIGlzIGV4cG9ydGVkLCB0aGUgaW1hZ2VzIHdpbGwgYmUgc2F2ZWQgY29uc2lkZXJpbmcgdGhlIG5hbWUgYW5kIGV4dGVuc2lvbiBwcmVzZW50IGluIHRoZSBsaXN0LiBJZiBubyBleHRlbnNpb24gaXMgcHJlc2VudCwgdGhlIGltYWdlcyB3aWxsIGJlIHNhdmVkIGFzIGAqLmpwZ2AgZmlsZXMuDQoNCmBgYHtyIGV4cG9ydH0NCmltYWdlX2V4cG9ydChzb3ksICJleHBvcnRlZC5qcGciKQ0KYGBgDQoNCiMjIyBDb21iaW5pbmcgZnVuY3Rpb25zDQpgcGxpbWFuYCBvZmZlcnMgdGhlIHBvc3NpYmlsaXR5IG9mIGNvbWJpbmluZyBmdW5jdGlvbnMgd2l0aCB0aGUgbmV3IFIgYmFzZSAoNC4xKSBmb3J3YXJkIHBpcGUgb3BlcmF0b3IgYHw+YC4NCg0KYGBge3IgY29tYmluaW5nZnVuY3QsIGZpZy53aWR0aD0xMCwgZmlnLmhlaWdodD01fQ0KIyB0ZW1wb3JhcnkgZGlyZWN0b3J5DQphIDwtIGltYWdlX2ltcG9ydChwYXR0ZXJuID0gInNveV9ncmFpbnMiLA0KICAgICAgICAgICAgICAgICAgcGF0aCA9ICIuL2RhdGEiKQ0KaW1hZ2VfY29tYmluZShhKQ0KDQojIHJlZHVjZSByZXNvbHV0aW9uLCBhdXRvY3JvcCwgdmVydGljYWwgcm90YXRpb24sDQojIGNyZWF0ZSBhIGJpbmFyeSBpbWFnZSwgZXhwb3J0DQphIHw+DQogIGltYWdlX3Jlc2l6ZShyZWxfc2l6ZSA9IDUwKSB8Pg0KICBpbWFnZV9ibHVyKCkgfD4NCiAgaW1hZ2VfYXV0b2Nyb3AoKSB8Pg0KICBpbWFnZV92ZXJ0aWNhbCgpIHw+DQogIGltYWdlX2JpbmFyeShpbmRleCA9ICJOQiIsDQogICAgICAgICAgICAgICBzaG93X2ltYWdlID0gRkFMU0UsDQogICAgICAgICAgICAgICByZXNpemUgPSBGQUxTRSkgfD4NCiAgaW1hZ2VfY29tYmluZSgpDQpgYGANCg0KDQoNCiMgSW1hZ2Ugc2VnbWVudGF0aW9uDQpJbiBgcGxpbWFuYCB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBjYW4gYmUgdXNlZCB0byBzZWdtZW50IGFuIGltYWdlLg0KDQoqIGBpbWFnZV9iaW5hcnkoKWAgdG8gcHJvZHVjZSBhIGJpbmFyeSAoYmxhY2sgYW5kIHdoaXRlKSBpbWFnZQ0KKiBgaW1hZ2Vfc2VnbWVudCgpYCB0byBwcm9kdWNlIGEgc2VnbWVudGVkIGltYWdlIChpbWFnZSBvYmplY3RzIGFuZCBhIHdoaXRlIGJhY2tncm91bmQpLg0KKiBgaW1hZ2Vfc2VnbWVudF9pdGVyKClgIHRvIHNlZ21lbnQgYW4gaW1hZ2UgaXRlcmF0aXZlbHkuDQoNCkJvdGggZnVuY3Rpb25zIHNlZ21lbnQgdGhlIGltYWdlIGJhc2VkIG9uIHRoZSB2YWx1ZSBvZiBzb21lIGltYWdlIGluZGV4LCB3aGljaCBtYXkgYmUgb25lIG9mIHRoZSBSR0IgYmFuZHMgb3IgYW55IG9wZXJhdGlvbiB3aXRoIHRoZXNlIGJhbmRzLiBJbnRlcm5hbGx5LCB0aGVzZSBmdW5jdGlvbnMgY2FsbCBgaW1hZ2VfaW5kZXgoKWAgdG8gY29tcHV0ZSB0aGVzZSBpbmRleGVzLiBUaGUgZm9sbG93aW5nIGluZGV4ZXMgYXJlIGN1cnJlbnRseSBhdmFpbGFibGUuDQoNCg0KfCBJbmRleCB8ICAgICAgICAgICBFcXVhdGlvbiAgICAgICAgICB8DQp8LS0tLS0tLXw6LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tOnwNCnwgUiAgICAgfCAgICAgICAgICAgICAgUiAgICAgICAgICAgICAgfA0KfCBHICAgICB8ICAgICAgICAgICAgICBHICAgICAgICAgICAgICB8DQp8IEIgICAgIHwgICAgICAgICAgICAgIEIgICAgICAgICAgICAgIHwNCnwgTlIgICAgfCAgICAgICAgICBSLyhSK0crQikgICAgICAgICAgfA0KfCBORyAgICB8ICAgICAgICAgIEcvKFIrRytCKSAgICAgICAgICB8DQp8IE5CICAgIHwgICAgICAgICAgQi8oUitHK0IpICAgICAgICAgIHwNCnwgR0IgICAgfCAgICAgICAgICAgICBHL0IgICAgICAgICAgICAgfA0KfCBSQiAgICB8ICAgICAgICAgICAgIFIvQiAgICAgICAgICAgICB8DQp8IEdSICAgIHwgICAgICAgICAgICAgRy9SICAgICAgICAgICAgIHwNCnwgQkkgICAgfCAgICBzcXJ0KChSXF4yK0dcXjIrQlxeMikvMykgICAgfA0KfCBCSU0gICB8ICAgIHNxcnQoKFJcKjIrR1wqMitCXCoyKS8zKSAgICB8DQp8IFNDSSAgIHwgICAgICAgICAoUi1HKS8oUitHKSAgICAgICAgIHwNCnwgR0xJICAgfCAgICAgKDJcKkctUi1CKS8oMlwqRytSK0IpICAgICB8DQp8IEhJICAgIHwgICAgICAgKDJcKlItRy1CKS8oRy1CKSAgICAgICB8DQp8IE5HUkRJIHwgICAgICAgICAoRy1SKS8oRytSKSAgICAgICAgIHwNCnwgTkRHQkkgfCAgICAgICAgIChHLUIpLyhHK0IpICAgICAgICAgfA0KfCBORFJCSSB8ICAgICAgICAgKFItQikvKFIrQikgICAgICAgICB8DQp8IEkgICAgIHwgICAgICAgICAgICBSK0crQiAgICAgICAgICAgIHwNCnwgUyAgICAgfCAgICAoKFIrRytCKS0zXCpCKS8oUitHK0IpICAgIHwNCnwgVkFSSSAgfCAgICAgICAgKEctUikvKEcrUi1CKSAgICAgICAgfA0KfCBIVUUgICB8ICBhdGFuKDJcKihCLUctUikvMzAuNVwqKEctUikpIHwNCnwgSFVFMiAgfCAgYXRhbigyXCooUi1HLVIpLzMwLjVcKihHLUIpKSB8DQp8IEJHSSAgIHwgICAgICAgICAgICAgQi9HICAgICAgICAgICAgIHwNCnwgTCAgICAgfCAgICAgICAgICAgUitHK0IvMyAgICAgICAgICAgfA0KfCBHUkFZICB8IDAuMjk5XCpSICsgMC41ODdcKkcgKyAwLjExNFwqQiB8DQoNCg0KDQpIZXJlLCBJIHVzZSB0aGUgYXJndW1lbnQgYGluZGV4ImAgdG8gdGVzdCB0aGUgc2VnbWVudGF0aW9uIGJhc2VkIG9uIHRoZSBSR0IgYW5kIHRoZWlyIG5vcm1hbGl6ZWQgdmFsdWVzLiBVc2VycyBjYW4gYWxzbyBwcm92aWRlIHRoZWlyIG93biBpbmRleCB3aXRoIHRoZSBhcmd1bWVudCBgbXlfaW5kZXhgLg0KDQpgYGB7ciBzZWdtZW50YXRpb24xIH0NCnNveSA8LSBpbWFnZV9pbXBvcnQoImRhdGEvc2VnbWVudGF0aW9uL3NlZ19tZWRpdW0uanBnIiwgcGxvdCA9IFRSVUUpDQoNCmBgYA0KDQpgYGB7ciBzZWdtZW50YXRpb24yLCBmaWcud2lkdGg9MTAsIGZpZy5oZWlnaHQ9NX0NCiMgQ29tcHV0ZSB0aGUgaW5kZXhlcw0KaW5kZXhlcyA8LSBpbWFnZV9pbmRleChzb3ksIGluZGV4ID0gYygiUiwgRywgQiwgTlIsIE5HLCBOQiIpKQ0KDQoNCiMgQ3JlYXRlIGEgcmFzdGVyIHBsb3Qgd2l0aCB0aGUgUkdCIHZhbHVlcw0KcGxvdChpbmRleGVzKQ0KDQojIENyZWF0ZSBhIGhpc3RvZ3JhbSB3aXRoIHRoZSBSR0IgdmFsdWVzDQpwbG90KGluZGV4ZXMsIHR5cGUgPSAiaGlzdCIpDQpgYGANCg0KSW4gdGhpcyBleGFtcGxlLCB3ZSBjYW4gc2VlIHRoZSBkaXN0cmlidXRpb24gb2YgdGhlIFJHQiB2YWx1ZXMgKGZpcnN0IHJvdykgYW5kIHRoZSBub3JtYWxpemVkIFJHQiB2YWx1ZXMgKHNlY29uZCByb3cpLiBUaGUgdHdvIHBlYWtzIHJlcHJlc2VudCB0aGUgZ3JhaW5zIChzbWFsbGVyIHBlYWspIGFuZCB0aGUgYmx1ZSBiYWNrZ3JvdW5kIChsYXJnZXIgcGVhaykuIFRoZSBjbGVhcmVyIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlc2UgcGVha3MsIHRoZSBiZXR0ZXIgd2lsbCB0aGUgaW1hZ2Ugc2VnbWVudGF0aW9uLg0KDQojIyBTZWdtZW50IGFuIGltYWdlDQoNClRoZSBmdW5jdGlvbiBgaW1hZ2Vfc2VnbWVudGF0aW9uKClgIGlzIHVzZWQgdG8gc2VnbWVudCBpbWFnZXMgdXNpbmcgaW1hZ2UgaW5kZXhlcy4gSW4gdGhpcyBleGFtcGxlLCBJIHdpbGwgdXNlIHRoZSBzYW1lIGluZGV4ZXMgY29tcHV0ZWQgYmVsb3cgdG8gc2VlIGhvdyB0aGUgaW1hZ2UgaXMgc2VnbWVudGVkLiBUaGUgb3V0cHV0IG9mIHRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgYXMgaW5wdXQgaW4gdGhlIGZ1bmN0aW9uIGBhbmFseXplX29iamVjdHMoKWAuDQoNCmBgYHtyIHNlZ21lbnRhdGlvbjMsIGZpZy53aWR0aD0xMCwgZmlnLmhlaWdodD01fQ0Kc2VnbWVudGVkIDwtIGltYWdlX3NlZ21lbnQoc295LCBpbmRleCA9IGMoIlIsIEcsIEIsIE5SLCBORywgTkIiKSkNCg0KYGBgDQoNCkl0IHNlZW1zIHRoYXQgdGhlIGAiTkIiYCBpbmRleCBwcm92aWRlZCBiZXR0ZXIgc2VnbWVudGF0aW9uLiBgIlIiYCBhbmQgYCJOUiJgIHJlc3VsdGVkIGluIGFuIGludmVydGVkIHNlZ21lbnRlZCBpbWFnZSwgaS5lLiwgdGhlIGdyYWlucyB3ZXJlIGNvbnNpZGVyZWQgYXMgYmFja2dyb3VuZCBhbmQgdGhlIHJlbWFpbmluZyBhcyAnc2VsZWN0ZWQnIGltYWdlLiBUbyBjaXJjdW12ZW50IHRoaXMgcHJvYmxlbSwgd2UgY2FuIHVzZSB0aGUgYXJndW1lbnQgYGludmVydGAgaW4gdGhvc2UgZnVuY3Rpb25zLg0KDQpgYGB7ciBzZWdtZW50YXRpb240LCBmaWcud2lkdGg9MTAsIGZpZy5oZWlnaHQ9NX0NCmltYWdlX3NlZ21lbnQoc295LA0KICAgICAgICAgICAgICBpbmRleCA9IGMoIlIsIE5SIiksDQogICAgICAgICAgICAgIGludmVydCA9IFRSVUUpDQoNCmBgYA0KDQoNCiMjIEl0ZXJhdGl2ZSBzZWdtZW50YXRpb24NCg0KVGhlIGZ1bmN0aW9uIGBpbWFnZV9zZWdtZW50X2l0ZXIoKWAgcHJvdmlkZXMgYW4gaXRlcmF0aXZlIGltYWdlIHNlZ21lbnRhdGlvbiwgcmV0dXJuaW5nIHRoZSBwcm9wb3J0aW9ucyBvZiBzZWdtZW50ZWQgcGl4ZWxzLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIG1vcmUgdGhhbiBvbmUgc2VnbWVudGF0aW9uIHByb2NlZHVyZSBpcyBuZWVkZWQuIFVzZXJzIGNhbiBjaG9vc2UgaG93IG1hbnkgc2VnbWVudGF0aW9uIHBlcmZvcm0sIHVzaW5nIHRoZSBhcmd1bWVudCBgbnNlZ2AuDQoNCmBgYHtyIHNlZ21lbnRhdGlvbjV9DQpzZWdfaXRlciA8LSBpbWFnZV9pbXBvcnQoaW1hZ2VfcGxpbWFuKCJzZXZfbGVhZl9uYi5qcGciKSwgcGxvdCA9IFRSVUUpDQoNCmBgYA0KDQpVc2luZyBhIHNveWJlYW4gc2FtcGxlIGxlYWYgKGFib3ZlKSwgSSB3aWxsIHVzZSB0aGUgZnVuY3Rpb24gYGltYWdlX3NlZ21lbnRfaXRlcmAgdG8gc2VnbWVudCB0aGUgZGlzZWFzZWQgdGlzc3VlIGZyb20gaGVhbHRoeSB0aXNzdWUuIFRoZSBhaW0gaXMgdG8gc2VnbWVudCB0aGUgc3ltcHRvbXMgaW50byB0d28gY2xhc3NlcywgbmFtZWx5LCBuZWNyb3NpcyAoYnJvd24gYXJlYXMpIGFuZCBjaGxvcm9zaXMgKHllbGxvdyBhcmVhcyksIGFuZCBjb21wdXRlIHRoZSBwZXJjZW50YWdlIG9mIGVhY2ggc3ltcHRvbSBjbGFzcy4NCg0KRmlyc3QsIHdlIG5lZWQgdG8gZmluZCBhIHN1aXRhYmxlIGluZGV4IGZvciBzZWdtZW50YXRpb24uDQoNCmBgYHtyIHNlZ21lbnRhdGlvbjYsIGZpZy53aWR0aD0xMCwgZmlnLmhlaWdodD0xMH0NCiMgRmlyc3Qgc2VnbWVudGF0aW9uDQpzZWcgPC0NCiAgaW1hZ2Vfc2VnbWVudChzZWdfaXRlciwNCiAgICAgICAgICAgICAgICBpbmRleCA9ICJhbGwiKQ0KDQojIHNlY29uZCBzZWdtZW50YXRpb24NCnNlZzIgPC0NCiAgaW1hZ2Vfc2VnbWVudChzZWckVkFSSSRpbWFnZSwNCiAgICAgICAgICAgICAgICBpbmRleCA9ICJhbGwiKQ0KDQpgYGANCg0KTm90ZSB0aGF0IHRoZSBzYW1lIHJlc3VsdHMgY2FuIGJlIG9idGFpbmV0IHdpdGggYGltYWdlX3NlZ21lbnRfaXRlcigpYCB1c2luZyBhbiBpdGVyYXRpdmUgc2VjdGlvbi4NCg0KYGBge3Igc2VnbWVudGF0aW9uNywgZXZhbD1GQUxTRX0NCiMgT25seSBydW4gaXRlcmF0aXZlbHkNCmltYWdlX3NlZ21lbnRfaXRlcihzZWdfaXRlciwgbnNlZyA9IDIpDQpgYGANCg0KDQpUaGUgYCJWQVJJImAgc2VlbXMgdG8gYmUgYSBzdWl0YWJsZSBpbmRleCB0byBzZWdtZW50IHN5bXB0b21zIChuZWNyb3NpcyBhbmQgY2hsb3Jvc2lzKSBmcm9tIGhlYWx0aHkgdGlzc3Vlcy4gVGhlIGAiR0xJImAgY2FuIGJlIHVzZWQgdG8gc2VnbWVudCBuZWNyb3NpcyBmcm9tIGNobG9yb3Npcy4gS25vd2luZyB0aGlzLCB3ZSBjYW4gbm93IHVzZSBgaW1hZ2Vfc2VnbWVudF9pdGVyKClgIGV4cGxpY2l0bHkgaW5kaWNhdGluZyB0aGVzZSBpbmRleGVzLCBhcyBmb2xsb3dzDQoNCmBgYHtyIHNlZ21lbnRhdGlvbjgsIGZpZy53aWR0aD0xMH0NCg0KaW1hZ2Vfc2VnbWVudF9pdGVyKHNlZ19pdGVyLA0KICAgICAgICAgICAgICAgICAgIG5zZWcgPSAyLCAjIHR3byBzZWdtZW50YXRpb25zDQogICAgICAgICAgICAgICAgICAgaW5kZXggPSBjKCJWQVJJIiwgIkdMSSIpLA0KICAgICAgICAgICAgICAgICAgIG5jb2wgPSAzKQ0KYGBgDQoNCkl0IGNhbiBiZSBvYnNlcnZlZCB0aGF0IDMwLjI4JSBvZiB0aGUgb3JpZ2luYWwgaW1hZ2Ugd2VyZSBjaGFyYWN0ZXJpemVkIGFzIHN5bXB0b21zIChib3RoIG5lY3Jvc2lzIGFuZCBjaGxvcm9zaXMpLiBPZiBvdXQgdGhpcyAoc3ltcHRvbWF0aWMgYXJlYSksIDI1LjkyJSBhcmUgbmVjcm90aWMgYXJlYXMuIFNvIDcuODUlIG9mIHRoZSB0b3RhbCBhcmVhIHdlcmUgY29uc2lkZXJlZCBhcyBuZWNyb3RpYyBhcmVhcyAoMzAuMjg4ICRcdGltZXMkIDAuMjU5MiBvciAxMDM0NjQvMTMxNzYwMCAkXHRpbWVzJCAxMDApIGFuZCAyMi40MyUgKDMwLjI4IC0gNy44NSBvciAoMzk5MDc1IC0gMTAzNDY0KSAvIDEzMTc2MDAgJFx0aW1lcyQgMTAwKSB3ZXJlIGNvbnNpZGVyZWQgYXMgY2hsb3JvdGljIGFyZWFzLg0KDQpVc2VycyBjYW4gdXNlIHRoZSBhcmd1bWVudCBgdGhyZXNob2xkYCB0byBjb250cm9scyBob3cgc2VnbWVudGF0aW9uIGlzIG1hZGUuIEJ5IGRlZmF1bHQgKGB0aHJlc2hvbGQgPSAiT3RzdSJgKSwgYSB0aHJlc2hvbGQgdmFsdWUgYmFzZWQgb24gT3RzdSdzIG1ldGhvZCBpcyB1c2VkIHRvIHJlZHVjZSB0aGUgZ3JheXNjYWxlIGltYWdlIHRvIGEgYmluYXJ5IGltYWdlLiAgIElmIGEgbnVtZXJpYyB2YWx1ZSBpcyBpbmZvcm1lZCwgdGhpcyB2YWx1ZSB3aWxsIGJlIHVzZWQgYXMgYSB0aHJlc2hvbGQuIEluZm9ybSBhbnkgbm9uLW51bWVyaWMgdmFsdWUgZGlmZmVyZW50IHRoYW4gYCJPdHN1ImAgdG8gaXRlcmF0aXZlbHkgY2hvc2VuIHRoZSB0aHJlc2hvbGQgYmFzZWQgb24gYSByYXN0ZXIgcGxvdCBzaG93aW5nIHBpeGVsIGludGVuc2l0eSBvZiB0aGUgaW5kZXguIEZvciBgaW1hZ2Vfc2VnbWVudGF0aW9uX2l0ZXIoKWAsIGEgdmVjdG9yIChhbGxvd3MgYSBtaXhlZCAobnVtZXJpYyBhbmQgY2hhcmFjdGVyKSB0eXBlKSB3aXRoIHRoZSBzYW1lIGxlbmd0aCBvZiBgbnNlZ2AgY2FuIGJlIHVzZWQuDQoNCmBgYHtyIHNlZ21lbnRhdGlvbjksIGZpZy53aWR0aD0xMH0NCnNlZ19pdGVyMSA8LQ0KICBpbWFnZV9zZWdtZW50X2l0ZXIoc2VnX2l0ZXIsDQogICAgICAgICAgICAgICAgICAgICBuc2VnID0gMiwgIyB0d28gc2VnbWVudGF0aW9ucw0KICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBjKCJWQVJJIiwgIkdMSSIpLA0KICAgICAgICAgICAgICAgICAgICAgdGhyZXNob2xkID0gYygwLjMsICJPdHN1IiksDQogICAgICAgICAgICAgICAgICAgICBuY29sID0gMywNCiAgICAgICAgICAgICAgICAgICAgIHNob3dfaW1hZ2UgPSBGQUxTRSkNCnNlZ19pdGVyMiA8LQ0KICBpbWFnZV9zZWdtZW50X2l0ZXIoc2VnX2l0ZXIsDQogICAgICAgICAgICAgICAgICAgICBuc2VnID0gMiwgIyB0d28gc2VnbWVudGF0aW9ucw0KICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBjKCJWQVJJIiwgIkdMSSIpLA0KICAgICAgICAgICAgICAgICAgICAgdGhyZXNob2xkID0gYygwLjUsICJPdHN1IiksDQogICAgICAgICAgICAgICAgICAgICBuY29sID0gMywNCiAgICAgICAgICAgICAgICAgICAgIHNob3dfaW1hZ2UgPSBGQUxTRSkNCg0KaW1hZ2VfY29tYmluZShzZWdfaXRlcjEkaW1hZ2VzJHNlZzEsDQogICAgICAgICAgICAgIHNlZ19pdGVyMiRpbWFnZXMkc2VnMSkNCmBgYA0KDQpVc2VycyBjYW4gdGhlbiBzZXQgdGhlIGFyZ3VtZW50IGB0aHJlc2hvbGRgIGZvciB0aGVpciBzcGVjaWZpYyBjYXNlLCBkZXBlbmRpbmcgb24gdGhlIGFpbXMgb2YgdGhlIHNlZ21lbnRhdGlvbi4NCg0KDQoNCiMgUHJvZHVjaW5nIGEgYmluYXJ5IGltYWdlDQoNCldlIGNhbiBhbHNvIHByb2R1Y2UgYSBiaW5hcnkgaW1hZ2Ugd2l0aCBgaW1hZ2VfYmluYXJ5KClgLiBKdXN0IGZvciBjdXJpb3NpdHksIHdlIHdpbGwgdXNlIHRoZSBpbmRleGVzIGAiQiJgIChibHVlKSBhbmQgYCJOQiJgIChub3JtYWxpemVkIGJsdWUpLiBCeSBkZWZhdWx0LCBgaW1hZ2VfYmluYXJ5KClgIHJlc2NhbGVzIHRoZSBpbWFnZSB0byAzMCUgb2YgdGhlIHNpemUgb2YgdGhlIG9yaWdpbmFsIGltYWdlIHRvIHNwZWVkIHVwIHRoZSBjb21wdXRhdGlvbiB0aW1lLiBVc2UgdGhlIGFyZ3VtZW50IGByZXNpemUgPSBGQUxTRWAgdG8gcHJvZHVjZSBhIGJpbmFyeSBpbWFnZSB3aXRoIHRoZSBvcmlnaW5hbCBzaXplLg0KDQpgYGB7ciBiaW5hcnkxLCBmaWcud2lkdGg9MTAsIGZpZy5oZWlnaHQ9NX0NCmJpbmFyeSA8LSBpbWFnZV9iaW5hcnkoc295KQ0KDQojIG9yaWdpbmFsIGltYWdlIHNpemUNCmltYWdlX2JpbmFyeShzb3ksDQogICAgICAgICAgICAgaW5kZXggPSBjKCJCLCBOQiIpLA0KICAgICAgICAgICAgIHJlc2l6ZSA9IEZBTFNFKQ0KYGBgDQoNCg0KIyBDb3VudCBvYmplY3RzDQojIyBDaGVjayB0aGUgYmV0dGVyIGluZGV4IHRvIHNlZ21lbnQgdGhlIGltYWdlDQoNCiogQmx1ZSBiYWNrZ3JvdW5kDQoNCmBgYHtyIGZpZy53aWR0aD0xMCB9DQojIHdoZWF0IChOQikNCmRpcl93YiA8LSAiLi9kYXRhL2NvdW50X29iamVjdHMvaW1hZ2VzL2ltZ193Yl81MF8xLmpwZyINCndiIDwtIGltYWdlX2ltcG9ydChpbWFnZSA9IGRpcl93YikNCmltYWdlX2JpbmFyeSh3YikNCg0KDQojIHNveWJlYW4gKE5CKQ0KZGlyX3NiIDwtICIuL2RhdGEvY291bnRfb2JqZWN0cy9pbWFnZXMvaW1nX3NiXzUwXzEuanBnIg0Kc2IgPC0gaW1hZ2VfaW1wb3J0KGltYWdlID0gZGlyX3NiKQ0KaW1hZ2VfYmluYXJ5KHNiKQ0KDQojIGJlYW4gKE5SIHdpdGggaW52ZXJ0PSBUUlVFKQ0KZGlyX2JiIDwtICIuL2RhdGEvY291bnRfb2JqZWN0cy9pbWFnZXMvaW1nX2JiXzUwXzEuanBnIg0KYmIgPC0gaW1hZ2VfaW1wb3J0KGltYWdlID0gZGlyX2JiKQ0KaW1hZ2VfYmluYXJ5KGJiKQ0KDQpgYGANCg0KDQoNCg0KDQoNCmBgYHtyIGNvdW50X2ltZ3MsIGV2YWw9RkFMU0V9DQoNCiMjIyBTT1lCRUFODQoNCiMgbWlkLXJlc29sdXRpb24gaW1hZ2VzIChfNTApIGFuZCB3aXRoIG5vIGZpbHRlcmluZw0KdDEgPC0NCiAgc3lzdGVtLnRpbWUoDQogICAgc2JfcmVzXzUwX25mIDwtDQogICAgICBhbmFseXplX29iamVjdHMocGF0dGVybiA9ICJzYl81MCIsDQogICAgICAgICAgICAgICAgICAgICAgZGlyX29yaWdpbmFsID0gImRhdGEvY291bnRfb2JqZWN0cy9pbWFnZXMiLA0KICAgICAgICAgICAgICAgICAgICAgIHNob3dfaW1hZ2UgPSBGQUxTRSwNCiAgICAgICAgICAgICAgICAgICAgICBwYXJhbGxlbCA9IFRSVUUsDQogICAgICAgICAgICAgICAgICAgICAgdmVyYm9zZSA9IEZBTFNFKQ0KICApDQoNCiMgbWlkLXJlc29sdXRpb24gaW1hZ2VzIChfNTApIGFuZCB3aXRoIGZpbHRlcmluZw0KdDIgPC0NCiAgc3lzdGVtLnRpbWUoDQogICAgc2JfcmVzXzUwX3dmIDwtDQogICAgICBhbmFseXplX29iamVjdHMocGF0dGVybiA9ICJzYl81MCIsDQogICAgICAgICAgICAgICAgICAgICAgZGlyX29yaWdpbmFsID0gIi9kYXRhL2NvdW50X29iamVjdHMvaW1hZ2VzIiwNCiAgICAgICAgICAgICAgICAgICAgICBzaG93X2ltYWdlID0gRkFMU0UsDQogICAgICAgICAgICAgICAgICAgICAgcGFyYWxsZWwgPSBUUlVFLA0KICAgICAgICAgICAgICAgICAgICAgIGZpbHRlciA9IDIsDQogICAgICAgICAgICAgICAgICAgICAgdmVyYm9zZSA9IEZBTFNFKQ0KICApDQoNCiMgaGlnaC1yZXNvbHV0aW9uIGltYWdlcyAoXzEwMCkgYW5kIHdpdGggbm8gZmlsdGVyaW5nDQp0MyA8LQ0KICBzeXN0ZW0udGltZSgNCiAgICBzYl9yZXNfMTAwX25mIDwtDQogICAgICBhbmFseXplX29iamVjdHMocGF0dGVybiA9ICJzYl8xMDAiLA0KICAgICAgICAgICAgICAgICAgICAgIGRpcl9vcmlnaW5hbCA9ICIvZGF0YS9jb3VudF9vYmplY3RzL2ltYWdlcyIsDQogICAgICAgICAgICAgICAgICAgICAgc2hvd19pbWFnZSA9IEZBTFNFLA0KICAgICAgICAgICAgICAgICAgICAgIHBhcmFsbGVsID0gVFJVRSwNCiAgICAgICAgICAgICAgICAgICAgICB2ZXJib3NlID0gRkFMU0UpDQogICkNCg0KDQojIGxvdy1yZXNvbHV0aW9uIGltYWdlcyAoXzEwMCkgYW5kIHdpdGggZmlsdGVyaW5nDQp0NCA8LQ0KICBzeXN0ZW0udGltZSgNCiAgICBzYl9yZXNfMTAwX3dmIDwtDQogICAgICBhbmFseXplX29iamVjdHMocGF0dGVybiA9ICJzYl8xMDAiLA0KICAgICAgICAgICAgICAgICAgICAgIGRpcl9vcmlnaW5hbCA9ICIvZGF0YS9jb3VudF9vYmplY3RzL2ltYWdlcyIsDQogICAgICAgICAgICAgICAgICAgICAgc2hvd19pbWFnZSA9IEZBTFNFLA0KICAgICAgICAgICAgICAgICAgICAgIHBhcmFsbGVsID0gVFJVRSwNCiAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXIgPSAzLA0KICAgICAgICAgICAgICAgICAgICAgIHZlcmJvc2UgPSBGQUxTRSkNCiAgKQ0KDQoNCg0KDQoNCg0KDQoNCiMjIyBXSEVBVA0KDQojIG1pZC1yZXNvbHV0aW9uIGltYWdlcyAoXzUwKSBhbmQgd2l0aCBubyBmaWx0ZXJpbmcNCndiX3Jlc181MF9uZiA8LQ0KICBhbmFseXplX29iamVjdHMocGF0dGVybiA9ICJ3Yl81MCIsDQogICAgICAgICAgICAgICAgICBkaXJfb3JpZ2luYWwgPSAiL2RhdGEvY291bnRfb2JqZWN0cy9pbWFnZXMiLA0KICAgICAgICAgICAgICAgICAgc2hvd19pbWFnZSA9IEZBTFNFLA0KICAgICAgICAgICAgICAgICAgcGFyYWxsZWwgPSBUUlVFLA0KICAgICAgICAgICAgICAgICAgdmVyYm9zZSA9IEZBTFNFKQ0KDQojIG1pZC1yZXNvbHV0aW9uIGltYWdlcyAoXzUwKSBhbmQgd2l0aCBmaWx0ZXJpbmcNCndiX3Jlc181MF93ZiA8LQ0KICBhbmFseXplX29iamVjdHMocGF0dGVybiA9ICJ3Yl81MCIsDQogICAgICAgICAgICAgICAgICBkaXJfb3JpZ2luYWwgPSAiL2RhdGEvY291bnRfb2JqZWN0cy9pbWFnZXMiLA0KICAgICAgICAgICAgICAgICAgc2hvd19pbWFnZSA9IEZBTFNFLA0KICAgICAgICAgICAgICAgICAgcGFyYWxsZWwgPSBUUlVFLA0KICAgICAgICAgICAgICAgICAgZmlsdGVyID0gMiwNCiAgICAgICAgICAgICAgICAgIHZlcmJvc2UgPSBGQUxTRSkNCg0KIyBoaWdoLXJlc29sdXRpb24gaW1hZ2VzIChfMTAwKSBhbmQgd2l0aCBubyBmaWx0ZXJpbmcNCndiX3Jlc18xMDBfbmYgPC0NCiAgYW5hbHl6ZV9vYmplY3RzKHBhdHRlcm4gPSAid2JfMTAwIiwNCiAgICAgICAgICAgICAgICAgIGRpcl9vcmlnaW5hbCA9ICIvZGF0YS9jb3VudF9vYmplY3RzL2ltYWdlcyIsDQogICAgICAgICAgICAgICAgICBzaG93X2ltYWdlID0gRkFMU0UsDQogICAgICAgICAgICAgICAgICBwYXJhbGxlbCA9IFRSVUUsDQogICAgICAgICAgICAgICAgICB2ZXJib3NlID0gRkFMU0UpDQoNCg0KIyBsb3ctcmVzb2x1dGlvbiBpbWFnZXMgKF8xMDApIGFuZCB3aXRoIGZpbHRlcmluZw0Kd2JfcmVzXzEwMF93ZiA8LQ0KICBhbmFseXplX29iamVjdHMocGF0dGVybiA9ICJ3Yl8xMDAiLA0KICAgICAgICAgICAgICAgICAgZGlyX29yaWdpbmFsID0gIi9kYXRhL2NvdW50X29iamVjdHMvaW1hZ2VzIiwNCiAgICAgICAgICAgICAgICAgIHNob3dfaW1hZ2UgPSBGQUxTRSwNCiAgICAgICAgICAgICAgICAgIHBhcmFsbGVsID0gVFJVRSwNCiAgICAgICAgICAgICAgICAgIGZpbHRlciA9IDMsDQogICAgICAgICAgICAgICAgICB2ZXJib3NlID0gRkFMU0UpDQoNCg0KDQoNCg0KIyMjIEJFQU4NCg0KIyBtaWQtcmVzb2x1dGlvbiBpbWFnZXMgKF81MCkgYW5kIHdpdGggbm8gZmlsdGVyaW5nDQpiYl9yZXNfNTBfbmYgPC0NCiAgYW5hbHl6ZV9vYmplY3RzKHBhdHRlcm4gPSAiYmJfNTAiLA0KICAgICAgICAgICAgICAgICAgZGlyX29yaWdpbmFsID0gIi9kYXRhL2NvdW50X29iamVjdHMvaW1hZ2VzIiwNCiAgICAgICAgICAgICAgICAgIGluZGV4ID0gIk5SIiwNCiAgICAgICAgICAgICAgICAgIGludmVydCA9IFRSVUUsDQogICAgICAgICAgICAgICAgICBzaG93X2ltYWdlID0gRkFMU0UsDQogICAgICAgICAgICAgICAgICBwYXJhbGxlbCA9IFRSVUUsDQogICAgICAgICAgICAgICAgICB2ZXJib3NlID0gRkFMU0UpDQoNCiMgbWlkLXJlc29sdXRpb24gaW1hZ2VzIChfNTApIGFuZCB3aXRoIGZpbHRlcmluZw0KYmJfcmVzXzUwX3dmIDwtDQogIGFuYWx5emVfb2JqZWN0cyhwYXR0ZXJuID0gImJiXzUwIiwNCiAgICAgICAgICAgICAgICAgIGRpcl9vcmlnaW5hbCA9ICIvZGF0YS9jb3VudF9vYmplY3RzL2ltYWdlcyIsDQogICAgICAgICAgICAgICAgICBpbmRleCA9ICJOUiIsDQogICAgICAgICAgICAgICAgICBpbnZlcnQgPSBUUlVFLA0KICAgICAgICAgICAgICAgICAgc2hvd19pbWFnZSA9IEZBTFNFLA0KICAgICAgICAgICAgICAgICAgcGFyYWxsZWwgPSBUUlVFLA0KICAgICAgICAgICAgICAgICAgZmlsdGVyID0gMiwNCiAgICAgICAgICAgICAgICAgIHZlcmJvc2UgPSBGQUxTRSkNCg0KIyBoaWdoLXJlc29sdXRpb24gaW1hZ2VzIChfMTAwKSBhbmQgd2l0aCBubyBmaWx0ZXJpbmcNCmJiX3Jlc18xMDBfbmYgPC0NCiAgYW5hbHl6ZV9vYmplY3RzKHBhdHRlcm4gPSAiYmJfMTAwIiwNCiAgICAgICAgICAgICAgICAgIGRpcl9vcmlnaW5hbCA9ICIvZGF0YS9jb3VudF9vYmplY3RzL2ltYWdlcyIsDQogICAgICAgICAgICAgICAgICBpbmRleCA9ICJOUiIsDQogICAgICAgICAgICAgICAgICBpbnZlcnQgPSBUUlVFLA0KICAgICAgICAgICAgICAgICAgc2hvd19pbWFnZSA9IEZBTFNFLA0KICAgICAgICAgICAgICAgICAgcGFyYWxsZWwgPSBUUlVFLA0KICAgICAgICAgICAgICAgICAgdmVyYm9zZSA9IEZBTFNFKQ0KDQoNCiMgbG93LXJlc29sdXRpb24gaW1hZ2VzIChfMTAwKSBhbmQgd2l0aCBmaWx0ZXJpbmcNCmJiX3Jlc18xMDBfd2YgPC0NCiAgYW5hbHl6ZV9vYmplY3RzKHBhdHRlcm4gPSAiYmJfMTAwIiwNCiAgICAgICAgICAgICAgICAgIGRpcl9vcmlnaW5hbCA9ICIvZGF0YS9jb3VudF9vYmplY3RzL2ltYWdlcyIsDQogICAgICAgICAgICAgICAgICBpbmRleCA9ICJOUiIsDQogICAgICAgICAgICAgICAgICBpbnZlcnQgPSBUUlVFLA0KICAgICAgICAgICAgICAgICAgc2hvd19pbWFnZSA9IEZBTFNFLA0KICAgICAgICAgICAgICAgICAgcGFyYWxsZWwgPSBUUlVFLA0KICAgICAgICAgICAgICAgICAgZmlsdGVyID0gMywNCiAgICAgICAgICAgICAgICAgIHZlcmJvc2UgPSBGQUxTRSkNCg0KYGBgDQoNCg0KDQoqIHdoaXRlIGJhY2tncm91bmQNCg0KYGBge3IsIGZpZy53aWR0aD0xMH0NCg0KIyB3aGVhdCAoTkIpDQpkaXJfd3cgPC0gIi4vZGF0YS9jb3VudF9vYmplY3RzL2ltYWdlcy9pbWdfd3dfNTBfMS5qcGciDQp3dyA8LSBpbWFnZV9pbXBvcnQoaW1hZ2UgPSBkaXJfd3cpDQppbWFnZV9iaW5hcnkod3cpDQoNCiMgc295YmVhbiAoTkIpDQpkaXJfc3cgPC0gIi4vZGF0YS9jb3VudF9vYmplY3RzL2ltYWdlcy9pbWdfc3dfNTBfMS5qcGciDQpzdyA8LSBpbWFnZV9pbXBvcnQoaW1hZ2UgPSBkaXJfc3cpDQppbWFnZV9iaW5hcnkoc3cpDQoNCiMgYmVhbiAoRykNCmRpcl9idyA8LSAiLi9kYXRhL2NvdW50X29iamVjdHMvaW1hZ2VzL2ltZ19id181MF8xLmpwZyINCmJ3IDwtIGltYWdlX2ltcG9ydChpbWFnZSA9IGRpcl9idykNCmltYWdlX2JpbmFyeShidykNCg0KDQpgYGANCg0KDQoNCmBgYHtyIGV2YWw9RkFMU0V9DQojIyMgU09ZQkVBTg0KDQojIG1pZC1yZXNvbHV0aW9uIGltYWdlcyAoXzUwKSBhbmQgd2l0aCBubyBmaWx0ZXJpbmcNCnN3X3Jlc181MF9uZiA8LQ0KICBhbmFseXplX29iamVjdHMocGF0dGVybiA9ICJzd181MCIsDQogICAgICAgICAgICAgICAgICBkaXJfb3JpZ2luYWwgPSAiL2RhdGEvY291bnRfb2JqZWN0cy9pbWFnZXMiLA0KICAgICAgICAgICAgICAgICAgc2hvd19pbWFnZSA9IEZBTFNFLA0KICAgICAgICAgICAgICAgICAgcGFyYWxsZWwgPSBUUlVFLA0KICAgICAgICAgICAgICAgICAgdmVyYm9zZSA9IEZBTFNFKQ0KDQojIG1pZC1yZXNvbHV0aW9uIGltYWdlcyAoXzUwKSBhbmQgd2l0aCBmaWx0ZXJpbmcNCnN3X3Jlc181MF93ZiA8LQ0KICBhbmFseXplX29iamVjdHMocGF0dGVybiA9ICJzd181MCIsDQogICAgICAgICAgICAgICAgICBkaXJfb3JpZ2luYWwgPSAiL2RhdGEvY291bnRfb2JqZWN0cy9pbWFnZXMiLA0KICAgICAgICAgICAgICAgICAgc2hvd19pbWFnZSA9IEZBTFNFLA0KICAgICAgICAgICAgICAgICAgcGFyYWxsZWwgPSBUUlVFLA0KICAgICAgICAgICAgICAgICAgZmlsdGVyID0gMiwNCiAgICAgICAgICAgICAgICAgIHZlcmJvc2UgPSBGQUxTRSkNCnN3X3Jlc18xMDBfbmYgPC0NCiAgYW5hbHl6ZV9vYmplY3RzKHBhdHRlcm4gPSAic3dfMTAwIiwNCiAgICAgICAgICAgICAgICAgIGRpcl9vcmlnaW5hbCA9ICIvZGF0YS9jb3VudF9vYmplY3RzL2ltYWdlcyIsDQogICAgICAgICAgICAgICAgICBzaG93X2ltYWdlID0gRkFMU0UsDQogICAgICAgICAgICAgICAgICBwYXJhbGxlbCA9IFRSVUUsDQogICAgICAgICAgICAgICAgICB2ZXJib3NlID0gRkFMU0UpDQoNCg0KIyBsb3ctcmVzb2x1dGlvbiBpbWFnZXMgKF8xMDApIGFuZCB3aXRoIGZpbHRlcmluZw0Kc3dfcmVzXzEwMF93ZiA8LQ0KICBhbmFseXplX29iamVjdHMocGF0dGVybiA9ICJzd18xMDAiLA0KICAgICAgICAgICAgICAgICAgZGlyX29yaWdpbmFsID0gIi9kYXRhL2NvdW50X29iamVjdHMvaW1hZ2VzIiwNCiAgICAgICAgICAgICAgICAgIHNob3dfaW1hZ2UgPSBGQUxTRSwNCiAgICAgICAgICAgICAgICAgIHBhcmFsbGVsID0gVFJVRSwNCiAgICAgICAgICAgICAgICAgIGZpbHRlciA9IDMsDQogICAgICAgICAgICAgICAgICB2ZXJib3NlID0gRkFMU0UpDQoNCg0KDQoNCg0KDQojIyMgV0hFQVQNCg0KIyBtaWQtcmVzb2x1dGlvbiBpbWFnZXMgKF81MCkgYW5kIHdpdGggbm8gZmlsdGVyaW5nDQp3d19yZXNfNTBfbmYgPC0NCiAgYW5hbHl6ZV9vYmplY3RzKHBhdHRlcm4gPSAid3dfNTAiLA0KICAgICAgICAgICAgICAgICAgZGlyX29yaWdpbmFsID0gIi9kYXRhL2NvdW50X29iamVjdHMvaW1hZ2VzIiwNCiAgICAgICAgICAgICAgICAgIHNob3dfaW1hZ2UgPSBGQUxTRSwNCiAgICAgICAgICAgICAgICAgIHBhcmFsbGVsID0gVFJVRSwNCiAgICAgICAgICAgICAgICAgIHZlcmJvc2UgPSBGQUxTRSkNCg0KIyBtaWQtcmVzb2x1dGlvbiBpbWFnZXMgKF81MCkgYW5kIHdpdGggZmlsdGVyaW5nDQp3d19yZXNfNTBfd2YgPC0NCiAgYW5hbHl6ZV9vYmplY3RzKHBhdHRlcm4gPSAid3dfNTAiLA0KICAgICAgICAgICAgICAgICAgZGlyX29yaWdpbmFsID0gIi9kYXRhL2NvdW50X29iamVjdHMvaW1hZ2VzIiwNCiAgICAgICAgICAgICAgICAgIHNob3dfaW1hZ2UgPSBGQUxTRSwNCiAgICAgICAgICAgICAgICAgIHBhcmFsbGVsID0gVFJVRSwNCiAgICAgICAgICAgICAgICAgIGZpbHRlciA9IDIsDQogICAgICAgICAgICAgICAgICB2ZXJib3NlID0gRkFMU0UpDQoNCiMgaGlnaC1yZXNvbHV0aW9uIGltYWdlcyAoXzEwMCkgYW5kIHdpdGggbm8gZmlsdGVyaW5nDQp3d19yZXNfMTAwX25mIDwtDQogIGFuYWx5emVfb2JqZWN0cyhwYXR0ZXJuID0gInd3XzEwMCIsDQogICAgICAgICAgICAgICAgICBkaXJfb3JpZ2luYWwgPSAiL2RhdGEvY291bnRfb2JqZWN0cy9pbWFnZXMiLA0KICAgICAgICAgICAgICAgICAgc2hvd19pbWFnZSA9IEZBTFNFLA0KICAgICAgICAgICAgICAgICAgcGFyYWxsZWwgPSBUUlVFLA0KICAgICAgICAgICAgICAgICAgdmVyYm9zZSA9IEZBTFNFKQ0KDQoNCiMgbG93LXJlc29sdXRpb24gaW1hZ2VzIChfMTAwKSBhbmQgd2l0aCBmaWx0ZXJpbmcNCnd3X3Jlc18xMDBfd2YgPC0NCiAgYW5hbHl6ZV9vYmplY3RzKHBhdHRlcm4gPSAid3dfMTAwIiwNCiAgICAgICAgICAgICAgICAgIGRpcl9vcmlnaW5hbCA9ICIvZGF0YS9jb3VudF9vYmplY3RzL2ltYWdlcyIsDQogICAgICAgICAgICAgICAgICBzaG93X2ltYWdlID0gRkFMU0UsDQogICAgICAgICAgICAgICAgICBwYXJhbGxlbCA9IFRSVUUsDQogICAgICAgICAgICAgICAgICBmaWx0ZXIgPSAzLA0KICAgICAgICAgICAgICAgICAgdmVyYm9zZSA9IEZBTFNFKQ0KDQoNCg0KDQoNCiMjIyBCRUFODQoNCiMgbWlkLXJlc29sdXRpb24gaW1hZ2VzIChfNTApIGFuZCB3aXRoIG5vIGZpbHRlcmluZw0KYndfcmVzXzUwX25mIDwtDQogIGFuYWx5emVfb2JqZWN0cyhwYXR0ZXJuID0gImJ3XzUwIiwNCiAgICAgICAgICAgICAgICAgIGRpcl9vcmlnaW5hbCA9ICIvZGF0YS9jb3VudF9vYmplY3RzL2ltYWdlcyIsDQogICAgICAgICAgICAgICAgICBpbmRleCA9ICJHIiwNCiAgICAgICAgICAgICAgICAgIHNob3dfaW1hZ2UgPSBGQUxTRSwNCiAgICAgICAgICAgICAgICAgIHBhcmFsbGVsID0gVFJVRSwNCiAgICAgICAgICAgICAgICAgIHZlcmJvc2UgPSBGQUxTRSkNCg0KIyBtaWQtcmVzb2x1dGlvbiBpbWFnZXMgKF81MCkgYW5kIHdpdGggZmlsdGVyaW5nDQpid19yZXNfNTBfd2YgPC0NCiAgYW5hbHl6ZV9vYmplY3RzKHBhdHRlcm4gPSAiYndfNTAiLA0KICAgICAgICAgICAgICAgICAgZGlyX29yaWdpbmFsID0gIi9kYXRhL2NvdW50X29iamVjdHMvaW1hZ2VzIiwNCiAgICAgICAgICAgICAgICAgIGluZGV4ID0gIkciLA0KICAgICAgICAgICAgICAgICAgc2hvd19pbWFnZSA9IEZBTFNFLA0KICAgICAgICAgICAgICAgICAgcGFyYWxsZWwgPSBUUlVFLA0KICAgICAgICAgICAgICAgICAgZmlsdGVyID0gMiwNCiAgICAgICAgICAgICAgICAgIHZlcmJvc2UgPSBGQUxTRSkNCg0KIyBoaWdoLXJlc29sdXRpb24gaW1hZ2VzIChfMTAwKSBhbmQgd2l0aCBubyBmaWx0ZXJpbmcNCmJ3X3Jlc18xMDBfbmYgPC0NCiAgYW5hbHl6ZV9vYmplY3RzKHBhdHRlcm4gPSAiYndfMTAwIiwNCiAgICAgICAgICAgICAgICAgIGRpcl9vcmlnaW5hbCA9ICIvZGF0YS9jb3VudF9vYmplY3RzL2ltYWdlcyIsDQogICAgICAgICAgICAgICAgICBpbmRleCA9ICJHIiwNCiAgICAgICAgICAgICAgICAgIHNob3dfaW1hZ2UgPSBGQUxTRSwNCiAgICAgICAgICAgICAgICAgIHBhcmFsbGVsID0gVFJVRSwNCiAgICAgICAgICAgICAgICAgIHZlcmJvc2UgPSBGQUxTRSkNCg0KDQojIGxvdy1yZXNvbHV0aW9uIGltYWdlcyAoXzEwMCkgYW5kIHdpdGggZmlsdGVyaW5nDQpid19yZXNfMTAwX3dmIDwtDQogIGFuYWx5emVfb2JqZWN0cyhwYXR0ZXJuID0gImJ3XzEwMCIsDQogICAgICAgICAgICAgICAgICBkaXJfb3JpZ2luYWwgPSAiL2RhdGEvY291bnRfb2JqZWN0cy9pbWFnZXMiLA0KICAgICAgICAgICAgICAgICAgaW5kZXggPSAiRyIsDQogICAgICAgICAgICAgICAgICBzaG93X2ltYWdlID0gRkFMU0UsDQogICAgICAgICAgICAgICAgICBwYXJhbGxlbCA9IFRSVUUsDQogICAgICAgICAgICAgICAgICBmaWx0ZXIgPSAzLA0KICAgICAgICAgICAgICAgICAgdmVyYm9zZSA9IEZBTFNFKQ0KYGBgDQoNCg0KYGBge3IgZXZhbD1GQUxTRSwgaW5jbHVkZT1GQUxTRX0NCmRmcyA8LSBsaXN0KA0KICBzYl9yZXNfNTBfbmYgPSBzYl9yZXNfNTBfbmYsDQogIHNiX3Jlc181MF93ZiA9IHNiX3Jlc181MF93ZiwNCiAgc2JfcmVzXzEwMF9uZiA9IHNiX3Jlc18xMDBfbmYsDQogIHNiX3Jlc18xMDBfd2YgPSBzYl9yZXNfMTAwX3dmLA0KICANCiAgd2JfcmVzXzUwX25mID0gd2JfcmVzXzUwX25mLA0KICB3Yl9yZXNfNTBfd2YgPSB3Yl9yZXNfNTBfd2YsDQogIHdiX3Jlc18xMDBfbmYgPSB3Yl9yZXNfMTAwX25mLA0KICB3Yl9yZXNfMTAwX3dmID0gd2JfcmVzXzEwMF93ZiwNCiAgDQogIGJiX3Jlc181MF9uZiA9IGJiX3Jlc181MF9uZiwNCiAgYmJfcmVzXzUwX3dmID0gYmJfcmVzXzUwX3dmLA0KICBiYl9yZXNfMTAwX25mID0gYmJfcmVzXzEwMF9uZiwNCiAgYmJfcmVzXzEwMF93ZiA9IGJiX3Jlc18xMDBfd2YNCikNCg0KZGZzMiA8LSBsYXBwbHkoZGZzLCBmdW5jdGlvbih4KXsNCiAgeCRjb3VudA0KfSkNCm5hbWVzKGRmczIpIDwtIG5hbWVzKGRmcykNCg0KZGZzMyA8LSBtZXRhbjo6cmJpbmRfZmlsbF9pZChkZnMyLCAuaWQgPSAiZGZzIikNCg0KYmx1ZV9iYWNrIDwtDQogIGRmczMgJT4lDQogIHNlcGFyYXRlKGRmcyAgLCBpbnRvID0gYygiY3JvcCIsICJhYSIsICJyZXNvbHV0aW9uIiwgImZpbHRlciIpKSAlPiUNCiAgbXV0YXRlKHJlc29sdXRpb24gPSBpZmVsc2UocmVzb2x1dGlvbiA9PSA1MCwgIjgxNng2MTIiLCAiMTYzMngxMDI0IiksDQogICAgICAgICBmaWx0ZXIgPSBpZmVsc2UoZmlsdGVyID09ICJuZiIsICJXaXRob3V0IGZpbHRlciIsICJXaXRoIGZpbHRlciIpLA0KICAgICAgICAgY3JvcCA9IGNhc2Vfd2hlbihjcm9wID09ICJzYiIgfiAiU295YmVhbiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgIGNyb3AgPT0gIndiIiB+ICJXaGVhdCIsDQogICAgICAgICAgICAgICAgICAgICAgICAgIGNyb3AgPT0gImJiIiB+ICJCZWFuIiksDQogICAgICAgICBiYWNrZ3JvdW5kID0gIkJsdWUgYmFja2dyb3VuZCIpICU+JQ0KICBzZWxlY3QoLWFhKQ0KDQoNCg0KDQoNCmRmdyA8LSBsaXN0KA0KICBzd19yZXNfNTBfbmYgPSBzd19yZXNfNTBfbmYsDQogIHN3X3Jlc181MF93ZiA9IHN3X3Jlc181MF93ZiwNCiAgc3dfcmVzXzEwMF9uZiA9IHN3X3Jlc18xMDBfbmYsDQogIHN3X3Jlc18xMDBfd2YgPSBzd19yZXNfMTAwX3dmLA0KICANCiAgd3dfcmVzXzUwX25mID0gd3dfcmVzXzUwX25mLA0KICB3d19yZXNfNTBfd2YgPSB3d19yZXNfNTBfd2YsDQogIHd3X3Jlc18xMDBfbmYgPSB3d19yZXNfMTAwX25mLA0KICB3d19yZXNfMTAwX3dmID0gd3dfcmVzXzEwMF93ZiwNCiAgDQogIGJ3X3Jlc181MF9uZiA9IGJ3X3Jlc181MF9uZiwNCiAgYndfcmVzXzUwX3dmID0gYndfcmVzXzUwX3dmLA0KICBid19yZXNfMTAwX25mID0gYndfcmVzXzEwMF9uZiwNCiAgYndfcmVzXzEwMF93ZiA9IGJ3X3Jlc18xMDBfd2YNCikNCg0KZGZzMncgPC0gbGFwcGx5KGRmdywgZnVuY3Rpb24oeCl7DQogIHgkY291bnQNCn0pDQpuYW1lcyhkZnMydykgPC0gbmFtZXMoZGZ3KQ0KDQpkZnMzdyA8LSBtZXRhbjo6cmJpbmRfZmlsbF9pZChkZnMydywgLmlkID0gImRmcyIpDQoNCndoaXRlX2JhY2sgPC0NCiAgZGZzM3cgJT4lDQogIHNlcGFyYXRlKGRmcyAgLCBpbnRvID0gYygiY3JvcCIsICJhYSIsICJyZXNvbHV0aW9uIiwgImZpbHRlciIpKSAlPiUNCiAgbXV0YXRlKHJlc29sdXRpb24gPSBpZmVsc2UocmVzb2x1dGlvbiA9PSA1MCwgIjgxNng2MTIiLCAiMTYzMngxMDI0IiksDQogICAgICAgICBmaWx0ZXIgPSBpZmVsc2UoZmlsdGVyID09ICJuZiIsICJXaXRob3V0IGZpbHRlciIsICJXaXRoIGZpbHRlciIpLA0KICAgICAgICAgY3JvcCA9IGNhc2Vfd2hlbihjcm9wID09ICJzdyIgfiAiU295YmVhbiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgIGNyb3AgPT0gInd3IiB+ICJXaGVhdCIsDQogICAgICAgICAgICAgICAgICAgICAgICAgIGNyb3AgPT0gImJ3IiB+ICJCZWFuIiksDQogICAgICAgICBiYWNrZ3JvdW5kID0gIldoaXRlIGJhY2tncm91bmQiKSAlPiUNCiAgc2VsZWN0KC1hYSkNCg0KDQpjb3VudCA8LSBpbXBvcnQoImRhdGEvY291bnRfb2JqZWN0cy9jb3VudF9kYXRhLnhsc3giKQ0KZGZfZmluYWwgPC0gcmJpbmQod2hpdGVfYmFjaywgYmx1ZV9iYWNrKQ0KdmFsaWRhdGlvbiA8LSBjb3VudCAlPiUgbGVmdF9qb2luKGRmX2ZpbmFsKQ0KDQpgYGANCg0KDQoNCiMjIENvbmNvcmRhbmNlDQoNCmBgYHtyIGNvdW50MSwgZmlnLndpZHRoPTEwLCBmaWcuaGVpZ2h0PTh9DQoNCnZhbGlkYXRpb24gPC0gaW1wb3J0KCJkYXRhL2NvdW50X29iamVjdHMvY291bnRfZGF0YS54bHN4IikNCg0KIyMjIG92ZXJhbGwgY29uY29yZGFuY2UNCmdldF9jY2ModmFsaWRhdGlvbiwgcmVhbCwgcHJlZGljdGVkKQ0KIyMjIGNvbmNvcmRhbmNlIGJ5IHJlc29sdXRpb24sIGZpbHRlcmluZywgY3JvcCwgYmFja2dyb3VuZA0KZGZfY2NjIDwtDQogIHZhbGlkYXRpb24gJT4lDQogIGdyb3VwX2J5KGZpbHRlcikgJT4lDQogIGdldF9jY2MocmVhbCwgcHJlZGljdGVkKSAlPiUNCiAgbXV0YXRlKHJobyA9IHBhc3RlMCgicmhvW2NdOn4iLCByb3VuZChwYywgMykpLA0KICAgICAgICAgYmMgPSBwYXN0ZTAoIkNbYl06fiIsIHJvdW5kKGJjLCAzKSksDQogICAgICAgICByID0gcGFzdGUwKCJyOn5+fiIsIHJvdW5kKHIsIDMpKSkNCg0KDQpnZ3Bsb3QodmFsaWRhdGlvbiwgYWVzKHJlYWwsIHByZWRpY3RlZCkpKw0KICBnZW9tX2FibGluZShpbnRlcmNlcHQgPSAwICwgc2xvcGUgPSAxLCBsaW5ldHlwZSA9IDIpICsNCiAgZ2VvbV9wb2ludChhZXMoZmlsbCA9IGZhY3Rvcihjcm9wKSksDQogICAgICAgICAgICAgY29sb3IgPSAiYmxhY2siLA0KICAgICAgICAgICAgIHNoYXBlID0gMjEsDQogICAgICAgICAgICAgc2l6ZSA9IDIuNSwNCiAgICAgICAgICAgICBhbHBoYSA9IDAuNzUsDQogICAgICAgICAgICAgc3Ryb2tlID0gMC4wNSkgKw0KICBmYWNldF9uZXN0ZWQoZmlsdGVyKnJlc29sdXRpb24gfiBiYWNrZ3JvdW5kKmNyb3AgKSArDQogIGdlb21fdGV4dChhZXMobGFiZWw9cmhvKSwNCiAgICAgICAgICAgIHggPSA1LA0KICAgICAgICAgICAgeSA9IDEzNSwNCiAgICAgICAgICAgIGhqdXN0ID0gMCwNCiAgICAgICAgICAgIHNpemUgPSAzLA0KICAgICAgICAgICAgZGF0YSA9IGRmX2NjYywNCiAgICAgICAgICAgIHBhcnNlID0gVFJVRSkgKw0KICBsYWJzKHggPSAiQWN0dWFsIG51bWJlciBvZiBncmFpbnMiLA0KICAgICAgIHkgPSAiUHJlZGljdGVkIG51bWJlciBvZiBncmFpbnMiKSArDQogIG15X3RoZW1lKCkgKw0KICBjb29yZF9maXhlZCgpICsNCiAgc2NhbGVfeF9jb250aW51b3VzKGxpbWl0cyA9IGMoMCwgMTYwKSwNCiAgICAgICAgICAgICAgICAgICAgIGJyZWFrcyA9IHNlcSgwLCAxNjAsIGJ5ID0gNTApKSArDQogIHNjYWxlX3lfY29udGludW91cyhsaW1pdHMgPSBjKDAsIDE2MCksDQogICAgICAgICAgICAgICAgICAgICBicmVha3MgPSBzZXEoMCwgMTYwLCBieSA9IDUwKSkNCmdnc2F2ZSgiZmlncy9jb3VudF9vYmplY3RzLnBkZiIsIHdpZHRoID0gOSwgaGVpZ2h0ID0gNykNCmBgYA0KDQoNCiMjIFNvdXJjZSBvZiBlcnJvcnMNCkluIHRoZSBmb2xsb3dpbmcgcGxvdCwgdGhlIHF1YW50aWZpY2F0aW9uIG9mIHRoZSBpbWFnZSBgaW1nX2J3XzUwXzEuanBnYCAoYmVhbiB3aXRoIGJsdWUgYmFja2dyb3VuZCkgaXMgc2hvd24uIFdoZW4gbm8gZmlsdGVyaW5nIGlzIHVzZWQsIHNvbWUgcGl4ZWxzIHdpdGhpbiBncmFpbnMgYXJlIGNvbnNpZGVyZWQgYXMgYmFja2dyb3VuZCwgb3ZlcmVzdGltYXRpbmcgdGhlIG51bWJlciBvZiBncmFpbnMgd2hlbiBwcm9jZXNzaW5nIHRoZSBpbWFnZS4gVGhlIHVzZSBvZiBgZmlsdGVyID0gMmAgaW1wcm92ZWQgdGhlIGltYWdlIGJpbmFyaXphdGlvbiwgcHJvdmlkaW5nIGFuIGFjY3VyYWN5IG9mIDEuDQoNCmBgYHtyIGVycm9ycywgZmlnLndpZHRoPTEwfQ0KZXJyb3JzIDwtIGltYWdlX2ltcG9ydCgiZmlncy9iZWFuX2ZpbHRlci5wbmciLCBwbG90ID0gVFJVRSkNCmBgYA0KDQoNCiMjIEJlbmNobWFya2luZw0KDQpgYGB7ciBibSwgZXZhbD1GQUxTRX0NCnQxIDwtDQogIHN5c3RlbS50aW1lKA0KICAgIGEgPC0gDQogICAgICBhbmFseXplX29iamVjdHMocGF0dGVybiA9ICJfNTAiLA0KICAgICAgICAgICAgICAgICAgICAgIGRpcl9vcmlnaW5hbCA9ICJkYXRhL2NvdW50X29iamVjdHMvaW1hZ2VzIiwNCiAgICAgICAgICAgICAgICAgICAgICBzaG93X2ltYWdlID0gRkFMU0UsDQogICAgICAgICAgICAgICAgICAgICAgcGFyYWxsZWwgPSBUUlVFLA0KICAgICAgICAgICAgICAgICAgICAgIHZlcmJvc2UgPSBGQUxTRSkNCiAgKQ0KdDIgPC0NCiAgc3lzdGVtLnRpbWUoDQogICAgYW5hbHl6ZV9vYmplY3RzKHBhdHRlcm4gPSAiXzUwIiwNCiAgICAgICAgICAgICAgICAgICAgZGlyX29yaWdpbmFsID0gImRhdGEvY291bnRfb2JqZWN0cy9pbWFnZXMiLA0KICAgICAgICAgICAgICAgICAgICBzaG93X2ltYWdlID0gRkFMU0UsDQogICAgICAgICAgICAgICAgICAgIHBhcmFsbGVsID0gVFJVRSwNCiAgICAgICAgICAgICAgICAgICAgdmVyYm9zZSA9IEZBTFNFLA0KICAgICAgICAgICAgICAgICAgICBmaWx0ZXIgPSAyKQ0KICApDQp0MyA8LQ0KICBzeXN0ZW0udGltZSgNCiAgICBhIDwtICANCiAgICAgIGFuYWx5emVfb2JqZWN0cyhwYXR0ZXJuID0gIl8xMDAiLA0KICAgICAgICAgICAgICAgICAgICAgIGRpcl9vcmlnaW5hbCA9ICJkYXRhL2NvdW50X29iamVjdHMvaW1hZ2VzIiwNCiAgICAgICAgICAgICAgICAgICAgICBzaG93X2ltYWdlID0gRkFMU0UsDQogICAgICAgICAgICAgICAgICAgICAgcGFyYWxsZWwgPSBUUlVFLA0KICAgICAgICAgICAgICAgICAgICAgIHZlcmJvc2UgPSBGQUxTRSkNCiAgKQ0KdDQgPC0NCiAgc3lzdGVtLnRpbWUoDQogICAgYSA8LSAgDQogICAgICBhbmFseXplX29iamVjdHMocGF0dGVybiA9ICJfMTAwIiwNCiAgICAgICAgICAgICAgICAgICAgICBkaXJfb3JpZ2luYWwgPSAiZGF0YS9jb3VudF9vYmplY3RzL2ltYWdlcyIsDQogICAgICAgICAgICAgICAgICAgICAgc2hvd19pbWFnZSA9IEZBTFNFLA0KICAgICAgICAgICAgICAgICAgICAgIHBhcmFsbGVsID0gVFJVRSwNCiAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXIgPSAyLA0KICAgICAgICAgICAgICAgICAgICAgIHZlcmJvc2UgPSBGQUxTRSkNCiAgKQ0KdDUgPC0NCiAgc3lzdGVtLnRpbWUoDQogICAgYSA8LSANCiAgICAgIGFuYWx5emVfb2JqZWN0cyhwYXR0ZXJuID0gIl81MCIsDQogICAgICAgICAgICAgICAgICAgICAgZGlyX29yaWdpbmFsID0gImRhdGEvY291bnRfb2JqZWN0cy9pbWFnZXMiLA0KICAgICAgICAgICAgICAgICAgICAgIHNob3dfaW1hZ2UgPSBGQUxTRSwNCiAgICAgICAgICAgICAgICAgICAgICBwYXJhbGxlbCA9IEZBTFNFLA0KICAgICAgICAgICAgICAgICAgICAgIHZlcmJvc2UgPSBGQUxTRSkNCiAgKQ0KdDYgPC0NCiAgc3lzdGVtLnRpbWUoDQogICAgYSA8LSANCiAgICAgIGFuYWx5emVfb2JqZWN0cyhwYXR0ZXJuID0gIl81MCIsDQogICAgICAgICAgICAgICAgICAgICAgZGlyX29yaWdpbmFsID0gImRhdGEvY291bnRfb2JqZWN0cy9pbWFnZXMiLA0KICAgICAgICAgICAgICAgICAgICAgIHNob3dfaW1hZ2UgPSBGQUxTRSwNCiAgICAgICAgICAgICAgICAgICAgICBwYXJhbGxlbCA9IEZBTFNFLA0KICAgICAgICAgICAgICAgICAgICAgIGZpbHRlciA9IDIsDQogICAgICAgICAgICAgICAgICAgICAgdmVyYm9zZSA9IEZBTFNFKQ0KICApDQp0NyA8LQ0KICBzeXN0ZW0udGltZSgNCiAgICBhIDwtIA0KICAgICAgYW5hbHl6ZV9vYmplY3RzKHBhdHRlcm4gPSAiXzEwMCIsDQogICAgICAgICAgICAgICAgICAgICAgZGlyX29yaWdpbmFsID0gImRhdGEvY291bnRfb2JqZWN0cy9pbWFnZXMiLA0KICAgICAgICAgICAgICAgICAgICAgIHNob3dfaW1hZ2UgPSBGQUxTRSwNCiAgICAgICAgICAgICAgICAgICAgICBwYXJhbGxlbCA9IEZBTFNFLA0KICAgICAgICAgICAgICAgICAgICAgIHZlcmJvc2UgPSBGQUxTRSkNCiAgKQ0KdDggPC0NCiAgc3lzdGVtLnRpbWUoDQogICAgYSA8LSANCiAgICAgIGFuYWx5emVfb2JqZWN0cyhwYXR0ZXJuID0gIl8xMDAiLA0KICAgICAgICAgICAgICAgICAgICAgIGRpcl9vcmlnaW5hbCA9ICJkYXRhL2NvdW50X29iamVjdHMvaW1hZ2VzIiwNCiAgICAgICAgICAgICAgICAgICAgICBzaG93X2ltYWdlID0gRkFMU0UsDQogICAgICAgICAgICAgICAgICAgICAgcGFyYWxsZWwgPSBGQUxTRSwNCiAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXIgPSAyLA0KICAgICAgICAgICAgICAgICAgICAgIHZlcmJvc2UgPSBGQUxTRSkNCiAgKQ0KYGBgDQoNCmBgYHtyIGJlbmNobWFya2luZywgZmlnLndpZHRoPTEwfQ0KDQpiZW5jaCA8LSBpbXBvcnQoImRhdGEvY291bnRfb2JqZWN0cy90aW1lLnhsc3giKQ0KDQoNCmdncGxvdChiZW5jaCwgYWVzKGZpbHRlciwgYXZnLCBmaWxsID0gc3RyYXRlZ3kpKSArDQogIGdlb21fY29sKHBvc2l0aW9uID0gIHBvc2l0aW9uX2RvZGdlKHdpZHRoID0gMC45KSkgKw0KICBmYWNldF93cmFwKH5yZXNvbHV0aW9uKSArDQogIHNjYWxlX3lfY29udGludW91cyhleHBhbmQgPSBleHBhbnNpb24oYygwLjA1LCAwLjEpKSkgKw0KICBnZW9tX3RleHQoYWVzKGxhYmVsID0gcm91bmQoYXZnLCAyKSksDQogICAgICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uX2RvZGdlKHdpZHRoID0gMC45KSwNCiAgICAgICAgICAgIHZqdXN0ID0gLTAuNSwNCiAgICAgICAgICAgIGhqdXN0ID0gMC41LA0KICAgICAgICAgICAgc2l6ZSA9IDMpICsNCiAgbXlfdGhlbWUoKSArDQogIGxhYnMoeCA9ICJGaWx0ZXIiLA0KICAgICAgIHkgPSBleHByZXNzaW9uKFByb2Nlc3Npbmd+dGltZX4oc35pbWFnZV57LTF9KSkpDQpnZ3NhdmUoImZpZ3MvYmVuY2htYXJraW5nLnBkZiIsIHdpZHRoID0gNCwgaGVpZ2h0ID0gNCkNCmBgYA0KDQoNCg0KIyBMZWFmIGFyZWENCldlIGNhbiB1c2UgYGFuYWx5emVfb2JqZWN0cygpYCB0byBjb21wdXRlIG9iamVjdCBmZWF0dXJlcyBzdWNoIGFzIGFyZWEsIHBlcmltZXRlciwgcmFkaXVzLCBldGMuIFRoaXMgY2FuIGJlIHVzZWQsIGZvciBleGFtcGxlLCB0byBjb21wdXRlIGxlYWYgYXJlYS4NCkxldCdzIGNvbXB1dGUgdGhlIGxlYWYgYXJlYSBvZiBgbGVhdmVzYCB3aXRoIGBhbmFseXplX29iamVjdHMoKWAuIEZpcnN0LCB3ZSB1c2UgYGltYWdlX3NlZ21lbnRhdGlvbigpYCB0byBpZGVudGlmeSBjYW5kaWRhdGUgaW5kZXhlcyB0byBzZWdtZW50IGZvcmVncm91bmQgKGxlYXZlcykgZnJvbSBiYWNrZ3JvdW5kLg0KDQpgYGB7ciBsZWFmMywgZmlnLndpZHRoPTEwIH0NCmxlYXZlcyA8LSBpbWFnZV9pbXBvcnQoImRhdGEvbGVhZl9hcmVhL2xlYXZlczIuSlBHIiwgcGxvdCA9IFRSVUUpDQoNCg0KYGBgDQoNCmBgYHtyIGxlYWY0LCBmaWcud2lkdGg9OCwgZmlnLmhlaWdodD04fQ0KaW1hZ2Vfc2VnbWVudChsZWF2ZXMsIGluZGV4ID0gImFsbCIpDQpgYGANCg0KYEdgIChHcmVlbikgYW5kIGBOQmAgKE5vcm1hbGl6ZWQgQmx1ZSkgYXJlIHR3byBwb3NzaWJsZSBjYW5kaWRhdGVzIHRvIHNlZ21lbnQgdGhlIGxlYXZlcyBmcm9tIHRoZSBiYWNrZ3JvdW5kLiBXZSB3aWxsIHVzZSB0aGUgYE5CYCBpbmRleCBoZXJlIChkZWZhdWx0IG9wdGlvbiBpbiBgYW5hbHl6ZV9vYmplY3RzKClgKS4gVGhlIG1lYXN1cmVtZW50IG9mIHRoZSBsZWFmIGFyZWEgaW4gdGhpcyBhcHByb2FjaCBjYW4gYmUgZG9uZSBpbiB0d28gbWFpbiB3YXlzOiAxKSB1c2luZyBhbiBvYmplY3Qgb2Yga25vd24gYXJlYSwgYW5kIDIpIGtub3dpbmcgdGhlIGltYWdlIHJlc29sdXRpb24gaW4gZHBpIChkb3RzIHBlciBpbmNoKS4NCg0KDQojIyBVc2luZyBhbiBvYmplY3Qgb2Yga25vd24gYXJlYSB7I29iamVjdHNpemV9DQoNCi0gQ291bnQgdGhlIG51bWJlciBvZiBvYmplY3RzIChsZWF2ZXMgaW4gdGhpcyBjYXNlKQ0KDQpIZXJlLCB3ZSB1c2UgdGhlIGFyZ3VtZW50IGBtYXJrZXIgPSAiaWQiYCBvZiB0aGUgZnVuY3Rpb24gYGFuYWx5emVfb2JqZWN0cygpYCB0byBvYnRhaW4gdGhlIGlkZW50aWZpY2F0aW9uIG9mIGVhY2ggb2JqZWN0IChsZWFmKSwgYWxsb3dpbmcgZm9yIGZ1cnRoZXIgYWRqdXN0bWVudCBvZiB0aGUgbGVhZiBhcmVhLg0KDQpgYGB7ciBsZWFmNSwgZmlnLndpZHRoPTEwfQ0KY291bnQgPC0gYW5hbHl6ZV9vYmplY3RzKGxlYXZlcywgbWFya2VyID0gImlkIikNCg0KYGBgDQoNCk5vdGUgdGhhdCAiaG9sZXMiIGluIHNvbWUgbGVhdmVzIHJlc3VsdGVkIGluIHRoZSBzZWdtZW50YXRpb24gb2Ygb25lIGxlYWYgaW4gbW9yZSB0aGFuIG9uZSBvYmplY3QgKGUuZy4sIDUsIDgsIDIyLCAyNSwgMTgsIDI4KS4gVGhpcyB3aWxsIG5vdCBhZmZlY3QgdGhlIHRvdGFsIGxlYWYgYXJlYSwgYnV0IHRoZSBhcmVhIG9mIGluZGl2aWR1YWwgbGVhdmVzIGFuZCB0aGUgYXZlcmFnZSBsZWFmIGFyZWEuIFRoaXMgY2FuIGJlIHNvbHZlZCBieSBlaXRoZXIgc2V0dGluZyB0aGUgYXJndW1lbnQgYGZpbGxfaHVsbCA9IFRSVUVgIG9yIGB3YXRlcnNoZWQgPSBGQUxTRWAgKFRvIGRvbid0IGltcGxlbWVudCB0aGUgd2F0ZXJzaGVkLWJhc2VkIG9iamVjdCBzZWdtZW50YXRpb24pLiBMZXQncyBzZWUgaG93IG11Y2ggYmV0dGVyIHdlIGNhbiBnby4NCg0KYGBge3IgbGVhZjYsIGZpZy53aWR0aD0xMH0NCmNvdW50IDwtDQogIGFuYWx5emVfb2JqZWN0cyhsZWF2ZXMsDQogICAgICAgICAgICAgICAgICBtYXJrZXIgPSAiaWQiLA0KICAgICAgICAgICAgICAgICAgZmlsbF9odWxsID0gVFJVRSkNCg0KYGBgDQoNCkFsbW9zdCB0aGVyZSEgRHVlIHRvIHRoZSBtb3JwaG9sb2d5IG9mIHRoZSBsZWFmIGNvbXBvc2VkIGJ5IG9iamVjdHMgMiBhbmQgMjMsIGl0IHdhcyBzZWdtZW50ZWQgaW50byB0d28gb2JqZWN0cy4gVGhpcyBjYW4gYmUgc29sdmVkIGJ5IHNldHRpbmcgdGhlIGFyZ3VtZW50IGBvYmplY3Rfc2l6ZSA9ICJsYXJnZSJgIHRoYXQgd2lsbCBjaGFuZ2UgdGhlIGRlZmF1bHQgKG1lZGl1bSkgdmFsdWVzIGZvciBgdG9sZXJhbmNlYCBhbmQgYGV4dGVuc2lvbmAgYXJndW1lbnRzLg0KDQpgYGB7ciBsZWFmNywgZmlnLndpZHRoPTEwfQ0KY291bnQgPC0NCiAgYW5hbHl6ZV9vYmplY3RzKGxlYXZlcywNCiAgICAgICAgICAgICAgICAgIG1hcmtlciA9ICJpZCIsDQogICAgICAgICAgICAgICAgICBmaWxsX2h1bGwgPSBUUlVFLA0KICAgICAgICAgICAgICAgICAgb2JqZWN0X3NpemUgPSAibGFyZ2UiKQ0KDQpgYGANCg0KV2hlbiB0aGUgb2JqZWN0cyBhcmUgbm90IHRvdWNoaW5nIGVhY2ggb3RoZXIsIHRoZSBhcmd1bWVudCBgd2F0ZXJzaGVkID0gRkFMU0VgIHdvdWxkIGJlIGEgYmV0dGVyIG9wdGlvbi4NCg0KYGBge3IgbGVhZjgsIGZpZy53aWR0aD0xMH0NCmFuYWx5emVfb2JqZWN0cyhsZWF2ZXMsDQogICAgICAgICAgICAgICAgd2F0ZXJzaGVkID0gRkFMU0UpDQoNCmBgYA0KDQpBbmQgaGVyZSB3ZSBhcmUhIE5vdywgYWxsIGxlYXZlcyB3ZXJlIGlkZW50aWZpZWQgY29ycmVjdGx5LCBidXQgYWxsIG1lYXN1cmVzIHdlcmUgZ2l2ZW4gaW4gcGl4ZWwgdW5pdHMuIFRoZSBuZXh0IHN0ZXAgaXMgdG8gY29udmVydCB0aGVzZSBtZWFzdXJlcyB0byBtZXRyaWMgdW5pdHMuDQoNCg0KLSBDb252ZXJ0IHRoZSBsZWFmIGFyZWEgYnkgdGhlIGFyZWEgb2YgdGhlIGtub3duIG9iamVjdA0KDQpUaGUgZnVuY3Rpb24gYGdldF9tZWFzdXJlcygpYCBpcyB1c2VkIHRvIGFkanVzdCB0aGUgbGVhZiBhcmVhIHVzaW5nIG9iamVjdCAxMCwgYSBzcXVhcmUgd2l0aCBhIHNpZGUgb2YgNSBjbSAoMjUgY20kXjIkKS4NCg0KYGBge3IgbGVhZjksIGZpZy53aWR0aD0xMH0NCmFyZWEgPC0NCiAgZ2V0X21lYXN1cmVzKGNvdW50LA0KICAgICAgICAgICAgICAgaWQgPSAxMCwNCiAgICAgICAgICAgICAgIGFyZWEgfiAyNSkNCmFyZWENCiMgcGxvdCB0aGUgYXJlYSB0byB0aGUgc2VnbWVudGVkIGltYWdlDQppbWFnZV9zZWdtZW50KGxlYXZlcywgaW5kZXggPSAiTkIiLCB2ZXJib3NlID0gRkFMU0UpDQpwbG90X21lYXN1cmVzKGFyZWEsDQogICAgICAgICAgICAgIG1lYXN1cmUgPSAiYXJlYSIsDQogICAgICAgICAgICAgIGNvbCA9ICJyZWQiKSAjIGRlZmF1bHQgaXMgIndoaXRlIg0KDQoNCmBgYA0KDQoNCiMjIGtub3dpbmcgdGhlIGltYWdlIHJlc29sdXRpb24gaW4gZHBpIChkb3RzIHBlciBpbmNoKQ0KV2hlbiB0aGUgaW1hZ2UgcmVzb2x1dGlvbiBpcyBrbm93biwgdGhlIG1lYXN1cmVzIGluIHBpeGVscyBvYnRhaW5lZCB3aXRoIGBhbmFseXplX29iamVjdHMoKWAgYXJlIGNvcnJlY3RlZCBieSB0aGUgaW1hZ2UgcmVzb2x1dGlvbi4gVGhlIGZ1bmN0aW9uIGBkcGkoKWAgY2FuIGJlIHVzZWQgdG8gY29tcHV0ZSB0aGUgZHBpIG9mIGFuIGltYWdlLCBwcm92aWRlZCB0aGF0IHRoZSBzaXplIG9mIGFueSBvYmplY3QgaXMga25vd24uIFNlZSB0aGUgW2RwaV0oI2RwaSkgc2VjdGlvbiBmb3IgbW9yZSBkZXRhaWxzLiBJbiB0aGlzIGNhc2UsIHRoZSBlc3RpbWF0ZWQgcmVzb2x1dGlvbiBjb25zaWRlcmluZyB0aGUgY2FsaWJyYXRpb24gb2Ygb2JqZWN0IDEwIHdhcyB+NTAuOCBEUElzLiBXZSBpbmZvcm0gdGhpcyB2YWx1ZSBpbiB0aGUgYGRwaWAgYXJndW1lbnQgb2YgYGdldF9tZWFzdXJlczkpYC4NCg0KYGBge3IgbGVhZjEwfQ0KYXJlYTIgPC0gZ2V0X21lYXN1cmVzKGNvdW50LCBkcGkgPSA1MC44KQ0KIyBjb21wdXRlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHR3byBtZXRob2RzDQpzdW0oYXJlYSRhcmVhIC0gYXJlYTIkYXJlYSkNCmBgYA0KDQoNCg0KIyMgQ29tcGFyaW5nIGBwbGltYW5gIGFuZCBgTGVhZkFyZWFgDQoNCmBgYHtyIGxlYWYxMSwgZXZhbD1GQUxTRX0NCiMgRmluZCB0aGUgZXhhY3QgZGlzdGFuY2Ugb2YgODI2IHBpeGVscyBhdCAxMDAgZHBpDQojDQprZCA8LSBwaXhlbHNfdG9fY20oODI2LCAxMDApDQprZA0KDQojIGNoYW5nZSBhY2NvcmRpbmcgdG8geW91ciBQQw0KZGlyZWN0b3J5IDwtICJFOi9EZXNrdG9wL3BhcGVyX3BsaW1hbi9kYXRhL2xlYWZfYXJlYS9pbWFnZWoiDQpwYXRoX2ltZ2ogPC0gIkM6L1Byb2dyYW0gRmlsZXMvSW1hZ2VKIg0Kc3lzdGVtLnRpbWUoDQogIGxmYSA8LQ0KICAgIHJ1bi5paihwYXRoLmltYWdlaiA9IHBhdGhfaW1naiwNCiAgICAgICAgICAgc2V0LmRpcmVjdG9yeSA9IGRpcmVjdG9yeSwNCiAgICAgICAgICAga25vd24uZGlzdGFuY2UgPSAyMC45ODA0LCAjIHJ1bi5pZyBoYXMgMjEgYXMgZGVmYXVsdC4NCiAgICAgICAgICAgc2F2ZS5pbWFnZSA9IEZBTFNFLA0KICAgICAgICAgICB0cmltLnBpeGVsID0gMCkNCikNCg0KIyB0b3RhbCB0aW1lOiB+MTAuOSBzDQpgYGANCg0KDQpgYGB7ciBsZWFmMTIsIGV2YWw9VFJVRX0NCnN5c3RlbS50aW1lKA0KICBwbG0gPC0NCiAgICBhbmFseXplX29iamVjdHMocGF0dGVybiA9ICJpbWciLCAgICMgbmFtZSBwYXR0ZXJuDQogICAgICAgICAgICAgICAgICAgIHdhdGVyc2hlZCA9IEZBTFNFLCAgIyBkb24ndCB1c2Ugd2F0ZXJzaGVkIHNlZ21lbnRhdGlvbg0KICAgICAgICAgICAgICAgICAgICBpbmRleCA9ICJHIiwgICAgICAgICAgICMgaW5kZXggdG8gc2VnbWVudCBsZWFmIGFuZCBiYWNrZ3JvdW5kDQogICAgICAgICAgICAgICAgICAgIGRpcl9vcmlnaW5hbCA9ICJkYXRhL2xlYWZfYXJlYS9pbWFnZWoiLA0KICAgICAgICAgICAgICAgICAgICBzaG93X2ltYWdlID0gRkFMU0UsICAgICMgZG9uJ3Qgc2hvdyBpbWFnZSBhZnRlciBwcm9jZXNzaW5nDQogICAgICAgICAgICAgICAgICAgIHBhcmFsbGVsID0gVFJVRSwgICAgICAgIyBtdWx0aXBsZSBzZWN0aW9ucw0KICAgICAgICAgICAgICAgICAgICB2ZXJib3NlID0gRkFMU0UpDQopDQoNCiMgYWRqdXN0IHRoZSBtZWFzdXJlcyBjb25zaWRlcmluZyAxMDAgZHBpICh0aGUgc2FtZSBhcyBMZWFmQXJlYSkNCmFyZWEgPC0gZ2V0X21lYXN1cmVzKHBsbSwgZHBpID0gMTAwKQ0KYGBgDQoNCg0KYGBge3IgbGVhZjEzLCBmaWcud2lkdGg9MTB9DQpkZl9hcmVhIDwtIGltcG9ydCgiLi9kYXRhL2xlYWZfYXJlYS9sZWFmX2FyZWEueGxzeCIpDQpobHQgPC0gYygiaW1nOTAiLCAiaW1nODciLCAiaW1nMTA3IikNCmRmX2FyZWEgPC0NCiAgZGZfYXJlYSAlPiUNCiAgbXV0YXRlKHJlcyA9IHBsaW1hbiAtIGxlYWZfYXJlYSwNCiAgICAgICAgIGxhYmVsID0gaWZlbHNlKHNhbXBsZSAlaW4lIGhsdCwgc2FtcGxlLCBOQSkpDQoNCiMgY29tcHV0ZSB0aGUgTGluJ3MgY29uY29yZGFuY2UgY29ycmVsYXRpb24NCmRmX2NvciA8LSBkZl9hcmVhWzE6MTUwLF0NCmNjYyA8LQ0KICBkZl9jb3IgJT4lDQogIGdyb3VwX2J5KGJhY2tncm91bmQpICU+JQ0KICBnZXRfY2NjKGxlYWZfYXJlYSwgcGxpbWFuKSAlPiUNCiAgbXV0YXRlKHJobyA9IHBhc3RlMCgicmhvW2NdOn4iLCByb3VuZChwYywgNCksDQogICAgICAgICAgICAgICAgICAgICAgIlsoIixyb3VuZChsd3JfY2ksNCksICItIiwNCiAgICAgICAgICAgICAgICAgICAgICByb3VuZCh1cHJfY2ksNCksICIpXSIgKSkNCg0KIyBjcmVhdGUgdGhlIHBsb3QNCmdncGxvdChkZl9hcmVhLCBhZXMobGVhZl9hcmVhLCBwbGltYW4pKSArDQogIGdlb21fYWJsaW5lKGludGVyY2VwdCA9IDAsIHNsb3BlID0gMSwNCiAgICAgICAgICAgICAgbGluZXR5cGUgPSAyKSArDQogIGdlb21fcG9pbnQoYWVzKGZpbGwgPSBiYWNrZ3JvdW5kKSwNCiAgICAgICAgICAgICBzaGFwZSA9IDI1LA0KICAgICAgICAgICAgIHNpemUgPSAzLA0KICAgICAgICAgICAgIGFscGhhID0gMC42LA0KICAgICAgICAgICAgIGNvbG9yID0gImJsYWNrIiwNCiAgICAgICAgICAgICBzdHJva2UgPSAwLjA1LA0KICAgICAgICAgICAgIGRhdGEgPSBzdWJzZXQoZGZfYXJlYSwgc2FtcGxlICVpbiUgaGx0KSkgKw0KICBnZW9tX3BvaW50KGFlcyhmaWxsID0gYmFja2dyb3VuZCksDQogICAgICAgICAgICAgc2hhcGUgPSAyMSwNCiAgICAgICAgICAgICBzaXplID0gMywNCiAgICAgICAgICAgICBhbHBoYSA9IDAuNiwNCiAgICAgICAgICAgICBjb2xvciA9ICJibGFjayIsDQogICAgICAgICAgICAgc3Ryb2tlID0gMC4wNSwNCiAgICAgICAgICAgICBkYXRhID0gc3Vic2V0KGRmX2FyZWEsICFzYW1wbGUgJWluJSBobHQpKSArDQogIGdlb21fdGV4dF9yZXBlbChhZXMobGFiZWwgPSBsYWJlbCkpICsNCiAgZ2VvbV90ZXh0KGFlcyhsYWJlbD1yaG8sIGNvbG9yID0gYmFja2dyb3VuZCksDQogICAgICAgICAgICBzaG93LmxlZ2VuZCA9IEZBTFNFLA0KICAgICAgICAgICAgeCA9IGMoMTAsIDEwKSwNCiAgICAgICAgICAgIHkgPSBjKDI0MCwgMjYwKSwNCiAgICAgICAgICAgIGhqdXN0ID0gMCwNCiAgICAgICAgICAgIHNpemUgPSA0LA0KICAgICAgICAgICAgZGF0YSA9IGNjYywNCiAgICAgICAgICAgIHBhcnNlID0gVFJVRSkgKw0KICBzY2FsZV94X2NvbnRpbnVvdXMobGltaXRzID0gYygwLCAyNzUpLCBicmVha3MgPSBzZXEoMCwgMjc1LCBieSA9IDUwKSkgKw0KICBzY2FsZV95X2NvbnRpbnVvdXMobGltaXRzID0gYygwLCAyNzUpLCBicmVha3MgPSBzZXEoMCwgMjc1LCBieSA9IDUwKSkgKw0KICBsYWJzKHggPSAiTGVhZkFyZWEiLA0KICAgICAgIHkgPSAicGxpbWFuIikgKw0KICBteV90aGVtZSgpICsNCiAgY29vcmRfZml4ZWQoKQ0KDQpnZ3NhdmUoImZpZ3MvcGxpbWFuX2xlYWZhcmVhLnBkZiIsIHdpZHRoID0gNCwgaGVpZ2h0ID0gNCkNCmBgYA0KDQoNCiMjIFZhcmlhdGlvbnMgaW4gdGhlIGFyZ3VtZW50cyBvZiBgYW5hbHl6ZV9vYmplY3RzKClgDQoNCkhlcmUsIEkgc2hvdyBob3cgdG8gcHJvZHVjZSB0aGUgbWFza3Mgc2hvd24gaW4gRmlndXJlIDggb2YgdGhlIGFydGljbGUsIHVzaW5nIHRoZSBpbWFnZSBgaW1nOTBgIGFzIGFuIGV4YW1wbGUuDQoNCmBgYHtyIG1hc2tzfQ0KaW1nOTAgPC0gaW1hZ2VfaW1wb3J0KCJpbWc5MC5qcGciLA0KICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSAiZGF0YS9sZWFmX2FyZWEvaW1hZ2VqIiwNCiAgICAgICAgICAgICAgICAgICAgICBwbG90ID0gVFJVRSkNCg0KIyBwbGltYW4gMQ0KYW5hbHl6ZV9vYmplY3RzKGltZzkwLA0KICAgICAgICAgICAgICAgIGluZGV4ID0gIkciLCAgICAgICAgICAjIGluZGV4IHRvIHNlZ21lbnQgbGVhZiBhbmQgYmFja2dyb3VuZA0KICAgICAgICAgICAgICAgIGZpbGxfaHVsbCA9IFRSVUUsICAgICAjIGZpbGwgdGhlIGluanVyaWVkIGFyZWENCiAgICAgICAgICAgICAgICBzaG93X29yaWdpbmFsID0gRkFMU0UpIyBjcmVhdGUgYSBtYXNrIChub3Qgb3JpZ2luYWwgaW1hZ2UpDQoNCiMgcGxpbWFuIDINCmFuYWx5emVfb2JqZWN0cyhpbWc5MCwNCiAgICAgICAgICAgICAgICBpbmRleCA9ICJHIiwgICAgICAgICAgIyBpbmRleCB0byBzZWdtZW50IGxlYWYgYW5kIGJhY2tncm91bmQNCiAgICAgICAgICAgICAgICBmaWxsX2h1bGwgPSBGQUxTRSwgICAgIyBkb24ndCBmaWxsIHRoZSBpbmp1cmllZCBhcmVhIChkZWZhdWx0KQ0KICAgICAgICAgICAgICAgIHNob3dfb3JpZ2luYWwgPSBGQUxTRSkjIGNyZWF0ZSBhIG1hc2sgKG5vdCBvcmlnaW5hbCBpbWFnZSkNCg0KIyBwbGltYW4gMw0KYW5hbHl6ZV9vYmplY3RzKGltZzkwLA0KICAgICAgICAgICAgICAgIGluZGV4ID0gIkciLCAgICAgICAgICAgICAjIGluZGV4IHRvIHNlZ21lbnQgbGVhZiBhbmQgYmFja2dyb3VuZA0KICAgICAgICAgICAgICAgIGZpbGxfaHVsbCA9IEZBTFNFLCAgICAgICAjIGRvbid0IGZpbGwgdGhlIGluanVyaWVkIGFyZWEgKGRlZmF1bHQpDQogICAgICAgICAgICAgICAgc2hvd19jb250b3VyID0gRkFMU0UsICAgICMgZG9uJ3Qgc2hvdyBvYmplY3QgY29udG91cg0KICAgICAgICAgICAgICAgIHNob3dfb3JpZ2luYWwgPSBUUlVFLCAgICAjIHNob3cgb3JpZ2luYWwgb2JqZWN0DQogICAgICAgICAgICAgICAgY29sX2JhY2tncm91bmQgPSAiYmxhY2siKSMgYmxhY2sgYmFja2dyb3VuZA0KDQojIHBsaW1hbiA0DQphbmFseXplX29iamVjdHMoaW1nOTAsDQogICAgICAgICAgICAgICAgaW5kZXggPSAiRyIsICAgICAgICAgICAgICMgaW5kZXggdG8gc2VnbWVudCBsZWFmIGFuZCBiYWNrZ3JvdW5kDQogICAgICAgICAgICAgICAgZmlsbF9odWxsID0gRkFMU0UsICAgICAgICMgZG9uJ3QgZmlsbCB0aGUgaW5qdXJpZWQgYXJlYSAoZGVmYXVsdCkNCiAgICAgICAgICAgICAgICBzaG93X29yaWdpbmFsID0gRkFMU0UsICAgIyBzaG93IG9yaWdpbmFsIG9iamVjdA0KICAgICAgICAgICAgICAgIGNvbF9iYWNrZ3JvdW5kID0gImJsYWNrIiwjIGJsYWNrIGJhY2tncm91bmQNCiAgICAgICAgICAgICAgICBjb2xfZm9yZWdyb3VuZCA9ICJncmVlbiIpIyBncmVlbiBmb3JlZ3JvdW5kDQoNCmBgYA0KDQoNCg0KIyBMZWFmIHNoYXBlDQoNClRoZSBmdW5jdGlvbiBgYW5hbHl6ZV9vYmplY3RzKClgIGNvbXB1dGVzIGEgcmFuZ2Ugb2Ygb2JqZWN0IGZlYXR1cmVzIHRoYXQgY2FuIGJlIHVzZWQgdG8gc3R1ZHkgbGVhZiBzaGFwZS4gQXMgYSBtb3RpdmF0aW5nIGV4YW1wbGUsIEkgd2lsbCB1c2UgdGhlIGltYWdlIGBwb3RhdG9fbGVhdmVzLnBuZ2AsIHRoYXQgd2FzIGdhdGhlcmVkIGZyb20gR3VwdGEgZXQgYWwuICgyMDIwKV5bR3VwdGEsIFMuLCBSb3NlbnRoYWwsIEQuIE0uLCBTdGluY2hjb21iZSwgSi4gUi4sICYgQmF1Y29tLCBSLiBTLiAoMjAyMCkuIFRoZSByZW1hcmthYmxlIG1vcnBob2xvZ2ljYWwgZGl2ZXJzaXR5IG9mIGxlYWYgc2hhcGUgaW4gc3dlZXQgcG90YXRvICgqSXBvbW9lYSBiYXRhdGFzKik6IHRoZSBpbmZsdWVuY2Ugb2YgZ2VuZXRpY3MsIGVudmlyb25tZW50LCBhbmQgR8OXRS4gKk5ldyBQaHl0b2xvZ2lzdCosIDIyNSg1KSwgMjE4M+KAkzIxOTUuIGh0dHBzOi8vZG9pLm9yZy8xMC4xMTExL25waC4xNjI4Nl0NCg0KDQoNCmBgYHtyIHBvdGF0bywgZmlnLndpZHRoPTEwfQ0KcG90YXRvIDwtIGltYWdlX2ltcG9ydCgiZGF0YS9sZWFmX2FyZWEvcG90YXRvX2xlYXZlcy5wbmciLCBwbG90ID0gVFJVRSkNCnBvdF9tZWFzIDwtDQogIGFuYWx5emVfb2JqZWN0cyhwb3RhdG8sDQogICAgICAgICAgICAgICAgICB3YXRlcnNoZWQgPSBGQUxTRSwNCiAgICAgICAgICAgICAgICAgIG1hcmtlciA9ICJpZCIsDQogICAgICAgICAgICAgICAgICBzaG93X2NodWxsID0gVFJVRSkgIyBzaG93cyB0aGUgY29udmV4IGh1bGwNCnByaW50KHBvdF9tZWFzJHJlc3VsdHMpDQpgYGANCg0KVGhyZWUga2V5IG1lYXN1cmVzIChpbiBwaXhlbCB1bml0cykgYXJlOg0KDQoxLiBgYXJlYWAgdGhlIGFyZWEgb2YgdGhlIG9iamVjdC4NCjIuIGBhcmVhX2NoYCB0aGUgYXJlYSBvZiB0aGUgY29udmV4IGh1bGwuDQozLiBgcGVyaW1ldGVyYCB0aGUgcGVyaW1ldGVyIG9mIHRoZSBvYmplY3QuDQoNClVzaW5nIHRoZXNlIG1lYXN1cmVzLCBjaXJjdWxhcml0eSBhbmQgc29saWRpdHkgYXJlIGNvbXB1dGVkIGFzIHNob3duIGluIChHdXB0YSBldCBhbCwgMjAyMCkuDQoNCiQkIGNpcmN1bGFyaXR5ID0gNFxwaShhcmVhIC8gcGVyaW1ldGVyXjIpJCQNCg0KDQokJHNvbGlkaXR5ID0gYXJlYSAvIGFyZWFcX2NoJCQNCg0KQ2lyY3VsYXJpdHkgaXMgaW5mbHVlbmNlZCBieSBzZXJyYXRpb25zIGFuZCBsb2JpbmcuIFNvbGlkaXR5IGlzIHNlbnNpdGl2ZSB0byBsZWF2ZXMgd2l0aCBkZWVwIGxvYmVzLCBvciB3aXRoIGEgZGlzdGluY3QgcGV0aW9sZSwgYW5kIGNhbiBiZSB1c2VkIHRvIGRpc3Rpbmd1aXNoIGxlYXZlcyBsYWNraW5nIHN1Y2ggc3RydWN0dXJlcy4gVW5saWtlIGNpcmN1bGFyaXR5LCBpdCBpcyBub3QgdmVyeSBzZW5zaXRpdmUgdG8gc2VycmF0aW9ucyBhbmQgbWlub3IgbG9iaW5ncywgc2luY2UgdGhlIGNvbnZleCBodWxsIHJlbWFpbnMgbGFyZ2VseSB1bmFmZmVjdGVkLg0KDQoNCiMjIE9iamVjdCBjb250b3VyDQoNClVzZXJzIGNhbiBhbHNvIG9idGFpbiB0aGUgb2JqZWN0IGNvbnRvdXIgYW5kIGNvbnZleCBodWxsIGFzIGZvbGxvd3M6DQoNCmBgYHtyIGNvbnQsIGZpZy53aWR0aD0xMH0NCmNvbnQgPC0NCiAgb2JqZWN0X2NvbnRvdXIocG90YXRvLA0KICAgICAgICAgICAgICAgICB3YXRlcnNoZWQgPSBGQUxTRSwNCiAgICAgICAgICAgICAgICAgc2hvd19pbWFnZSA9IEZBTFNFKQ0KcGxvdChwb3RhdG8pDQpwbG90X2NvbnRvdXIoY29udCwgY29sID0gInJlZCIsIGx3ZCA9IDMpDQpgYGANCg0KIyMgQ29udmV4IGh1bGwNClRoZSBmdW5jdGlvbiBgb2JqZWN0X2NvbnRvdXIoKWAgcmV0dXJucyBhIGxpc3Qgd2l0aCB0aGUgY29vcmRpbmF0ZSBwb2ludHMgZm9yIGVhY2ggb2JqZWN0IGNvbnRvdXIgdGhhdCBjYW4gYmUgZnVydGhlciB1c2VkIHRvIG9idGFpbiB0aGUgY29udmV4IGh1bGwgd2l0aCBgY29udl9odWxsKClgLg0KDQpgYGB7ciBjb252LCBmaWcud2lkdGg9MTB9DQpjb252IDwtIGNvbnZfaHVsbChjb250KQ0KcGxvdChwb3RhdG8pDQpwbG90X2NvbnRvdXIoY29udiwgY29sID0gInJlZCIsIGx3ZCA9IDMpDQpgYGANCg0KDQojIyBBcmVhIG9mIHRoZSBjb252ZXggaHVsbA0KVGhlbiwgdGhlIGFyZWEgb2YgdGhlIGNvbnZleCBodWxsIGNhbiBiZSBvYnRhaW5lZCB3aXRoIGBwb2x5X2FyZWEoKWAuDQpgYGB7ciBwb2x5YXJlYX0NCihhcmVhIDwtIHBvbHlfYXJlYShjb252KSkNCmBgYA0KDQoNCiMjIExlYXZlcyBhcyBgZ2dwbG90MmAgcGxvdA0KDQpgYGB7ciBtYXNrcG9seSwgZmlnLndpZHRoPTEwLCBmaWcuaGVpZ2h0PTMuNX0NCiMgY3JlYXRlIGEgZGF0YSBmcmFtZSBmb3IgY29udG91ciBhbmQgY29udmV4IGh1bGwNCmRmX2NvbnQgPC0gYmluZF9yb3dzKGNvbnQsIC5pZCA9ICJvYmplY3QiKQ0KZGZfY29udiA8LSBiaW5kX3Jvd3MoY29udiwgLmlkID0gIm9iamVjdCIpDQoNCiMgY3JlYXRlIGEgcGxvdA0KZ2dwbG90KGRmX2NvbnQsIGFlcyhYMSwgWDIsIGdyb3VwID0gb2JqZWN0KSkgKw0KICBnZW9tX3BvbHlnb24oYWVzKGZpbGwgPSBvYmplY3QpKSArDQogIGdlb21fcG9seWdvbihkYXRhID0gZGZfY29udiwNCiAgICAgICAgICAgICAgIGFlcyh4LCB5LCBmaWxsID0gb2JqZWN0KSwNCiAgICAgICAgICAgICAgIGFscGhhID0gMC4zKSArDQogIHRoZW1lX3ZvaWQoKSArIA0KICB0aGVtZShsZWdlbmQucG9zaXRpb24gPSAiYm90dG9tIikNCg0KYGBgDQoNCg0KIyMgU2ltcGxlIGFuZCBjb21wb3VuZCBsZWF2ZXMNCg0KQSBzaW1wbGUgbGVhZiBibGFkZSBpcyB1bmRpdmlkZWQuIFRoZSBibGFkZSBvZiBhIGNvbXBvdW5kIGxlYWYgaXMgZGl2aWRlZCBpbnRvIHNldmVyYWwgbGVhZmxldHMuIEluIHRoZSBmb2xsb3dpbmcgZXhhbXBsZXMsIEkgd2lsbCBzaG93IGhvdyB0byBhbmFseXplIHNpbXBsZSBhbmQgY29tcG91bmQgbGVhdmVzIHdpdGggYGFuYWx5emVfb2JqZWN0cygpYCwgbWFpbmx5IGlmIHRoZSBnb2FsIGlzIHRvIG9idGFpbiB0aGUgbWVhc3VyZXMgZm9yIGVhY2ggbGVhZiAoZS5nLiwgbWVhbiBhcmVhKSwgd2hlcmUgdGhlIG51bWJlciBvZiBvYmplY3RzIChsZWF2ZXMpIHdpbGwgaW5mbHVlbmNlIHRoZSByZXN1bHRzLg0KDQpUaGUgZm9sbG93aW5nIGltYWdlcyBieSBbRGFuaWVsIFNhdWVyZXNzaWddKGh0dHBzOi8vd3d3LmZsb3Jlc3Rhb21icm9maWxhbWlzdGEuY29tLmJyL3NpZG9sLz9tZW51PWNvbnRhY3QpIHdlcmUgb2J0YWluZWQgZnJvbSB0aGUgWyIqU2lzdGVtYSBkZSBJZGVudGlmaWNhw6fDo28gRGVuZHJvbMOzZ2ljYSBPbmxpbmUgLSBGbG9yZXN0YSBPbWJyw7NmaWxhIE1pc3RhKiJdKGh0dHBzOi8vd3d3LmZsb3Jlc3Rhb21icm9maWxhbWlzdGEuY29tLmJyL3NpZG9sLz9tZW51PWdsb3NzYXJ5KSBhbmQgc2hvdyBleGFtcGxlcyBvZiBzaW1wbGUgYW5kIGNvbXBvdW5kIGxlYXZlcy4NCg0KYGBge3Igc2MxLCBmaWcud2lkdGg9MTB9DQppbWdzIDwtIA0KICBpbWFnZV9pbXBvcnQoYygic2ltcGxlLmpwZyIsICJjb21wb3VuZC5qcGciKSwNCiAgICAgICAgICAgICAgIHBhdGggPSAiZGF0YS9sZWFmX2FyZWEiLA0KICAgICAgICAgICAgICAgcGxvdCA9IFRSVUUpDQoNCmBgYA0KDQoNCiMjIyBTaW1wbGUgbGVhdmVzDQpBbmFseXppbmcgbm9uLXRvdWNoaW5nIHNpbXBsZSBsZWF2ZXMgaXMgZmFpcmx5IHNpbXBsZS4gV2UgYWxyZWFkeSBzYXcgdGhhdCB0aGUgbm9ybWFsaXplZCBibHVlIGluZGV4IHByb3ZpZGVzIHNhdGlzZmFjdG9yeSBvYmplY3Qgc2VnbWVudGF0aW9uIHVzaW5nIGltYWdlcyB3aXRoIGEgYmx1ZSBiYWNrZ3JvdW5kIGxpa2UgaW4gdGhpcyBjYXNlLiBTbywgdGhlIGRlZmF1bHQgb3B0aW9uIChgaW5kZXggPSAiTkIiYCkgaXMgdXNlZC4gVGhlIHNxdWFyZXMgaW4gdGhlIGJhY2tncm91bmQgaGF2ZSA0IGNtJF4yJC4gV2l0aCB0aGlzIGluZm9ybWF0aW9uLCBpdCBpcyBwb3NzaWJsZSB0byBvYnRhaW4gdGhlIGltYWdlIHJlc29sdXRpb24gd2l0aCBgZHBpKHNpbXBsZSlgLCB3aGljaCB3aWxsIGJlIHVzZWZ1bCB0byBhZGp1c3QgdGhlIG1lYXN1cmVzLiBJbiB0aGlzIGNhc2UsIHRoZSBlc3RpbWF0ZWQgZHBpIGlzIDQ4LjY1Lg0KDQpgYGB7ciBzYzJ9DQpzaW1wbGUgPC0gaW1ncyRzaW1wbGUuanBnDQpzYXJlYSA8LSBhbmFseXplX29iamVjdHMoc2ltcGxlLCBtYXJrZXIgPSAiaWQiKQ0KDQpgYGANCg0KTm90ZSB0aGF0IHdpdGggdGhlIGRlZmF1bHQgc2V0dGluZ3MsIHRoZSBzaW1wbGUgbGVhZiB3YXMgcGFydGl0aW9uZWQgaW50byBzbWFsbCwgc2VnbWVudGVkIGxlYXZlcy4gQXMgc2hvd24gaW4gW3NlY3Rpb24gOC4xXSgjb2JqZWN0c2l6ZSkgdGhpcyBjYW4gYmUgc29sdmVkIGJ5IGVpdGhlciB1c2luZyBgb2JqZWN0X3NpemUgPSAibGFyZ2UiYCBvciBgd2F0ZXJzaGVkID0gRkFMU0VgLCB0byBvbWl0IHRoZSB3YXRlcnNoZWQgc2VnbWVudGF0aW9uIGFsZ29yaXRobS4gVGhlIGxhc3QgaXMgdXNlZCBoZXJlLg0KDQoNCmBgYHtyIHNjM30NCnNhcmVhIDwtIA0KICBhbmFseXplX29iamVjdHMoc2ltcGxlLA0KICAgICAgICAgICAgICAgICAgd2F0ZXJzaGVkID0gRkFMU0UsDQogICAgICAgICAgICAgICAgICBtYXJrZXIgPSAiaWQiLA0KICAgICAgICAgICAgICAgICAgc2hvd19jaHVsbCA9IFRSVUUpDQpzYXJlYV9jb3IgPC0gZ2V0X21lYXN1cmVzKHNhcmVhLCBkcGkgPSA0OC42NSkNCnNhcmVhX2Nvcg0KYGBgDQoNCg0KIyMjIENvbXBvdW5kIGxlYXZlcw0KDQpGb3IgY29tcG91bmQgbGVhdmVzLCBpZiB0aGUgd2F0ZXJzaGVkIHNlZ21lbnRhdGlvbiBpcyB1c2VkLCBsZWFmbGV0cyB3aWxsIHByb2JhYmx5IGJlIGNvbnNpZGVyZWQgYXMgZGlmZmVyZW50IGxlYXZlcywgYXMgY2FuIGJlIHNlZW4gYmVsb3cuDQoNCmBgYHtyIHNjNH0NCmNvbXBvdW5kIDwtIGltZ3MkY29tcG91bmQuanBnDQpjYXJlYSA8LSANCiAgYW5hbHl6ZV9vYmplY3RzKGNvbXBvdW5kLA0KICAgICAgICAgICAgICAgICAgc2hvd19zZWdtZW50YXRpb24gPSBUUlVFLA0KICAgICAgICAgICAgICAgICAgc2hvd19jb250b3VyID0gRkFMU0UsDQogICAgICAgICAgICAgICAgICBtYXJrZXIgPSAiaWQiKQ0KYGBgDQoNClRoZXJlZm9yZSwgdXNpbmcgYHdhdGVyc2hlZCA9IEZBTFNFYCB3aWxsIHNvbHZlIHRoaXMgcHJvYmxlbSwgc2luY2UgYWxsIGxlYWZsZXRzIGNvbm5lY3RlZCBieSBhdCBsZWFzdCBvbmUgcGl4ZWwgd2lsbCBiZSBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIHNhbWUgbGVhZi4NCg0KYGBge3Igc2M1fQ0KY2FyZWEgPC0gDQogIGFuYWx5emVfb2JqZWN0cyhjb21wb3VuZCwNCiAgICAgICAgICAgICAgICAgIHdhdGVyc2hlZCA9IEZBTFNFLA0KICAgICAgICAgICAgICAgICAgc2hvd19zZWdtZW50YXRpb24gPSBUUlVFLA0KICAgICAgICAgICAgICAgICAgc2hvd19jb250b3VyID0gRkFMU0UsDQogICAgICAgICAgICAgICAgICBzaG93X2NodWxsID0gVFJVRSwNCiAgICAgICAgICAgICAgICAgIG1hcmtlciA9ICJpZCIpDQpjYXJlYV9jb3IgPC0gZ2V0X21lYXN1cmVzKGNhcmVhLCBkcGkgPSA0OS41KQ0KY2FyZWFfY29yDQpgYGANCg0KDQoNCg0KDQojIEdldCB0aGUgUkdCIHZhbHVlcyBmb3IgZWFjaCBvYmplY3QNCg0KVG8gb2J0YWluIHRoZSBSR0IgaW50ZW5zaXR5IG9mIGVhY2ggaW1hZ2Ugb2JqZWN0IHdlIHVzZSB0aGUgYXJndW1lbnQgYG9iamVjdF9yZ2IgPSBUUlVFYCBpbiB0aGUgZnVuY3Rpb24gYGFuYWx5emVfb2JqZWN0cygpYC4gSW4gdGhpcyBleGFtcGxlLA0KDQpgYGB7ciByZ2IxLCBmaWcud2lkdGggPSAxMCwgZmlnLmhlaWdodD0xMH0NCg0KaW1nIDwtIGltYWdlX2ltcG9ydCgiZGF0YS9vYmplY3RzX3JnYi90aGV0cmF6b2xpdW0uanBnIikNCg0KIyBpZGVudGlmeSB0aGUgaW5kZXggdGhhdCBiZXR0ZXIgc2VnbWVudHMgdGhlIGltYWdlDQphIDwtIGltYWdlX2JpbmFyeShpbWcsICJhbGwiKQ0KDQpgYGANCg0KDQpUaGUgaW5kZXggYEhVRTJgIHdhcyBjaG9zZW4gdG8gc2VnbWVudCB0aGUgZ3JhaW5zIGZyb20gdGhlIGJhY2tncm91bmQuIFRoZSBtZWFuIG9mIGJsdWUgdmFsdWVzIHdpbGwgYmUgY29tcHV0ZWQgYnkgZGVjbGFyaW5nIGBvYmplY3RfaW5kZXggPSAiQiJgLg0KDQpgYGB7ciByZ2IyLCBmaWcud2lkdGggPSAxMCwgZmlnLmhlaWdodD0xMH0NCmlkcyA8LQ0KICBhbmFseXplX29iamVjdHMoaW1nLA0KICAgICAgICAgICAgICAgICAgaW5kZXggPSAiSFVFMiIsDQogICAgICAgICAgICAgICAgICBvYmplY3RfaW5kZXggPSAiQiIsDQogICAgICAgICAgICAgICAgICBmaWxsX2h1bGwgPSBUUlVFLA0KICAgICAgICAgICAgICAgICAgbWFya2VyID0gImlkIiwNCiAgICAgICAgICAgICAgICAgIG1hcmtlcl9jb2wgPSAiYmxhY2siKQ0KDQpgYGANCg0KDQojIyBQbG90IHRoZSBpbmRleA0KSGVyZSwgSSB1c2UgYGltYWdlX3NlZ21lbnQoKWAgYW5kIGBwbG90X21lYXN1cmVzKClgIHRvIHBsb3QgdGhlIG1lYW4gb2YgYmx1ZSB2YWx1ZXMgZm9yIGVhY2ggb2JqZWN0Lg0KDQpgYGB7ciByZ2IzLCBmaWcud2lkdGggPSAxMCwgZmlnLmhlaWdodD04fQ0KaW1hZ2Vfc2VnbWVudChpbWcsDQogICAgICAgICAgICAgIGluZGV4ID0gIkhVRTIiLA0KICAgICAgICAgICAgICB2ZXJib3NlID0gRkFMU0UpDQpwbG90X21lYXN1cmVzKGlkcywNCiAgICAgICAgICAgICAgbWVhc3VyZSA9ICJpbmRleCIsICMgcGxvdCB0aGUgbWVhbiBvZiBibHVlIHZhbHVlcyBmb3IgZWFjaCBvYmplY3QNCiAgICAgICAgICAgICAgY29sID0gImJsYWNrIikNCmBgYA0KDQpJdCBzZWVtcyB0aGF0IGdyYWlucyB3aXRoIG1lYW4gYmx1ZSB2YWx1ZXMgaGlnaGVyIHRoYW4gMC4zIHByZXNlbnQgc29tZSBsZXZlbCBvZiBkYW1hZ2UuIFVzZXJzIGNhbiB0aGVuIHdvcmsgd2l0aCB0aGlzIGZlYXR1cmUgYW5kIGFkYXB0IGl0IHRvIHRoZWlyIGNhc2UuDQoNCmBgYHtyIHJnYjR9DQpsZW5ndGgod2hpY2goaWRzJHJlc3VsdHMkaW5kZXggPiAwLjMpKQ0KYGBgDQoNCg0KDQojIyBHZXR0aW5nIHRoZSBpZCBmb3IgZWFjaCBvYmplY3QNCktub3dpbmcgdGhlIG9iamVjdCBpZGVudGlmaWNhdGlvbiAoaWQpIGlzIHVzZWZ1bCwgZm9yIGV4YW1wbGUsIHdoZW4gY29ycmVjdGluZyB0aGUgb2JqZWN0cycgbWVhc3VyZXMgYnkgdGhlIG1lYXN1cmUgb2Ygc29tZSBvYmplY3QsIGUuZy4sIHdpdGggYGdldF9tZWFzdXJlcygpYC4gVG8gZ2V0IHRoZSBvYmplY3QgaWQsIHdlIHVzZSBgb2JqZWN0X2lkKClgLg0KDQoNCmBgYHtyIG9iamVjMX0NCmltZyA8LSBpbWFnZV9pbXBvcnQoaW1hZ2VfcGxpbWFuKCJsYV9sZWF2ZXMuanBnIikpDQpvYmplY3RfaWQoaW1nKQ0KDQpgYGANCg0KDQoNCiMjIEdldHRpbmcgdGhlIG9iamVjdCBjb29yZGluYXRlcw0KVXNlcnMgY2FuIGdldCB0aGUgY29vcmRpbmF0ZXMgZm9yIGFsbCBvciBkZXNpcmVkIG9iamVjdHMgd2l0aCBgb2JqZWN0X2Nvb3JkKClgLiBXaGVuIHRoZSBgaWRgIGFyZ3VtZW50IGlzIHNldCB0byBgTlVMTGAgKGRlZmF1bHQpLCBhIGJvdW5kaW5nIHJlY3RhbmdsZSBpcyBkcmF3biBpbmNsdWRpbmcgYWxsIHRoZSBvYmplY3RzLiBTZXQgYGlkID0gImFsbCJgIHRvIGNvbXB1dGUgdGhlIGNvb3JkaW5hdGVzIGZvciBhbGwgb2JqZWN0cyBpbiB0aGUgaW1hZ2UsIG9yIHVzZSBhIG51bWVyaWMgdmVjdG9yIHRvIGluZGljYXRlIHRoZSBvYmplY3RzIHRvIGNvbXB1dGUgdGhlIGNvb3JkaW5hdGVzDQoNCg0KYGBge3Igb2JqZWMyfQ0KIyBHZXQgdGhlIGNvb3JkaW5hdGVzIGZvciBhIGJvdW5kaW5nIHJlY3RhbmdsZSBhcm91bmQgYWxsIG9iamVjdHMNCm9iamVjdF9jb29yZChpbWcpDQoNCiMgR2V0IHRoZSBjb29yZGluYXRlcyBmb3IgYWxsIG9iamVjdHMNCm9iamVjdF9jb29yZChpbWcsIGlkID0gImFsbCIpDQoNCiMgR2V0IHRoZSBjb29yZGluYXRlcyBvZiBvYmplY3RzIDEgYW5kIDMNCm9iamVjdF9jb29yZChpbWcsIGlkID0gYygyLCAzKSkNCmBgYA0KDQoNCg0KIyMgSXNvbGF0aW5nIG9iamVjdHMNCg0KVG8gaXNvbGF0ZSBvYmplY3RzLCB0aGUgZnVuY3Rpb24gYG9iamVjdF9pc29sYXRlKClgIGlzIHVzZWQuIEluIHRoZSBmb2xsb3dpbmcgZXhhbXBsZSwgSSB3aWxsIGlzb2xhdGUgb2JqZWN0IDEgYW5kIHNldCBhbiBlZGdlIG9mIDEwIHBpeGVscyBhcm91bmQgdGhlIG9iamVjdC4NCg0KYGBge3Igb2JqZWMzfQ0KaWQxIDwtIG9iamVjdF9pc29sYXRlKGltZywgaWQgPSAxLCBlZGdlID0gMTApDQpwbG90KGlkMSkNCmBgYA0KDQoNCg0KDQojIFBoeXRvcGF0aG9tZXRyeQ0KIyMgU2luZ2xlIGltYWdlcw0KDQpgYGB7ciBkaXNlYXNlMSwgZmlnLndpZHRoPTEyLCBmaWcuaGVpZ2h0PTN9DQojIHNldCB0aGUgcGF0aCBkaXJlY3RvcnkNCnBhdGhfc295IDwtICJkYXRhL2Rpc2Vhc2Vfc2V2ZXJpdHkvc295YmVhbiINCiMgaW1wb3J0IGltYWdlcw0KaW1nIDwtIGltYWdlX2ltcG9ydCgibGVhZi5qcGciLCBwYXRoID0gcGF0aF9zb3kpDQpoZWFsdGh5IDwtIGltYWdlX2ltcG9ydCgiaGVhbHRoeS5qcGciLCBwYXRoID0gcGF0aF9zb3kpDQpzeW1wdG9tcyA8LSBpbWFnZV9pbXBvcnQoInN5bXB0LmpwZyIsIHBhdGggPSBwYXRoX3NveSkNCmJhY2tncm91bmQgPC0gaW1hZ2VfaW1wb3J0KCJiYWNrLmpwZyIsIHBhdGggPSBwYXRoX3NveSkNCmltYWdlX2NvbWJpbmUoaW1nLCBoZWFsdGh5LCBzeW1wdG9tcywgYmFja2dyb3VuZCwgbmNvbCA9IDQpDQoNCg0KYGBgDQoNCiMjIEltYWdlIHBhbGV0dGVzDQpTYW1wbGUgcGFsZXR0ZXMgY2FuIGJlIG1hZGUgYnkgc2ltcGx5IG1hbnVhbGx5IHNhbXBsaW5nIHNtYWxsIGFyZWFzIG9mIHJlcHJlc2VudGF0aXZlIGltYWdlcyBhbmQgcHJvZHVjaW5nIGEgY29tcG9zaXRlIGltYWdlIHRoYXQgd2lsbCByZXByZXNlbnQgZWFjaCBvZiB0aGUgZGVzaXJlZCBjbGFzc2VzIChiYWNrZ3JvdW5kLCBoZWFsdGh5LCBhbmQgc3ltcHRvbWF0aWMgdGlzc3VlcykuIEFub3RoZXIgd2F5IGlzIHRvIHVzZSB0aGUgYGltYWdlX3BhbGV0dGUoKWAgZnVuY3Rpb24gdG8gY3JlYXRlIHNhbXBsZSBjb2xvciBwYWxldHRlcw0KDQpgYGB7cn0NCnBhbHMgPC0gaW1hZ2VfcGFsZXR0ZShpbWcsIG5wYWwgPSA4KQ0KaW1hZ2VfY29tYmluZShwYWxzLCBuY29sID0gNCkNCmBgYA0KDQpgYGB7ciBkaXNlYXNlMiwgZmlnLndpZHRoPTEwLCBmaWcuaGVpZ2h0PTV9DQojIGRlZmF1bHQgc2V0dGluZ3MNCnJlcyA8LQ0KICBtZWFzdXJlX2Rpc2Vhc2UoaW1nID0gaW1nLA0KICAgICAgICAgICAgICAgICAgaW1nX2hlYWx0aHkgPSBoZWFsdGh5LA0KICAgICAgICAgICAgICAgICAgaW1nX3N5bXB0b21zID0gc3ltcHRvbXMsDQogICAgICAgICAgICAgICAgICBpbWdfYmFja2dyb3VuZCA9IGJhY2tncm91bmQsDQogICAgICAgICAgICAgICAgICBzYXZlX2ltYWdlID0gVFJVRSwNCiAgICAgICAgICAgICAgICAgIGRpcl9wcm9jZXNzZWQgPSAiZGF0YS9kaXNlYXNlX3NldmVyaXR5L3NveWJlYW5fcnVzdC9zaW5nbGUiKQ0KDQojIGNyZWF0ZSBhIHBlcnNvbmFsaXplZCBtYXNrDQptZWFzdXJlX2Rpc2Vhc2UoaW1nID0gaW1nLA0KICAgICAgICAgICAgICAgIGltZ19oZWFsdGh5ID0gaGVhbHRoeSwNCiAgICAgICAgICAgICAgICBpbWdfc3ltcHRvbXMgPSBzeW1wdG9tcywNCiAgICAgICAgICAgICAgICBpbWdfYmFja2dyb3VuZCA9IGJhY2tncm91bmQsDQogICAgICAgICAgICAgICAgc2F2ZV9pbWFnZSA9IFRSVUUsDQogICAgICAgICAgICAgICAgc2hvd19vcmlnaW5hbCA9IEZBTFNFLA0KICAgICAgICAgICAgICAgIGRpcl9wcm9jZXNzZWQgPSAiZGF0YS9kaXNlYXNlX3NldmVyaXR5L3NveWJlYW5fcnVzdC9zaW5nbGUyIikNCg0KIyBpbXBvcnQgZ2VuZXJhdGVkIG1hc2tzDQptYXNrIDwtIGltYWdlX2ltcG9ydCgiZGF0YS9kaXNlYXNlX3NldmVyaXR5L3NveWJlYW5fcnVzdC9zaW5nbGUvcHJvY19pbWcuanBnIikNCm1hc2syIDwtIGltYWdlX2ltcG9ydCgiZGF0YS9kaXNlYXNlX3NldmVyaXR5L3NveWJlYW5fcnVzdC9zaW5nbGUyL3Byb2NfaW1nLmpwZyIpDQoNCiMgY29tYmluZSB0aGUgbWFza3Mgd2l0aCB0aGUgb3JpZ2luYWwgaW1hZ2UNCmltYWdlX2NvbWJpbmUoaW1nLCBtYXNrLCBtYXNrMiwgbmNvbCA9IDMpDQoNCmBgYA0KDQoNCg0KIyMgVmFyaWF0aW9ucyBpbiBpbWFnZSBwYWxldHRlcw0KSW4gdGhlIGZvbGxvd2luZyBleGFtcGxlLCBJIHNob3cgYSBzZWNvbmQgZXhhbXBsZSB3aXRoIGEgdmFyaWF0aW9uIGluIHRoZSBjb2xvciBwYWxldHRlcywgd2hlcmUgb25seSB0aGUgbmVjcm90aWMgYXJlYSBpcyBhc3N1bWVkIHRvIGJlIHRoZSBkaXNlYXNlZCB0aXNzdWUuIFRoZXJlZm9yZSwgdGhlIHN5bXB0b21hdGljIGFyZWEgd2lsbCBiZSBzbWFsbGVyIHRoYW4gdGhlIHByZXZpb3VzIG9uZS4NCg0KYGBge3IgZGlzZWFzZTMsIGZpZy53aWR0aD0xMH0NCg0KIyBzZXQgdGhlIHBhdGggZGlyZWN0b3J5DQpwYXRoX3NveSA8LSAiZGF0YS9kaXNlYXNlX3NldmVyaXR5L3NveWJlYW4iDQojIGltcG9ydCBpbWFnZXMNCmhlYWx0aHkyIDwtIGltYWdlX2ltcG9ydCgiaGVhbHRoeTIuanBnIiwgcGF0aCA9IHBhdGhfc295KQ0Kc3ltcHRvbXMyIDwtIGltYWdlX2ltcG9ydCgic3ltcHQyLmpwZyIsIHBhdGggPSBwYXRoX3NveSkNCmJhY2tncm91bmQyIDwtIGltYWdlX2ltcG9ydCgiYmFjazIuanBnIiwgcGF0aCA9IHBhdGhfc295KQ0KaW1hZ2VfY29tYmluZShoZWFsdGh5Miwgc3ltcHRvbXMyLCBiYWNrZ3JvdW5kMiwgbmNvbCA9IDMpDQppbWcyIDwtIGltZw0KcmVzIDwtDQogIG1lYXN1cmVfZGlzZWFzZShpbWcgPSBpbWcyLA0KICAgICAgICAgICAgICAgICAgaW1nX2hlYWx0aHkgPSBoZWFsdGh5MiwNCiAgICAgICAgICAgICAgICAgIGltZ19zeW1wdG9tcyA9IHN5bXB0b21zMiwNCiAgICAgICAgICAgICAgICAgIGltZ19iYWNrZ3JvdW5kID0gYmFja2dyb3VuZDIsDQogICAgICAgICAgICAgICAgICBzaG93X2ltYWdlID0gVFJVRSwNCiAgICAgICAgICAgICAgICAgIGNvbnRvdXJfY29sID0gImJsYWNrIiwNCiAgICAgICAgICAgICAgICAgIHNhdmVfaW1hZ2UgPSBUUlVFLA0KICAgICAgICAgICAgICAgICAgcHJlZml4ID0gInByb2MyXyIsDQogICAgICAgICAgICAgICAgICBkaXJfcHJvY2Vzc2VkID0gImRhdGEvZGlzZWFzZV9zZXZlcml0eS9zb3liZWFuX3J1c3Qvc2luZ2xlIikNCnJlcyRzZXZlcml0eQ0KDQoNCmltZ3NfcGFsIDwtDQogIGltYWdlX2ltcG9ydChjKCJwcm9jX2ltZy5qcGciLCAicHJvYzJfaW1nLmpwZyIpLA0KICAgICAgICAgICAgICAgcGF0aCA9ICJkYXRhL2Rpc2Vhc2Vfc2V2ZXJpdHkvc295YmVhbl9ydXN0L3NpbmdsZSIpDQppbWFnZV9jb21iaW5lKGltZ3NfcGFsKQ0KYGBgDQoNCg0KIyMgQmF0Y2ggcHJvY2Vzc2luZw0KRmlmdHkgc295YmVhbiBsZWF2ZXMgYW5kIDE5IGJlYW4gbGVhdmVzIHByZXZpb3VzbHkgcHJvY2Vzc2VkIGluIEFQUyBBc3Nlc3Mgc29mdHdhcmUgd2VyZSB1c2VkLiBUaGUgc295YmVhbiBpbWFnZXMgd2VyZSByZXRyaWV2ZWQgZnJvbSBodHRwczovL29zZi5pby80aGJyNiwgYSBQbGFudCBEaXNlYXNlIFNldmVyaXR5IEFubm90YXRpb24gSW1hZ2UgRGF0YWJhc2UuIFRoYW5rcyB0byBbRW1lcnNvbiBNLiBEZWwgUG9udGVdKGh0dHBzOi8vb3NmLmlvL2piNnlkLykgYW5kIGhpcyBjb2xsYWJvcmF0b3JzIGZvciBrZWVwaW5nIHRoaXMgaW1wb3J0YW50IHByb2plY3QgcHVibGljbHkgYXZhaWxhYmxlLg0KDQojIyMgU295YmVhbiBydXN0DQojIyMjIFVzaW5nIHNhbXBsZSBwYWxldHRlcw0KKiBTb3liZWFuIGxlYXZlcyB0byBiZSBwcm9jZXNzZWQNCmBgYHtyIGJhdGNoLCBmaWcud2lkdGg9MTAsIGZpZy5oZWlnaHQ9MjB9DQojIGltYWdlIGRpcmVjdG9yeQ0KcGF0aF9zb3kgPC0gIkU6L0Rlc2t0b3AvcGFwZXJfcGxpbWFuL2RhdGEvZGlzZWFzZV9zZXZlcml0eS9zb3liZWFuX3J1c3QiDQpzb3lfbGVhdmVzIDwtIGltYWdlX2ltcG9ydChwYXR0ZXJuID0gInNveSIsIHBhdGggPSBwYXRoX3NveSkNCmltYWdlX2NvbWJpbmUoc295X2xlYXZlcywgbmNvbCA9IDUpDQpgYGANCg0KDQoqIEltYWdlIHBhbGV0dGVzIHdpdGggdGhlIGRpZmZlcmVudCBwaXhlbCBjbGFzc2VzDQoNCmBgYHtyIGJhdGNoMX0NCiMgaW1hZ2UgZGlyZWN0b3J5DQpwYXRoX3NveSA8LSAiRTovRGVza3RvcC9wYXBlcl9wbGltYW4vZGF0YS9kaXNlYXNlX3NldmVyaXR5L3NveWJlYW5fcnVzdCINCnNveV9wYWxldHRlcyA8LQ0KICBpbWFnZV9pbXBvcnQoaW1hZ2UgPSBjKCJiYWNrLnBuZyIsICJkaXNlYXNlLnBuZyIsICJoZWFsdGgucG5nIiksDQogICAgICAgICAgICAgICBwYXRoID0gcGF0aF9zb3kpDQppbWFnZV9jb21iaW5lKHNveV9wYWxldHRlcywgbmNvbCA9IDMpDQpgYGANCg0KDQoNCmBgYHtyIGJhdGNoMn0NCnN5c3RlbS50aW1lKA0KICBzb3lfcnVzdCA8LQ0KICAgIG1lYXN1cmVfZGlzZWFzZShwYXR0ZXJuID0gInNveV8iLA0KICAgICAgICAgICAgICAgICAgICBpbWdfc3ltcHRvbXMgPSAiZGlzZWFzZSIsDQogICAgICAgICAgICAgICAgICAgIGltZ19oZWFsdGh5ID0gImhlYWx0aCIsDQogICAgICAgICAgICAgICAgICAgIGltZ19iYWNrZ3JvdW5kID0gImJhY2siLA0KICAgICAgICAgICAgICAgICAgICBkaXJfb3JpZ2luYWwgPSAiZGF0YS9kaXNlYXNlX3NldmVyaXR5L3NveWJlYW5fcnVzdCIsDQogICAgICAgICAgICAgICAgICAgIGRpcl9wcm9jZXNzZWQgPSAiZGF0YS9kaXNlYXNlX3NldmVyaXR5L3NveWJlYW5fcnVzdC9wcm9jZXNzZWQiLA0KICAgICAgICAgICAgICAgICAgICBzaG93X2NvbnRvdXIgPSBGQUxTRSwNCiAgICAgICAgICAgICAgICAgICAgcGFyYWxsZWwgPSBUUlVFKQ0KKQ0Kc295X3J1c3Qkc2V2ZXJpdHkNCmBgYA0KDQoNCg0KYGBge3IgYmF0Y2gzLCBmaWcud2lkdGg9MTAsIGZpZy5oZWlnaHQ9MjB9DQojIGltYWdlIGRpcmVjdG9yeQ0KcGF0aF9zb3lfcHJvYyA8LSAiRTovRGVza3RvcC9wYXBlcl9wbGltYW4vZGF0YS9kaXNlYXNlX3NldmVyaXR5L3NveWJlYW5fcnVzdC9wcm9jZXNzZWQiDQpzb3lfcHJvYyA8LSBpbWFnZV9pbXBvcnQocGF0dGVybiA9ICJwcm9jIiwgcGF0aCA9IHBhdGhfc295X3Byb2MpDQppbWFnZV9jb21iaW5lKHNveV9wcm9jLCBuY29sID0gNSkNCg0KYGBgDQoNCg0KDQoNCiMjIyMgVXNpbmcgYW4gUkdCLWJhc2VkIGluZGV4DQpBbm90aGVyIHdheSB0byBjb21wdXRlIHRoZSBkaWFzZWQgYXJlYSBpcyBieSB1c2luZyBhbiBSR0ItYmFzZWQgcGhlbm90eXBpbmdeW2h0dHBzOi8vbGluay5zcHJpbmdlci5jb20vYXJ0aWNsZS8xMC4xMDA3L3M0MDg1OC0wMjEtMDA0NDgteV0uIFRoZSBmaXJzdCBzdGVwIGlzIHRvIGZpbmQgYSBzdWl0YWJsZSBpbmRleCBmb3IgZGlzZWFzZSBzZWdtZW50YXRpb24uDQpgYGB7ciBmaWcud2lkdGg9MTAsIGZpZy5oZWlnaHQ9MTB9DQppbWcgPC0gaW1hZ2VfaW1wb3J0KCJzb3lfMS5qcGciLCBwYXRoID0gcGF0aF9zb3ksIHBsb3QgPSBUUlVFKQ0KDQojIGZpbmQgYSBzdWl0YWJsZSBpbmRleCB0byBzZWdtZW50IGRpc2Vhc2UgYW5kIGhlYWx0aHkgdGlzc3Vlcw0KaW1hZ2Vfc2VnbWVudChpbWcsIGluZGV4ID0gImFsbCIpDQoNCmBgYA0KDQpUaGUgTkdSREkgKE5vcm1hbGl6ZWQgZ3JlZW4gcmVkIGRpZmZlcmVuY2UgaW5kZXgpIGNvbXB1dGVkIGFzICRHLVIvRytSJCBzZWVtcyB0byBzZWdtZW50IGxlc2lvbnMgZnJvbSBoZWFsdGh5IGFyZWFzIHNhdGlzZmFjdG9yaWx5LiBOZXh0LCBJIGBwbG90KClgIHRoZSBvdXRwdXQgb2YgYGltYWdlX2luZGV4KClgIHRvIGZpbmQgYSBzdWl0YWJsZSB0aHJlc2hvbGQuDQoNCg0KYGBge3J9DQojIEZpbmQgYSB0aHJlc2hvbGQNCmltZ19pbmQgPC0gaW1hZ2VfaW5kZXgoaW1nLCBpbmRleCA9ICJOR1JESSIsIHNob3dfaW1hZ2UgPSBGQUxTRSkNCnBsb3QoaW1nX2luZCkNCmBgYA0KDQpBIHRocmVzaG9sZCBvZiBgMGAgaGFzIGJlZW4gY2hvc2VuLiBTbywgdGhlIG5leHQgc3RlcCBpcyB0byB1c2UgdGhlIGZ1bmN0aW9uIGBtZWFzdXJlX2Rpc2Vhc2UoKWAgbm93LiBJbiB0aGlzIGFwcHJvYWNoLCBjb2xvciBwYWxldHRlcyBhcmUgbm90IGluZm9ybWVkLiBJbnN0ZWFkLCB0aGUgdXNlciBuZWVkcyB0byBkZWNsYXJlIHR3byBvdGhlciBhcmd1bWVudHM6IGBpbmRleF9sYmAgdG8gc2VnbWVudCBsZWFmIGZyb20gdGhlIGJhY2tncm91bmQgYW5kIGBpbmRleF9kaGAgdG8gc2VnbWVudCBkaXNlYXNlZCBmcm9tIGhlYWx0aHkgdGlzc3Vlcy4NCg0KDQpgYGB7cn0NCnN5c3RlbS50aW1lKA0KICBzb3lfcnVzdDIgPC0NCiAgICBtZWFzdXJlX2Rpc2Vhc2UocGF0dGVybiA9ICJzb3lfIiwNCiAgICAgICAgICAgICAgICAgICAgaW5kZXhfbGIgPSAiRyIsICMgc2VnbWVudCBsZWFmIGZyb20gYmFja2dyb3VuZA0KICAgICAgICAgICAgICAgICAgICBpbmRleF9kaCA9ICJOR1JESSIsICMgc2VnbWVudCBkaXNlYXNlZCBmcm9tIGhlYWx0aHkgdGlzc3Vlcw0KICAgICAgICAgICAgICAgICAgICB0aHJlc2hvbGQgPSAwLA0KICAgICAgICAgICAgICAgICAgICBkaXJfb3JpZ2luYWwgPSAiZGF0YS9kaXNlYXNlX3NldmVyaXR5L3NveWJlYW5fcnVzdCIsDQogICAgICAgICAgICAgICAgICAgIHNob3dfaW1hZ2UgPSBGQUxTRSwNCiAgICAgICAgICAgICAgICAgICAgcGFyYWxsZWwgPSBUUlVFKQ0KKQ0KDQpgYGANCg0KDQpgYGB7ciBldmFsPUZBTFNFLCBlY2hvPUZBTFNFfQ0KZGZfcGFsIDwtDQogIHNveV9ydXN0JHNldmVyaXR5ICU+JQ0KICBzZWxlY3QoLWhlYWx0aHkpICU+JQ0KICByZW5hbWUocGFsZXR0ZXMgPSBzeW1wdG9tYXRpYykNCmRmX3JnYiA8LQ0KICBzb3lfcnVzdDIkc2V2ZXJpdHkgJT4lDQogIHNlbGVjdCgtaGVhbHRoeSkgJT4lDQogIHJlbmFtZShyZ2IgPSBzeW1wdG9tYXRpYykNCg0KZGZfc295IDwtDQogIGxlZnRfam9pbihkZl9wYWwsIGRmX3JnYikgJT4lDQogIG11dGF0ZShkaXNlYXNlID0gIlNveWJlYW4gcnVzdCIpDQpgYGANCg0KDQoNCg0KDQojIyMgQmVhbiBhbmd1bGFyIHNwb3QNCiMjIyMgVXNpbmcgc2FtcGxlIHBhbGV0dGVzDQpgYGB7ciBiYXRjaDQsIGZpZy53aWR0aD0xMCwgZmlnLmhlaWdodD0xMH0NCiMgaW1hZ2UgZGlyZWN0b3J5DQpwYXRoX2JlYW4gPC0gIkU6L0Rlc2t0b3AvcGFwZXJfcGxpbWFuL2RhdGEvZGlzZWFzZV9zZXZlcml0eS9iZWFuX3Nwb3QiDQpiZWFuX2xlYXZlcyA8LSBpbWFnZV9pbXBvcnQocGF0dGVybiA9ICJiZWFuIiwgcGF0aCA9IHBhdGhfYmVhbikNCmltYWdlX2NvbWJpbmUoYmVhbl9sZWF2ZXMsIG5jb2wgPSA1KQ0KDQpgYGANCg0KDQoNCg0KYGBge3IgYmF0Y2g1fQ0Kc3lzdGVtLnRpbWUoDQogIGJlYW5fc3BvdCA8LQ0KICAgIG1lYXN1cmVfZGlzZWFzZShwYXR0ZXJuID0gImJlYW4iLA0KICAgICAgICAgICAgICAgICAgICBpbWdfc3ltcHRvbXMgPSAiZGlzZWFzZSIsDQogICAgICAgICAgICAgICAgICAgIGltZ19oZWFsdGh5ID0gImhlYWx0aCIsDQogICAgICAgICAgICAgICAgICAgIGltZ19iYWNrZ3JvdW5kID0gImJhY2siLA0KICAgICAgICAgICAgICAgICAgICBkaXJfb3JpZ2luYWwgPSAiZGF0YS9kaXNlYXNlX3NldmVyaXR5L2JlYW5fc3BvdCIsDQogICAgICAgICAgICAgICAgICAgIGRpcl9wcm9jZXNzZWQgPSAiZGF0YS9kaXNlYXNlX3NldmVyaXR5L2JlYW5fc3BvdC9wcm9jZXNzZWQiLA0KICAgICAgICAgICAgICAgICAgICBzYXZlX2ltYWdlID0gVFJVRSwNCiAgICAgICAgICAgICAgICAgICAgc2hvd19jb250b3VyID0gRkFMU0UsDQogICAgICAgICAgICAgICAgICAgIHBhcmFsbGVsID0gVFJVRSkNCikNCmJlYW5fc3BvdCRzZXZlcml0eQ0KYGBgDQoNCg0KDQpgYGB7ciBiYXRjaDYsIGZpZy53aWR0aD0xMCwgZmlnLmhlaWdodD0xMH0NCiMgaW1hZ2UgZGlyZWN0b3J5DQpwYXRoX2JlYW5fcHJvYyA8LSAiRTovRGVza3RvcC9wYXBlcl9wbGltYW4vZGF0YS9kaXNlYXNlX3NldmVyaXR5L2JlYW5fc3BvdC9wcm9jZXNzZWQiDQpiZWFuX3Byb2MgPC0gaW1hZ2VfaW1wb3J0KHBhdHRlcm4gPSAicHJvYyIsIHBhdGggPSBwYXRoX2JlYW5fcHJvYykNCmltYWdlX2NvbWJpbmUoYmVhbl9wcm9jLCBuY29sID0gNSkNCg0KYGBgDQoNCg0KDQojIyMjIFVzaW5nIGFuIFJHQi1iYXNlZCBpbmRleA0KDQpgYGB7ciBiZWFubGVhZiwgZmlnLndpZHRoPTEwLCBmaWcuaGVpZ2h0PTEwfQ0KaW1nX2JlYW4gPC0gaW1hZ2VfaW1wb3J0KCJiZWFuX0YzLmpwZyIsIHBhdGggPSBwYXRoX2JlYW4sIHBsb3QgPSBUUlVFKQ0KDQoNCg0KYGBgDQoNCg0KRmlyc3QsIHdlIG5lZWQgdG8gY2hvb3NlIGFuIGluZGV4IHRvIHNlZ21lbnQgdGhlIGxlYWYgZnJvbSB0aGUgYmFja2dyb3VuZC4gVGhlIGBpbWFnZV9zZWdtZW50KClgIGZ1bmN0aW9uIGlzIHVzZWQgYWdhaW4uDQoNCmBgYHtyIHNlZ2JlYW4yLCBmaWcud2lkdGg9MTAsIGZpZy5oZWlnaHQ9MTB9DQppbWFnZV9zZWdtZW50KGltZ19iZWFuLCBpbmRleCA9ICJhbGwiKQ0KDQpgYGANCg0KTGV0J3MgdHJ5IHRvIHVzZSB0aGUgYE5CYCBpbmRleCB0byBzZWdtZW50IHRoZSBsZWFmIGFuZCBiYWNrZ3JvdW5kLCBhbmQgdGhlIGBOR1JESWAgYWdhaW4gdG8gc2VnbWVudCBsZXNpb24gYW5kIGhlYXRoeSB0aXNzdWVzLg0KDQoNCg0KYGBge3Igc2VnaXRlciwgZmlnLndpZHRoPTEwfQ0KDQpzZWcgPC0NCiAgaW1hZ2Vfc2VnbWVudF9pdGVyKGltZ19iZWFuLA0KICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBjKCJOQiIsICJOR1JESSIpLA0KICAgICAgICAgICAgICAgICAgICAgbnNlZyA9IDIsDQogICAgICAgICAgICAgICAgICAgICBuY29sID0gMykNCmBgYA0KDQoNCg0KYGBge3Igc2VndGhyZXNofQ0KIyBGaW5kIGEgdGhyZXNob2xkDQppbWdfaW5kIDwtIGltYWdlX2luZGV4KHNlZyRpbWFnZXMkc2VnMSwNCiAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAiTkdSREkiLA0KICAgICAgICAgICAgICAgICAgICAgICByZXNpemUgPSBGQUxTRSwNCiAgICAgICAgICAgICAgICAgICAgICAgc2hvd19pbWFnZSA9IEZBTFNFKQ0KcGxvdChpbWdfaW5kKQ0KYGBgDQoNCg0KDQpgYGB7cn0NCnN5c3RlbS50aW1lKA0KICBiZWFuX3Nwb3QyIDwtDQogICAgbWVhc3VyZV9kaXNlYXNlKHBhdHRlcm4gPSAiYmVhbiIsDQogICAgICAgICAgICAgICAgICAgIGluZGV4X2xiID0gIk5CIiwNCiAgICAgICAgICAgICAgICAgICAgaW5kZXhfZGggPSAiTkdSREkiLA0KICAgICAgICAgICAgICAgICAgICB0aHJlc2hvbGQgPSAwLA0KICAgICAgICAgICAgICAgICAgICBkaXJfb3JpZ2luYWwgPSAiZGF0YS9kaXNlYXNlX3NldmVyaXR5L2JlYW5fc3BvdCIsDQogICAgICAgICAgICAgICAgICAgIHNob3dfaW1hZ2UgPSBGQUxTRSwNCiAgICAgICAgICAgICAgICAgICAgcGFyYWxsZWwgPSBUUlVFKQ0KKQ0KDQoNCmBgYA0KDQoNCg0KDQpgYGB7ciBldmFsPUZBTFNFLCBlY2hvPUZBTFNFfQ0KZGZfcGFsMiA8LQ0KICBiZWFuX3Nwb3Qkc2V2ZXJpdHkgJT4lDQogIHNlbGVjdCgtaGVhbHRoeSkgJT4lDQogIHJlbmFtZShwYWxldHRlcyA9IHN5bXB0b21hdGljKQ0KZGZfcmdiMiA8LQ0KICBiZWFuX3Nwb3QyJHNldmVyaXR5ICU+JQ0KICBzZWxlY3QoLWhlYWx0aHkpICU+JQ0KICByZW5hbWUocmdiID0gc3ltcHRvbWF0aWMpDQoNCmRmX2JlYW4gPC0gbGVmdF9qb2luKGRmX3BhbDIsIGRmX3JnYjIpICU+JQ0KICBtdXRhdGUoZGlzZWFzZSA9ICJCZWFuIGFuZ3VsYXIgc3BvdCIpDQpkZl9zZXYgPC0gcmJpbmQoZGZfc295LCBkZl9iZWFuKQ0KYGBgDQoNCg0KDQoNCg0KDQoNCiMjIENvbmNvcmRhbmNlIGNvcnJlbGF0aW9uIGNvZWZmaWNpZW50DQoNCmBgYHtyIGNvcmNvcmRhbmNlfQ0KZGlzZWFzZSA8LSBpbXBvcnQoImRhdGEvZGlzZWFzZV9zZXZlcml0eS9kaXNlYXNlLnhsc3giKQ0KDQoNCmdncGFpcnMoZGlzZWFzZSwNCiAgICAgICAgbGVnZW5kID0gMSwNCiAgICAgICAgYWVzKGNvbG9yID0gZGlzZWFzZSwgZmlsbCA9IGRpc2Vhc2UpLA0KICAgICAgICBheGlzTGFiZWxzID0gIm5vbmUiLA0KICAgICAgICBjb2x1bW5zID0gYygiQXNzZXNzIiwgInBhbGV0dGVzIiwgIlJHQiIpLA0KICAgICAgICBsb3dlciA9IGxpc3QoY29udGludW91cyA9IGN1c3RvbV9zbW90aCksDQogICAgICAgIHVwcGVyID0gbGlzdChjb250aW51b3VzID0gY3VzdG9tX2NjYyksDQogICAgICAgIGRpYWcgPSBsaXN0KGNvbnRpbnVvdXMgPSB3cmFwKCJkZW5zaXR5RGlhZyIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhID0gIDAuNywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IDAuMiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IgPSAiYmxhY2siKSkpICsNCiAgbXlfdGhlbWUoKQ0KZ2dzYXZlKCJmaWdzL2Rpc2Vhc2Vfc2V2ZXJpdHkucGRmIiwgd2lkdGggPSA1LCBoZWlnaHQgPSA1KQ0KYGBgDQoNCiMjIExlc2lvbiBmZWF0dXJlcw0KSW4gdGhpcyBleGFtcGxlLCBJIHdpbGwgdXNlIGEgc2FtcGxlIG9mIGxlYWYgd2l0aCBzeW1wdG9tcyBvZiBzb3liZWFuIHJ1c3QgKCpQaGFrb3Bzb3JhIHBhY2h5cmhpemkqKS4NCg0KYGBge3J9DQoNCmxlc2lvbiA8LQ0KICBpbWFnZV9pbXBvcnQoImRhdGEvZGlzZWFzZV9zZXZlcml0eS9zb3liZWFuX3J1c3QvcnVzdC5wbmciLA0KICAgICAgICAgICAgICAgcGxvdCA9IFRSVUUpDQoNCmBgYA0KDQoNCkhlcmUsIGFuIFJHQi1iYXNlZCBpbmRleGUgd2lsbCBiZSB1c2VkIHRvIHNlZ21lbnQgdGhlIGRpc2Vhc2VkIGFuZCBoZWFsdGh5IHRpc3N1ZXMuIFRoZSBmaXJzdCBzdGVwIGlzIHRvIGNob29zZSBhbiBhcHByb3ByaWF0ZSBpbmRleC4NCg0KYGBge3IsIGZpZy53aWR0aD0xMH0NCmltYWdlX3NlZ21lbnQobGVzaW9uLCBpbmRleCA9ICJhbGwiKQ0KYGBgDQoNCkJvdGggYCJOR1JESSJgIGFuZCBgIlZBUkkiYCBwcm92aWRlZCBzYXRpc2ZhY3Rvcnkgc2VnbWVudGF0aW9uLiBTbywgdGhlIGAiTkdSREkiYCB3aWxsIGJlIGNob3Nlbi4gVGhlIG5leHQgc3RlcCBpcyB0byB1c2UgdGhlIGZ1bmN0aW9uIGBtZWFzdXJlX2Rpc2Vhc2UoKWAgd2l0aCB0aGUgYXJndW1lbnQgYGluZGV4X2RoYC4gTm90ZSB0aGF0IGBpbmRleF9sYmAgaXMgbm90IG1hbmRhdG9yeSBhbmQgd2lsbCBub3QgYmUgdXNlZCBoZXJlLCBzaW5jZSB0aGUgaW1hZ2UgaGFzIG5vIGJhY2tncm91bmQuDQoNCg0KYGBge3IsIGZpZy53aWR0aD0xMH0NCmxlcyA8LQ0KICBtZWFzdXJlX2Rpc2Vhc2UobGVzaW9uLA0KICAgICAgICAgICAgICAgICAgaW5kZXhfZGggPSAiTkdSREkiKQ0KbGVzJHNldmVyaXR5DQpgYGANCg0KVGhlIHJlc3VsdHMgc2hvdyBzYXRpc2ZhY3RvcnkgcmVzdWx0cy4gQWxsIGxlc2lvbnMgd2VyZSBpZGVudGlmaWVkIGFuZCB0aGUgc2V2ZXJpdHksIGluIHRoaXMgY2FzZSwgd2FzIH4xNCUuDQoNCkJ5IGRlZmF1bHQsIE90c3UncyB0aHJlc2hvbGRpbmcgbWV0aG9kIGlzIHVzZWQuIEJlbGxvdywgd2UgY2FuIHNlZSB3aGljaCB3YXMgdGhlIHRocmVzaG9sZCB2YWx1ZSB1c2VkIGluIHRoZSBzZWdtZW50YXRpb24uDQoNCmBgYHtyfQ0KaW5kZXhfbGVzaW9uIDwtIGltYWdlX2luZGV4KGxlc2lvbiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9ICJOR1JESSIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzaXplID0gRkFMU0UsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvd19pbWFnZSA9IEZBTFNFKQ0KRUJJbWFnZTo6b3RzdShpbmRleF9sZXNpb24kTkdSREksIHJhbmdlID0gcmFuZ2UoaW5kZXhfbGVzaW9uJE5HUkRJKSkNCmBgYA0KDQpVc2VycyBjYW4gc2V0IHRoZSBhcmd1bWVudCBgdGhyZXNob2xkYCBpbiBvcmRlciB0byBwcm92aWRlIG1vcmUgcmVsaWFibGUgc2VnbWVudGF0aW9ucy4gSWYgYW55IG5vbi1udW1lcmljIHZhbHVlIGRpZmZlcmVudCB0aGFuIGAiT3RzdSJgIGlzIHByb3ZpZGVkIGluIHRoZSBgdGhyZXNob2xkYCBhcmd1bWVudCwgYW4gaXRlcmF0aXZlIHNlY3Rpb24gd2lsbCBiZSBvcGVuIHNvIHRoYXQgdXNlcnMgY2FuIGNob29zZSBhIHRocmVzaG9sZCB2YWx1ZS4gSW4gdGhpcyBjYXNlLCBJIHdpbGwgc2ltcGx5IHBsb3QgdGhlIGluZGV4IGNvbXB1dGVkIGFib3ZlLg0KDQpgYGB7cn0NCnBsb3QoaW5kZXhfbGVzaW9uKQ0KYGBgDQoNCkluIHRoaXMgZXhhbXBsZSwgbmVnYXRpdmUgdmFsdWVzIG9mIGBOR1JESWAgYXJlIGF0dHJpYnV0ZWQgdG8gZGlzZWFzZWQgdGlzc3VlcyBhbmQgcG9zaXRpdmUgdG8gaGVhbHRoeSB0aXNzdWVzLiBMZXQncyBzZWUgaG93IHRoZSByZXN1bHRzIChib3RoIGZvciBzZXZlcml0eSBhbmQgbnVtYmVyIG9mIGxlc2lvbnMpIGNoYW5nZSB3aGVuIHRoZSBgdGhyZXNob2xkYCBhcmd1bWVudCBpcyB1c2VkLiBUbyBkbyB0aGF0LCB0aGUgYXJndW1lbnRzIGB3YXRlcnNoZWQgPSBUUlVFYChpbXBsZW1lbnQgdGhlIHdhdGVyc2hlZCBzZWdtZW50YXRpb24gYWxnb3JpdGhtKSBhbmQgYHNob3dfZmVhdHVyZXMgPSBUUlVFYCAoY29tcHV0ZSBsZXNpb25zJyBmZWF0dXJlcykgd2lsbCBiZSB1c2VkLg0KDQpgYGB7ciwgZmlnLndpZHRoPTEwfQ0KbGVzMiA8LQ0KICBtZWFzdXJlX2Rpc2Vhc2UobGVzaW9uLA0KICAgICAgICAgICAgICAgICAgaW5kZXhfZGggPSAiTkdSREkiLA0KICAgICAgICAgICAgICAgICAgdGhyZXNob2xkID0gMC4xLA0KICAgICAgICAgICAgICAgICAgd2F0ZXJzaGVkID0gVFJVRSwNCiAgICAgICAgICAgICAgICAgIHNob3dfZmVhdHVyZXMgPSBUUlVFKQ0KbGVzMiRzZXZlcml0eQ0KbGVzMiRzdGF0aXN0aWNzDQpgYGANCg0KDQoNCg0KYGBge3IsIGZpZy53aWR0aD0xMH0NCmxlczMgPC0NCiAgbWVhc3VyZV9kaXNlYXNlKGxlc2lvbiwNCiAgICAgICAgICAgICAgICAgIGluZGV4X2RoID0gIk5HUkRJIiwNCiAgICAgICAgICAgICAgICAgIHRocmVzaG9sZCA9IC0wLjEsDQogICAgICAgICAgICAgICAgICB3YXRlcnNoZWQgPSBUUlVFLA0KICAgICAgICAgICAgICAgICAgc2hvd19mZWF0dXJlcyA9IFRSVUUpDQpsZXMzJHNldmVyaXR5DQpsZXMzJHN0YXRpc3RpY3MNCmBgYA0KDQoNCg0KIyMgQmVuY2htYXJraW5nDQoNCmBgYHtyIGJlbmNobWFya2luZzIsIGZpZy53aWR0aD0xMH0NCg0KYmVuY2ggPC0gaW1wb3J0KCJkYXRhL2Rpc2Vhc2Vfc2V2ZXJpdHkvdGltZS54bHN4IikNCg0KDQpnZ3Bsb3QoYmVuY2gsIGFlcyhyZXNvbHV0aW9uLCBhdmcsIGZpbGwgPSBzdHJhdGVneSkpICsNCiAgZ2VvbV9jb2wocG9zaXRpb24gPSAgcG9zaXRpb25fZG9kZ2Uod2lkdGggPSAwLjkpKSArDQogICMgZmFjZXRfd3JhcCh+cmVzb2x1dGlvbikgKw0KICBzY2FsZV95X2NvbnRpbnVvdXMoZXhwYW5kID0gZXhwYW5zaW9uKGMoMC4wNSwgMC4xKSkpICsNCiAgZ2VvbV90ZXh0KGFlcyhsYWJlbCA9IHJvdW5kKGF2ZywgMikpLA0KICAgICAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbl9kb2RnZSh3aWR0aCA9IDAuOSksDQogICAgICAgICAgICB2anVzdCA9IC0wLjUsDQogICAgICAgICAgICBoanVzdCA9IDAuNSwNCiAgICAgICAgICAgIHNpemUgPSAzKSArDQogIG15X3RoZW1lKCkgKw0KICBsYWJzKHggPSAiRmlsdGVyIiwNCiAgICAgICB5ID0gZXhwcmVzc2lvbihQcm9jZXNzaW5nfnRpbWV+KHN+aW1hZ2Veey0xfSkpKQ0KZ2dzYXZlKCJmaWdzL2JlbmNobWFya2luZ19zZXYucGRmIiwgd2lkdGggPSA0LCBoZWlnaHQgPSA0LjUpDQpgYGANCg0KDQojIyBDaGFsbGVuZ2VzDQoNCiMjIyBsb3ctY29udHJhc3RpbmcgbGVzaW9ucw0KDQoNCmBgYHtyIGNoYWxsZW5nZTEsIGZpZy53aWR0aD0xMH0NCnBhdGhfY2hhbGxlbmdlIDwtICJkYXRhL2Rpc2Vhc2Vfc2V2ZXJpdHkvY2hhbGxlbmdlcyINCnBlcHBlciA8LSBpbWFnZV9pbXBvcnQoInBlcHBlci5wbmciLA0KICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gcGF0aF9jaGFsbGVuZ2UsDQogICAgICAgICAgICAgICAgICAgICAgIHBsb3QgPSBUUlVFKQ0KaW1hZ2VfaW5kZXgocGVwcGVyLCBpbmRleCA9ICJhbGwiLCByZXNpemUgPSBGQUxTRSkNCmBgYA0KDQoNCiMjIyBDb21wbGV4IGJhY2tncm91bmRzDQpTZWdtZW50aW5nIHRoZSBsZWFmIGZyb20gY29tcGxleCBiYWNrZ3JvdW5kcyBpcyBhIGNoYWxsZW5nZSBJbiB0aGUgZm9sbG93aW5nIGV4YW1wbGUsIGEgbWFpemUgbGVhZiBuZWVkcyB0byBiZSBzZWdtZW50ZWQgZnJvbSB0aGUgYmFja2dyb3VuZCB0aGF0IGNvbnRhaW5zIGJvdGggZ3JlZW4gbGVhdmVzIChzaW1pbGFyIHRvIGxlYWYpIGFuZCBzb2lsIChzaW1pbGFyIHRvIHRoZSBkaXNlYXNlKS4NCg0KYGBge3IgY2hhbGxlbmdlMiwgZmlnLndpZHRoPTEwfQ0KaW1nIDwtIA0KICBpbWFnZV9pbXBvcnQoIm1haXplXzEucG5nIiwNCiAgICAgICAgICAgICAgIHBhdGggPSBwYXRoX2NoYWxsZW5nZSwNCiAgICAgICAgICAgICAgIHBsb3QgPSBUUlVFKQ0KDQppbWFnZV9zZWdtZW50KGltZywgaW5kZXggPSAiYWxsIikNCmBgYA0KDQoNCkluIHRoZSBmb2xsb3dpbmcgZXhhbXBsZSwgdGhlIGJhY2tncm91bmQgaGF2ZSBzaW1pbGFyIGNvbG9yIHRoYW4gdGhlIG1pZHJpYi4gSW4gdGhpcyBjYXNlLCBjcm9wcGluZyB0aGUgaW1hZ2Ugc28gdGhhdCB0aGUgYmFja2dyb3VuZCBpcyByZW1vdmVkIHdvdWxkIHNvbHZlIHRoZSBpc3N1ZS4NCg0KYGBge3IgY2hhbGxlbmdlMywgZmlnLndpZHRoPTEwfQ0KDQppbWcyIDwtIA0KICBpbWFnZV9pbXBvcnQoIm1haXplXzIucG5nIiwNCiAgICAgICAgICAgICAgIHBhdGggPSBwYXRoX2NoYWxsZW5nZSwNCiAgICAgICAgICAgICAgIHBsb3QgPSBUUlVFKQ0KDQoNCmltYWdlX3NlZ21lbnQoaW1nMiwgaW5kZXggPSAiYWxsIikNCg0KDQoNCiMgY3JvcCB0aGUgaW1hZ2UgdG8gaXNvbGF0ZSB0aGUgYmFja2dyb3VuZA0KaW1nMl9jcm9wIDwtIGltYWdlX2Nyb3AoaW1nMiwNCiAgICAgICAgICAgICAgICAgICB3aWR0aCA9IDk1OTozMiwNCiAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSAxNjM6NTU3LA0KICAgICAgICAgICAgICAgICAgIHBsb3QgPSBUUlVFKQ0KDQppbWFnZV9zZWdtZW50KGltZzJfY3JvcCkNCg0KDQojIHVzZSB0aGUgTlIgaW5kZXggYW5kIGludmVydCB0aGUgc2VnbWVudGF0aW9uIHRvIGlzb2xhdGUgdGhlIGRpc2Vhc2VkIHRpc3N1ZXMNCm1lYXN1cmVfZGlzZWFzZShpbWcyX2Nyb3AsIA0KICAgICAgICAgICAgICAgIGluZGV4X2RoID0gIk5SIiwNCiAgICAgICAgICAgICAgICBpbnZlcnQgPSBUUlVFKQ0KDQpgYGANCg0KDQpJbiB0aGUgZm9sbG93aW5nIGltYWdlIGdhdGhlcmVkIGZyb20gQmFyYmVkbyAoMjAxNileW0JhcmJlZG8sIEouIEcuIEEuICgyMDE2KS4gQSByZXZpZXcgb24gdGhlIG1haW4gY2hhbGxlbmdlcyBpbiBhdXRvbWF0aWMgcGxhbnQgZGlzZWFzZSBpZGVudGlmaWNhdGlvbiBiYXNlZCBvbiB2aXNpYmxlIHJhbmdlIGltYWdlcy4gQmlvc3lzdGVtcyBFbmdpbmVlcmluZywgMTQ0LCA1MuKAkzYwLiBkb2k6MTAuMTAxNi9KLkJJT1NZU1RFTVNFTkcuMjAxNi4wMS4wMTddIGlzIHNob3duIGFuIGV4YW1wbGUgb2YgYW4gaW1hZ2UgY29udGFpbmluZyBzcGVjdWxhciByZWZsZWN0aW9ucyBhbmQgc2V2ZXJhbCBsaWdodC9zaGFkb3cgdHJhbnNpdGlvbnMuIFNlZ21lbnRpbmcgdGhlIGxlYWYsIGluIHRoaXMgY2FzZSwgaXMgdmVyeSBkaWZmaWN1bHQuDQoNCmBgYHtyIGNoYWxsZW5nZTQsIGZpZy53aWR0aD0xMH0NCg0KaW1nMyA8LSANCiAgaW1hZ2VfaW1wb3J0KCJtYWl6ZS5qcGciLA0KICAgICAgICAgICAgICAgcGF0aCA9IHBhdGhfY2hhbGxlbmdlLA0KICAgICAgICAgICAgICAgcGxvdCA9IFRSVUUpDQppbWFnZV9zZWdtZW50KGltZzMsIGluZGV4ID0gImFsbCIpDQoNCmBgYA0KDQoNCg==</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("code.Rmd");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
